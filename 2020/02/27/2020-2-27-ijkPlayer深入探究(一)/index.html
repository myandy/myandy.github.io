<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/img/avatar.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/img/avatar.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android,音视频,C,">










<meta name="description" content="Android硬解设置和解码流程深入解析">
<meta name="keywords" content="Android,音视频,C">
<meta property="og:type" content="article">
<meta property="og:title" content="ijkPlayer深入探究(一)">
<meta property="og:url" content="http://anddymao.com/2020/02/27/2020-2-27-ijkPlayer深入探究(一)/index.html">
<meta property="og:site_name" content="AnddyMao&#39;s Bolg">
<meta property="og:description" content="Android硬解设置和解码流程深入解析">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-02-28T01:39:34.076Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ijkPlayer深入探究(一)">
<meta name="twitter:description" content="Android硬解设置和解码流程深入解析">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://anddymao.com/2020/02/27/2020-2-27-ijkPlayer深入探究(一)/">





  <title>ijkPlayer深入探究(一) | AnddyMao's Bolg</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AnddyMao's Bolg</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Yesterday you said tomorrow</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://anddymao.com/2020/02/27/2020-2-27-ijkPlayer深入探究(一)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AnddyMao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/img/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnddyMao's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ijkPlayer深入探究(一)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-27T14:00:00+08:00">
                2020-02-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  Android硬解设置和解码流程深入解析
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ijkPlayer是开源做得最好的播放器，使用LGPL协议，非常适合播放器使用，也支持二次开发。<br>综合很多方案后，在项目中选用了ijkPlayer。ijkPlayer虽然使用广泛，人气非常高，核心代码解析也有不少，<br>但少有细节清楚的，还是得依靠源码。</p>
<p>所以接下来我会基于使用，来分享一些ijkPlayer中的知识点。<br>第一篇分析ijkPlayer的Android硬件解码流程。</p>
<h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><p>ijkplayer可以通过option设置做出很多更改，mediacodec解码部分就有以下这些配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, <span class="string">"mediacodec"</span>, <span class="number">1</span>);<span class="comment">//开启硬解码</span></span><br><span class="line">ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, <span class="string">"mediacodec-auto-rotate"</span>, value);</span><br><span class="line">ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, <span class="string">"mediacodec-handle-resolution-change"</span>, value);</span><br><span class="line"></span><br><span class="line">ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, <span class="string">"mediacodec-hevc"</span>, <span class="number">1</span>);</span><br><span class="line">ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, <span class="string">"mediacodec-sync"</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>为1时开启，为0时关闭。这些值默认都是关闭。官方demo里面有前三个。<br>“mediacodec”为是否开启硬解，<br>“mediacodec-auto-rotate”为是否自动旋转，<br>“mediacodec-handle-resolution-change”为是否自动分辨率更改，<br>“mediacodec-hevc”为是否支持h265,这个值要开启才能走h265的硬解，还有其它的格式配置没有列举。如果格式不支持就会硬解初始化不成功，转用软件解码。<br>“mediacodec-sync”为是否同步解码，异步效率更高。</p>
<p>这里配置名称要非常注意，java中写法都是”-“，而c代码中的配置都是”_”。比如mediacodec-hevc在源码中是mediacodec_hevc。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>分析源码首先是找到调用流程，把握整体脉络，再去细节上体会原理。<br>可以入口开始分析，也可以从出口分析。入口就是整体的启动，出口就是关键节点方法，比如MediaCodec的解码方法，FFmpeg的解码方法。<br>这里为叙述方便从入口分析。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>ijkplayer有一个管道的概念，不同平台走不同的管道方法.看ijkplayer/android下的文件。<br>入口就在ijkplayer_jni.c的IjkMediaPlayer_native_setup这个jni方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">IjkMediaPlayer_native_setup(JNIEnv *env, jobject thiz, jobject weak_this)</span><br><span class="line">&#123;</span><br><span class="line">    MPTRACE(<span class="string">"%s\n"</span>, __func__);</span><br><span class="line">    IjkMediaPlayer *mp = ijkmp_android_create(message_loop); </span><br><span class="line">    JNI_CHECK_GOTO(mp, env, <span class="string">"java/lang/OutOfMemoryError"</span>, <span class="string">"mpjni: native_setup: ijkmp_create() failed"</span>, LABEL_RETURN);</span><br><span class="line"></span><br><span class="line">    jni_set_media_player(env, thiz, mp);</span><br><span class="line">    ijkmp_set_weak_thiz(mp, (*env)-&gt;NewGlobalRef(env, weak_this));</span><br><span class="line">    ijkmp_set_inject_opaque(mp, ijkmp_get_weak_thiz(mp));</span><br><span class="line">    ijkmp_set_ijkio_inject_opaque(mp, ijkmp_get_weak_thiz(mp));</span><br><span class="line">    ijkmp_android_set_mediacodec_select_callback(mp, mediacodec_select_callback, ijkmp_get_weak_thiz(mp));</span><br><span class="line"></span><br><span class="line">LABEL_RETURN:</span><br><span class="line">    ijkmp_dec_ref_p(&amp;mp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>message_loop创建一个死循环，接受消息并再通过handler发送给Android层。<br>这些不细究，继续看ijkmp_android_create做了什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IjkMediaPlayer *<span class="title">ijkmp_android_create</span><span class="params">(<span class="keyword">int</span>(*msg_loop)(<span class="keyword">void</span>*))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IjkMediaPlayer *mp = ijkmp_create(msg_loop);</span><br><span class="line">    <span class="keyword">if</span> (!mp)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    mp-&gt;ffplayer-&gt;vout = SDL_VoutAndroid_CreateForAndroidSurface();</span><br><span class="line">    <span class="keyword">if</span> (!mp-&gt;ffplayer-&gt;vout)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    mp-&gt;ffplayer-&gt;pipeline = ffpipeline_create_from_android(mp-&gt;ffplayer);</span><br><span class="line">    <span class="keyword">if</span> (!mp-&gt;ffplayer-&gt;pipeline)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    ffpipeline_set_vout(mp-&gt;ffplayer-&gt;pipeline, mp-&gt;ffplayer-&gt;vout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mp;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    ijkmp_dec_ref_p(&amp;mp);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里设置了两个关键参数vout用于输出，pipeline用于解码，都是平台相关。显示部分就是surface转成nativewindow，再对应ffmpeg和mediacodec的使用。这部分不细究。<br>继续看ffpipeline_create_from_android如何做的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IJKFF_Pipeline *<span class="title">ffpipeline_create_from_android</span><span class="params">(FFPlayer *ffp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALOGD(<span class="string">"ffpipeline_create_from_android()\n"</span>);</span><br><span class="line">    IJKFF_Pipeline *pipeline = ffpipeline_alloc(&amp;g_pipeline_class, <span class="keyword">sizeof</span>(IJKFF_Pipeline_Opaque));</span><br><span class="line">    <span class="keyword">if</span> (!pipeline)</span><br><span class="line">        <span class="keyword">return</span> pipeline;</span><br><span class="line"></span><br><span class="line">    IJKFF_Pipeline_Opaque *opaque = pipeline-&gt;opaque;</span><br><span class="line">    opaque-&gt;ffp                   = ffp;</span><br><span class="line">    opaque-&gt;surface_mutex         = SDL_CreateMutex();</span><br><span class="line">    opaque-&gt;left_volume           = <span class="number">1.0f</span>;</span><br><span class="line">    opaque-&gt;right_volume          = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (!opaque-&gt;surface_mutex) &#123;</span><br><span class="line">        ALOGE(<span class="string">"ffpipeline-android:create SDL_CreateMutex failed\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pipeline-&gt;func_destroy              = func_destroy;</span><br><span class="line">    pipeline-&gt;func_open_video_decoder   = func_open_video_decoder;</span><br><span class="line">    pipeline-&gt;func_open_audio_output    = func_open_audio_output;</span><br><span class="line">    pipeline-&gt;func_init_video_decoder   = func_init_video_decoder;</span><br><span class="line">    pipeline-&gt;func_config_video_decoder = func_config_video_decoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pipeline;</span><br><span class="line">fail:</span><br><span class="line">    ffpipeline_free_p(&amp;pipeline);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有打开视频解码器和init视频解码器的方法，都由管道转发，在ffpipeline_android.c中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IJKFF_Pipenode* <span class="title">ffpipeline_open_video_decoder</span><span class="params">(IJKFF_Pipeline *pipeline, FFPlayer *ffp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline-&gt;func_open_video_decoder(pipeline, ffp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IJKFF_Pipenode* <span class="title">ffpipeline_init_video_decoder</span><span class="params">(IJKFF_Pipeline *pipeline, FFPlayer *ffp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline-&gt;func_init_video_decoder(pipeline, ffp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>func_open_video_decoder和func_init_video_decoder方法里面的实现很多是重复的，都是获取一个IJKFF_Pipenode。<br>我们再具体分析流程，找出原因。找调用发现ffpipeline_init_video_decoder在ffplay中准备阶段就调用了，在stream_open中被调用，而func_open_video_decoder在stream_component_open中被调用，且是node_vdec初始化失败才会调用。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">stream_component_open：</span><br><span class="line">       <span class="keyword">if</span> (ffp-&gt;async_init_decoder) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!is-&gt;initialized_decoder) &#123;</span><br><span class="line">                SDL_Delay(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ffp-&gt;node_vdec) &#123;</span><br><span class="line">                is-&gt;viddec.avctx = avctx;</span><br><span class="line">                ret = ffpipeline_config_video_decoder(ffp-&gt;pipeline, ffp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ret || !ffp-&gt;node_vdec) &#123;</span><br><span class="line">                decoder_init(&amp;is-&gt;viddec, avctx, &amp;is-&gt;videoq, is-&gt;continue_read_thread);</span><br><span class="line">                ffp-&gt;node_vdec = ffpipeline_open_video_decoder(ffp-&gt;pipeline, ffp);</span><br><span class="line">                <span class="keyword">if</span> (!ffp-&gt;node_vdec)</span><br><span class="line">                    <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decoder_init(&amp;is-&gt;viddec, avctx, &amp;is-&gt;videoq, is-&gt;continue_read_thread);</span><br><span class="line">            ffp-&gt;node_vdec = ffpipeline_open_video_decoder(ffp-&gt;pipeline, ffp);</span><br><span class="line">            <span class="keyword">if</span> (!ffp-&gt;node_vdec)</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = decoder_start(&amp;is-&gt;viddec, video_thread, ffp, <span class="string">"ff_video_dec"</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>
<p>这里看到更多细节，打开流时先看解码器初始化模式，如果是异步，没有初始化完成就dealy5毫秒。<br>再如果没有初始化完成，就是要ffpipeline_open_video_decoder启动。非异步就直接使用ffpipeline_open_video_decoder打开。结束后再打开video_thread线程，这个留待后面分析。<br>打开解码器方法func_open_video_decoder：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> IJKFF_Pipenode *<span class="title">func_open_video_decoder</span><span class="params">(IJKFF_Pipeline *pipeline, FFPlayer *ffp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IJKFF_Pipeline_Opaque *opaque = pipeline-&gt;opaque;</span><br><span class="line">    IJKFF_Pipenode        *node = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ffp-&gt;mediacodec_all_videos || ffp-&gt;mediacodec_avc || ffp-&gt;mediacodec_hevc || ffp-&gt;mediacodec_mpeg2)</span><br><span class="line">        node = ffpipenode_create_video_decoder_from_android_mediacodec(ffp, pipeline, opaque-&gt;weak_vout);</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        node = ffpipenode_create_video_decoder_from_ffplay(ffp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过格式支持先尝试打开硬件解码，如果node没有成功创建再使用ffplay进行软件解码。<br>再看ffpipenode_create_video_decoder_from_android_mediacodec方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IJKFF_Pipenode *<span class="title">ffpipenode_create_video_decoder_from_android_mediacodec</span><span class="params">(FFPlayer *ffp, IJKFF_Pipeline *pipeline, SDL_Vout *vout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALOGD(<span class="string">"ffpipenode_create_video_decoder_from_android_mediacodec()\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (SDL_Android_GetApiLevel() &lt; IJK_API_16_JELLY_BEAN)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ffp || !ffp-&gt;is)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    IJKFF_Pipenode *node = ffpipenode_alloc(<span class="keyword">sizeof</span>(IJKFF_Pipenode_Opaque));</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    VideoState            *is     = ffp-&gt;is;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque = node-&gt;opaque;</span><br><span class="line">    JNIEnv                *env    = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span>                    ret    = <span class="number">0</span>;</span><br><span class="line">    jobject                jsurface = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    node-&gt;func_destroy  = func_destroy;</span><br><span class="line">    <span class="comment">//设置解码线程</span></span><br><span class="line">    <span class="keyword">if</span> (ffp-&gt;mediacodec_sync) &#123;</span><br><span class="line">        node-&gt;func_run_sync = func_run_sync_loop;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;func_run_sync = func_run_sync;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;func_flush    = func_flush;</span><br><span class="line">    opaque-&gt;pipeline    = pipeline;</span><br><span class="line">    opaque-&gt;ffp         = ffp;</span><br><span class="line">    opaque-&gt;decoder     = &amp;is-&gt;viddec;</span><br><span class="line">    opaque-&gt;weak_vout   = vout;</span><br><span class="line"></span><br><span class="line">    opaque-&gt;codecpar = avcodec_parameters_alloc();</span><br><span class="line">    <span class="keyword">if</span> (!opaque-&gt;codecpar)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取解码器参数</span></span><br><span class="line">    ret = avcodec_parameters_from_context(opaque-&gt;codecpar, opaque-&gt;decoder-&gt;avctx);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opaque-&gt;codecpar-&gt;codec_id) &#123;</span><br><span class="line">    <span class="keyword">case</span> AV_CODEC_ID_H264:</span><br><span class="line">        <span class="keyword">if</span> (!ffp-&gt;mediacodec_avc &amp;&amp; !ffp-&gt;mediacodec_all_videos) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: MediaCodec: AVC/H264 is disabled. codec_id:%d \n"</span>, __func__, opaque-&gt;codecpar-&gt;codec_id);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (opaque-&gt;codecpar-&gt;profile) &#123;</span><br><span class="line">            <span class="keyword">case</span> FF_PROFILE_H264_BASELINE:</span><br><span class="line">                ALOGI(<span class="string">"%s: MediaCodec: H264_BASELINE: enabled\n"</span>, __func__);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FF_PROFILE_H264_CONSTRAINED_BASELINE:</span><br><span class="line">                ALOGI(<span class="string">"%s: MediaCodec: H264_CONSTRAINED_BASELINE: enabled\n"</span>, __func__);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">           ...</span><br><span class="line">    <span class="keyword">case</span> AV_CODEC_ID_HEVC:</span><br><span class="line">        <span class="keyword">if</span> (!ffp-&gt;mediacodec_hevc &amp;&amp; !ffp-&gt;mediacodec_all_videos) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: MediaCodec/HEVC is disabled. codec_id:%d \n"</span>, __func__, opaque-&gt;codecpar-&gt;codec_id);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(opaque-&gt;mcc.mime_type, SDL_AMIME_VIDEO_HEVC);</span><br><span class="line">        opaque-&gt;mcc.profile = opaque-&gt;codecpar-&gt;profile;</span><br><span class="line">        opaque-&gt;mcc.level   = opaque-&gt;codecpar-&gt;level;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">fail:</span><br><span class="line">    ffpipenode_free_p(&amp;node);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里通过mediacodec_sync这个配置设置了解码线程，同步则使用func_run_sync，异步使用func_run_sync。<br>通过codecpar的codec_id和profile的判断是否支持，不支持就会失败，然后回到前面走软解ffplay。</p>
<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><h4 id="启动解码线程"><a href="#启动解码线程" class="headerlink" title="启动解码线程"></a>启动解码线程</h4><p>通过初始化我们获得了IJKFF_Pipenode的节点管道，即ffp的node_vdec。且给node设置了func_run_sync方法。<br>func_run_sync在ff_ffpipenode.c中被转发：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffpipenode_run_sync</span><span class="params">(IJKFF_Pipenode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;func_run_sync(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如名称，这是一个线程。在ffplay中video_thread中被启动，就是前面stream_component_open中打开解码器后被调用的方法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">video_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFPlayer *ffp = (FFPlayer *)arg;</span><br><span class="line">    <span class="keyword">int</span>       ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ffp-&gt;node_vdec) &#123;</span><br><span class="line">        ret = ffpipenode_run_sync(ffp-&gt;node_vdec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="同步解码"><a href="#同步解码" class="headerlink" title="同步解码"></a>同步解码</h4><p>前面讲到mediacodec_sync设置，同步情况下就启动func_run_sync_loop方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func_run_sync_loop</span><span class="params">(IJKFF_Pipenode *node)</span> </span>&#123;</span><br><span class="line">    JNIEnv                *env           = <span class="literal">NULL</span>;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque        = node-&gt;opaque;</span><br><span class="line">    FFPlayer              *ffp           = opaque-&gt;ffp;</span><br><span class="line">    VideoState            *is            = ffp-&gt;is;</span><br><span class="line">    Decoder               *d             = &amp;is-&gt;viddec;</span><br><span class="line">    PacketQueue           *q             = d-&gt;<span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">int</span>                    ret           = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>                    dequeue_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>                    enqueue_count = <span class="number">0</span>;</span><br><span class="line">    AVFrame               *frame         = <span class="literal">NULL</span>;</span><br><span class="line">    AVRational             frame_rate    = av_guess_frame_rate(is-&gt;ic, is-&gt;video_st, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!opaque-&gt;acodec) &#123;</span><br><span class="line">        <span class="keyword">return</span> ffp_video_thread(ffp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (JNI_OK != SDL_JNI_SetupThreadEnv(&amp;env)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: SetupThreadEnv failed\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame = av_frame_alloc();</span><br><span class="line">    <span class="keyword">if</span> (!frame)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//关键代码</span></span><br><span class="line">    <span class="keyword">while</span> (!q-&gt;abort_request) &#123;</span><br><span class="line">        ret = drain_output_buffer2(env, node, AMC_SYNC_OUTPUT_TIMEOUT_US, &amp;dequeue_count, frame, frame_rate);</span><br><span class="line">        ret = feed_input_buffer2(env, node, AMC_SYNC_INPUT_TIMEOUT_US, &amp;enqueue_count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    av_frame_free(&amp;frame);</span><br><span class="line">    opaque-&gt;<span class="built_in">abort</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (opaque-&gt;n_buf_out) &#123;</span><br><span class="line">        <span class="built_in">free</span>(opaque-&gt;amc_buf_out);</span><br><span class="line">        opaque-&gt;n_buf_out = <span class="number">0</span>;</span><br><span class="line">        opaque-&gt;amc_buf_out = <span class="literal">NULL</span>;</span><br><span class="line">        opaque-&gt;off_buf_out = <span class="number">0</span>;</span><br><span class="line">        opaque-&gt;last_queued_pts = AV_NOPTS_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opaque-&gt;acodec) &#123;</span><br><span class="line">        SDL_VoutAndroid_invalidateAllBuffers(opaque-&gt;weak_vout);</span><br><span class="line">    &#125;</span><br><span class="line">    SDL_AMediaCodec_stop(opaque-&gt;acodec);</span><br><span class="line">    SDL_AMediaCodec_decreaseReferenceP(&amp;opaque-&gt;acodec);</span><br><span class="line">    ALOGI(<span class="string">"MediaCodec: %s: exit: %d"</span>, __func__, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键代码在while循环中，同步进行获取输出，填充输入。</p>
<p>看feed_input_buffer2方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">feed_input_buffer2</span><span class="params">(JNIEnv *env, IJKFF_Pipenode *node, <span class="keyword">int64_t</span> timeUs, <span class="keyword">int</span> *enqueue_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque   = node-&gt;opaque;</span><br><span class="line">    FFPlayer              *ffp      = opaque-&gt;ffp;</span><br><span class="line">    IJKFF_Pipeline        *pipeline = opaque-&gt;pipeline;</span><br><span class="line">    VideoState            *is       = ffp-&gt;is;</span><br><span class="line">    Decoder               *d        = &amp;is-&gt;viddec;</span><br><span class="line">    PacketQueue           *q        = d-&gt;<span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">sdl_amedia_status_t</span>    amc_ret  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>                    ret      = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span>  input_buffer_index     = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span>  copy_size              = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int64_t</span>  time_stamp             = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> queue_flags            = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enqueue_count)</span><br><span class="line">        *enqueue_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;abort_request) &#123;</span><br><span class="line">        ret = ACODEC_EXIT;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!d-&gt;packet_pending || d-&gt;<span class="built_in">queue</span>-&gt;serial != d-&gt;pkt_serial) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> AMC_USE_AVBITSTREAM_FILTER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        H264ConvertState convert_state = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">//数据源</span></span><br><span class="line">        AVPacket pkt;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;nb_packets == <span class="number">0</span>)</span><br><span class="line">                SDL_CondSignal(d-&gt;empty_queue_cond);</span><br><span class="line">            <span class="comment">//从队列获取数据</span></span><br><span class="line">            <span class="keyword">if</span> (ffp_packet_queue_get_or_buffering(ffp, d-&gt;<span class="built_in">queue</span>, &amp;pkt, &amp;d-&gt;pkt_serial, &amp;d-&gt;finished) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ret = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ffp_is_flush_packet(&amp;pkt) || opaque-&gt;acodec_flush_request) &#123;</span><br><span class="line">                <span class="comment">// request flush before lock, or never get mutex</span></span><br><span class="line">                opaque-&gt;acodec_flush_request = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (SDL_AMediaCodec_isStarted(opaque-&gt;acodec)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (opaque-&gt;input_packet_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// flush empty queue cause error on OMX.SEC.AVC.Decoder (Nexus S)</span></span><br><span class="line">                        SDL_VoutAndroid_invalidateAllBuffers(opaque-&gt;weak_vout);</span><br><span class="line">                        SDL_AMediaCodec_flush(opaque-&gt;acodec);</span><br><span class="line">                        opaque-&gt;input_packet_count = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// If codec is configured in synchronous mode, codec will resume automatically</span></span><br><span class="line">                    <span class="comment">// SDL_AMediaCodec_start(opaque-&gt;acodec);</span></span><br><span class="line">                &#125;</span><br><span class="line">                opaque-&gt;acodec_flush_request = <span class="literal">false</span>;</span><br><span class="line">                d-&gt;finished = <span class="number">0</span>;</span><br><span class="line">                d-&gt;next_pts = d-&gt;start_pts;</span><br><span class="line">                d-&gt;next_pts_tb = d-&gt;start_pts_tb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (ffp_is_flush_packet(&amp;pkt) || d-&gt;<span class="built_in">queue</span>-&gt;serial != d-&gt;pkt_serial);</span><br><span class="line">        av_packet_split_side_data(&amp;pkt);</span><br><span class="line">        av_packet_unref(&amp;d-&gt;pkt);</span><br><span class="line">        d-&gt;pkt_temp = d-&gt;pkt = pkt;</span><br><span class="line">        d-&gt;packet_pending = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ffp的配置之一，通过ffmpeg，处理大小变化</span></span><br><span class="line">        <span class="keyword">if</span> (opaque-&gt;ffp-&gt;mediacodec_handle_resolution_change &amp;&amp;</span><br><span class="line">            opaque-&gt;codecpar-&gt;codec_id == AV_CODEC_ID_H264) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span>  *size_data      = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">int</span>       size_data_size = <span class="number">0</span>;</span><br><span class="line">            AVPacket *avpkt          = &amp;d-&gt;pkt_temp;</span><br><span class="line">            size_data = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA, &amp;size_data_size);</span><br><span class="line">            <span class="comment">// minimum avcC(sps,pps) = 7</span></span><br><span class="line">            <span class="keyword">if</span> (size_data &amp;&amp; size_data_size &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span>             got_picture = <span class="number">0</span>;</span><br><span class="line">                AVFrame        *frame      = av_frame_alloc();</span><br><span class="line">                AVDictionary   *codec_opts = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">const</span> AVCodec  *codec      = opaque-&gt;decoder-&gt;avctx-&gt;codec;</span><br><span class="line">                AVCodecContext *new_avctx  = avcodec_alloc_context3(codec);</span><br><span class="line">                <span class="keyword">int</span> change_ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!new_avctx)</span><br><span class="line">                    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line"></span><br><span class="line">                avcodec_parameters_to_context(new_avctx, opaque-&gt;codecpar);</span><br><span class="line">                av_freep(&amp;new_avctx-&gt;extradata);</span><br><span class="line">                new_avctx-&gt;extradata = av_mallocz(size_data_size + AV_INPUT_BUFFER_PADDING_SIZE);</span><br><span class="line">                <span class="keyword">if</span> (!new_avctx-&gt;extradata) &#123;</span><br><span class="line">                    avcodec_free_context(&amp;new_avctx);</span><br><span class="line">                    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">memcpy</span>(new_avctx-&gt;extradata, size_data, size_data_size);</span><br><span class="line">                new_avctx-&gt;extradata_size = size_data_size;</span><br><span class="line"></span><br><span class="line">                av_dict_set(&amp;codec_opts, <span class="string">"threads"</span>, <span class="string">"1"</span>, <span class="number">0</span>);</span><br><span class="line">                change_ret = avcodec_open2(new_avctx, codec, &amp;codec_opts);</span><br><span class="line">                av_dict_free(&amp;codec_opts);</span><br><span class="line">                <span class="keyword">if</span> (change_ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    avcodec_free_context(&amp;new_avctx);</span><br><span class="line">                    <span class="keyword">return</span> change_ret;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                change_ret = avcodec_decode_video2(new_avctx, frame, &amp;got_picture, avpkt);</span><br><span class="line">                <span class="keyword">if</span> (change_ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    avcodec_free_context(&amp;new_avctx);</span><br><span class="line">                    <span class="keyword">return</span> change_ret;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (opaque-&gt;codecpar-&gt;width  != new_avctx-&gt;width &amp;&amp;</span><br><span class="line">                        opaque-&gt;codecpar-&gt;height != new_avctx-&gt;height) &#123;</span><br><span class="line">                        ALOGW(<span class="string">"AV_PKT_DATA_NEW_EXTRADATA: %d x %d\n"</span>, new_avctx-&gt;width, new_avctx-&gt;height);</span><br><span class="line">                        avcodec_parameters_from_context(opaque-&gt;codecpar, new_avctx);</span><br><span class="line">                        opaque-&gt;aformat_need_recreate = <span class="literal">true</span>;</span><br><span class="line">                        ffpipeline_set_surface_need_reconfigure_l(pipeline, <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                av_frame_unref(frame);</span><br><span class="line">                avcodec_free_context(&amp;new_avctx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        queue_flags = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取输入缓存队列</span></span><br><span class="line">        input_buffer_index = SDL_AMediaCodec_dequeueInputBuffer(opaque-&gt;acodec, timeUs);</span><br><span class="line">        <span class="keyword">if</span> (input_buffer_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (SDL_AMediaCodec_isInputBuffersValid(opaque-&gt;acodec)) &#123;</span><br><span class="line">                <span class="comment">// timeout</span></span><br><span class="line">                ret = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// enqueue fake frame</span></span><br><span class="line">                queue_flags |= AMEDIACODEC__BUFFER_FLAG_FAKE_FRAME;</span><br><span class="line">                copy_size    = d-&gt;pkt_temp.size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SDL_AMediaCodecFake_flushFakeFrames(opaque-&gt;acodec);</span><br><span class="line">            <span class="comment">//写数据</span></span><br><span class="line">            copy_size = SDL_AMediaCodec_writeInputData(opaque-&gt;acodec, input_buffer_index, d-&gt;pkt_temp.data, d-&gt;pkt_temp.size);</span><br><span class="line">            <span class="keyword">if</span> (!copy_size) &#123;</span><br><span class="line">                ALOGE(<span class="string">"%s: SDL_AMediaCodec_getInputBuffer failed\n"</span>, __func__);</span><br><span class="line">                ret = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        time_stamp = d-&gt;pkt_temp.pts;</span><br><span class="line">        <span class="keyword">if</span> (time_stamp == AV_NOPTS_VALUE &amp;&amp; d-&gt;pkt_temp.dts != AV_NOPTS_VALUE)</span><br><span class="line">            time_stamp = d-&gt;pkt_temp.dts;</span><br><span class="line">        <span class="keyword">if</span> (time_stamp &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            time_stamp = av_rescale_q(time_stamp, is-&gt;video_st-&gt;time_base, AV_TIME_BASE_Q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            time_stamp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ALOGE("queueInputBuffer, %lld\n", time_stamp);</span></span><br><span class="line">        <span class="comment">//buffer入队列</span></span><br><span class="line">        amc_ret = SDL_AMediaCodec_queueInputBuffer(opaque-&gt;acodec, input_buffer_index, <span class="number">0</span>, copy_size, time_stamp, queue_flags);</span><br><span class="line">        <span class="keyword">if</span> (amc_ret != SDL_AMEDIA_OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: SDL_AMediaCodec_getInputBuffer failed\n"</span>, __func__);</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ALOGE("%s: queue %d/%d", __func__, (int)copy_size, (int)input_buffer_size);</span></span><br><span class="line">        opaque-&gt;input_packet_count++;</span><br><span class="line">        <span class="keyword">if</span> (enqueue_count)</span><br><span class="line">            ++*enqueue_count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        d-&gt;packet_pending = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        d-&gt;pkt_temp.dts =</span><br><span class="line">        d-&gt;pkt_temp.pts = AV_NOPTS_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;pkt_temp.data) &#123;</span><br><span class="line">            d-&gt;pkt_temp.data += copy_size;</span><br><span class="line">            d-&gt;pkt_temp.size -= copy_size;</span><br><span class="line">            <span class="keyword">if</span> (d-&gt;pkt_temp.size &lt;= <span class="number">0</span>)</span><br><span class="line">                d-&gt;packet_pending = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">FIXME:</span> detect if decode finished</span></span><br><span class="line">            <span class="comment">// if (!got_frame) &#123;</span></span><br><span class="line">                d-&gt;packet_pending = <span class="number">0</span>;</span><br><span class="line">                d-&gt;finished = d-&gt;pkt_serial;</span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>了解MeidiaCodec就清楚输入流程了，看几个关键步骤就非常明了。<br>这里数据源是从ffp_packet_queue_get_or_buffering获取的，数据读取还是通过ffmpeg的avformat，没有通过Android的MediaExtractor，只是解码使用了mediacodec。<br>再看输出方法drain_output_buffer2：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drain_output_buffer2</span><span class="params">(JNIEnv *env, IJKFF_Pipenode *node, <span class="keyword">int64_t</span> timeUs, <span class="keyword">int</span> *dequeue_count, AVFrame *frame, AVRational frame_rate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque    = node-&gt;opaque;</span><br><span class="line">    FFPlayer              *ffp       = opaque-&gt;ffp;</span><br><span class="line">    VideoState            *is        = ffp-&gt;is;</span><br><span class="line">    AVRational            tb         = is-&gt;video_st-&gt;time_base;</span><br><span class="line">    <span class="keyword">int</span>                   got_frame  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>                   ret        = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">double</span>                duration;</span><br><span class="line">    <span class="keyword">double</span>                pts;</span><br><span class="line">    <span class="keyword">while</span> (ret) &#123;</span><br><span class="line">        got_frame = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//真正获取数据方法，数据在frame，是否获取是got_frame</span></span><br><span class="line">        ret = drain_output_buffer2_l(env, node, timeUs, dequeue_count, frame, &amp;got_frame);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opaque-&gt;decoder-&gt;<span class="built_in">queue</span>-&gt;abort_request) &#123;</span><br><span class="line">            <span class="keyword">if</span> (got_frame &amp;&amp; frame-&gt;opaque)</span><br><span class="line">                SDL_VoutAndroid_releaseBufferProxyP(opaque-&gt;weak_vout, (SDL_AMediaCodecBufferProxy **)&amp;frame-&gt;opaque, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ACODEC_EXIT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (got_frame &amp;&amp; frame-&gt;opaque)</span><br><span class="line">                SDL_VoutAndroid_releaseBufferProxyP(opaque-&gt;weak_vout, (SDL_AMediaCodecBufferProxy **)&amp;frame-&gt;opaque, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (got_frame) &#123;</span><br><span class="line">        duration = (frame_rate.num &amp;&amp; frame_rate.den ? av_q2d((AVRational)&#123;frame_rate.den, frame_rate.num&#125;) : <span class="number">0</span>);</span><br><span class="line">        pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);</span><br><span class="line">        <span class="keyword">if</span> (ffp-&gt;framedrop &gt; <span class="number">0</span> || (ffp-&gt;framedrop &amp;&amp; ffp_get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &#123;</span><br><span class="line">            ffp-&gt;stat.decode_frame_count++;</span><br><span class="line">            <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">                <span class="keyword">double</span> dpts = pts;</span><br><span class="line">                <span class="keyword">double</span> diff = dpts - ffp_get_master_clock(is);</span><br><span class="line">                <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD &amp;&amp;</span><br><span class="line">                    diff - is-&gt;frame_last_filter_delay &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    is-&gt;viddec.pkt_serial == is-&gt;vidclk.serial &amp;&amp;</span><br><span class="line">                    is-&gt;videoq.nb_packets) &#123;</span><br><span class="line">                    is-&gt;frame_drops_early++;</span><br><span class="line">                    is-&gt;continuous_frame_drops_early++;</span><br><span class="line">                    <span class="keyword">if</span> (is-&gt;continuous_frame_drops_early &gt; ffp-&gt;framedrop) &#123;</span><br><span class="line">                        is-&gt;continuous_frame_drops_early = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ffp-&gt;stat.drop_frame_count++;</span><br><span class="line">                        ffp-&gt;stat.drop_frame_rate = (<span class="keyword">float</span>)(ffp-&gt;stat.drop_frame_count) / (<span class="keyword">float</span>)(ffp-&gt;stat.decode_frame_count);</span><br><span class="line">                        <span class="keyword">if</span> (frame-&gt;opaque) &#123;</span><br><span class="line">                            SDL_VoutAndroid_releaseBufferProxyP(opaque-&gt;weak_vout, (SDL_AMediaCodecBufferProxy **)&amp;frame-&gt;opaque, <span class="literal">false</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        av_frame_unref(frame);</span><br><span class="line">                        <span class="keyword">return</span> ret;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = ffp_queue_picture(ffp, frame, pts, duration, av_frame_get_pkt_pos(frame), is-&gt;viddec.pkt_serial);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">if</span> (frame-&gt;opaque)</span><br><span class="line">                SDL_VoutAndroid_releaseBufferProxyP(opaque-&gt;weak_vout, (SDL_AMediaCodecBufferProxy **)&amp;frame-&gt;opaque, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        av_frame_unref(frame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取到frame后通过ffp_queue_picture去显示，看输出真正逻辑所在drain_output_buffer2_l方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drain_output_buffer2_l</span><span class="params">(JNIEnv *env, IJKFF_Pipenode *node, <span class="keyword">int64_t</span> timeUs, <span class="keyword">int</span> *dequeue_count, AVFrame *frame, <span class="keyword">int</span> *got_frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque         = node-&gt;opaque;</span><br><span class="line">    FFPlayer              *ffp            = opaque-&gt;ffp;</span><br><span class="line">    SDL_AMediaCodecBufferInfo bufferInfo;</span><br><span class="line">    <span class="keyword">ssize_t</span>          output_buffer_index  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dequeue_count)</span><br><span class="line">        *dequeue_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (JNI_OK != SDL_JNI_SetupThreadEnv(&amp;env)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s:create: SetupThreadEnv failed\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> ACODEC_RETRY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取输出buffer索引，然后是熟悉的返回值判断</span></span><br><span class="line">    output_buffer_index = SDL_AMediaCodecFake_dequeueOutputBuffer(opaque-&gt;acodec, &amp;bufferInfo, timeUs);</span><br><span class="line">    <span class="keyword">if</span> (output_buffer_index == AMEDIACODEC__INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">        ALOGD(<span class="string">"AMEDIACODEC__INFO_OUTPUT_BUFFERS_CHANGED\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ACODEC_RETRY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output_buffer_index == AMEDIACODEC__INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">        ALOGD(<span class="string">"AMEDIACODEC__INFO_OUTPUT_FORMAT_CHANGED\n"</span>);</span><br><span class="line">        SDL_AMediaFormat_deleteP(&amp;opaque-&gt;output_aformat);</span><br><span class="line">        opaque-&gt;output_aformat = SDL_AMediaCodec_getOutputFormat(opaque-&gt;acodec);</span><br><span class="line">        <span class="keyword">if</span> (opaque-&gt;output_aformat) &#123;</span><br><span class="line">            <span class="keyword">int</span> width        = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> height       = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> color_format = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> stride       = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> slice_height = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> crop_left    = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> crop_top     = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> crop_right   = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> crop_bottom  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"width"</span>,          &amp;width);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"height"</span>,         &amp;height);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"color-format"</span>,   &amp;color_format);</span><br><span class="line"></span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"stride"</span>,         &amp;stride);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"slice-height"</span>,   &amp;slice_height);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"crop-left"</span>,      &amp;crop_left);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"crop-top"</span>,       &amp;crop_top);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"crop-right"</span>,     &amp;crop_right);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"crop-bottom"</span>,    &amp;crop_bottom);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// TI decoder could crash after reconfigure</span></span><br><span class="line">            <span class="comment">// ffp_notify_msg3(ffp, FFP_MSG_VIDEO_SIZE_CHANGED, width, height);</span></span><br><span class="line">            <span class="comment">// opaque-&gt;frame_width  = width;</span></span><br><span class="line">            <span class="comment">// opaque-&gt;frame_height = height;</span></span><br><span class="line">            ALOGI(</span><br><span class="line">                <span class="string">"AMEDIACODEC__INFO_OUTPUT_FORMAT_CHANGED\n"</span></span><br><span class="line">                <span class="string">"    width-height: (%d x %d)\n"</span></span><br><span class="line">                <span class="string">"    color-format: (%s: 0x%x)\n"</span></span><br><span class="line">                <span class="string">"    stride:       (%d)\n"</span></span><br><span class="line">                <span class="string">"    slice-height: (%d)\n"</span></span><br><span class="line">                <span class="string">"    crop:         (%d, %d, %d, %d)\n"</span></span><br><span class="line">                ,</span><br><span class="line">                width, height,</span><br><span class="line">                SDL_AMediaCodec_getColorFormatName(color_format), color_format,</span><br><span class="line">                stride,</span><br><span class="line">                slice_height,</span><br><span class="line">                crop_left, crop_top, crop_right, crop_bottom);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ACODEC_RETRY;</span><br><span class="line">        <span class="comment">// continue;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output_buffer_index == AMEDIACODEC__INFO_TRY_AGAIN_LATER) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// continue;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output_buffer_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output_buffer_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ffp-&gt;stat.vdps = SDL_SpeedSamplerAdd(&amp;opaque-&gt;sampler, FFP_SHOW_VDPS_MEDIACODEC, <span class="string">"vdps[MediaCodec]"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//成功后计数加1</span></span><br><span class="line">        <span class="keyword">if</span> (dequeue_count)</span><br><span class="line">            ++*dequeue_count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opaque-&gt;n_buf_out) &#123;</span><br><span class="line">            AMC_Buf_Out *buf_out;</span><br><span class="line">            <span class="keyword">if</span> (opaque-&gt;off_buf_out &lt; opaque-&gt;n_buf_out) &#123;</span><br><span class="line">                <span class="comment">// ALOGD("filling buffer... %d", opaque-&gt;off_buf_out);</span></span><br><span class="line">                buf_out = &amp;opaque-&gt;amc_buf_out[opaque-&gt;off_buf_out++];</span><br><span class="line">                buf_out-&gt;acodec_serial = SDL_AMediaCodec_getSerial(opaque-&gt;acodec);</span><br><span class="line">                buf_out-&gt;port = output_buffer_index;</span><br><span class="line">                buf_out-&gt;info = bufferInfo;</span><br><span class="line">                buf_out-&gt;pts = pts_from_buffer_info(node, &amp;bufferInfo);</span><br><span class="line">                sort_amc_buf_out(opaque-&gt;amc_buf_out, opaque-&gt;off_buf_out);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">double</span> pts;</span><br><span class="line"></span><br><span class="line">                pts = pts_from_buffer_info(node, &amp;bufferInfo);</span><br><span class="line">                <span class="keyword">if</span> (opaque-&gt;last_queued_pts != AV_NOPTS_VALUE &amp;&amp;</span><br><span class="line">                    pts &lt; opaque-&gt;last_queued_pts) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">FIXME:</span> drop unordered picture to avoid dither</span></span><br><span class="line">                    <span class="comment">// ALOGE("early picture, drop!");</span></span><br><span class="line">                    <span class="comment">// SDL_AMediaCodec_releaseOutputBuffer(opaque-&gt;acodec, output_buffer_index, false);</span></span><br><span class="line">                    <span class="comment">// goto done;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* already sorted */</span></span><br><span class="line">                buf_out = &amp;opaque-&gt;amc_buf_out[opaque-&gt;off_buf_out - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">/* new picture is the most aged, send now */</span></span><br><span class="line">                <span class="keyword">if</span> (pts &lt; buf_out-&gt;pts) &#123;</span><br><span class="line">                    <span class="comment">//关键填充frame方法，多种条件触发</span></span><br><span class="line">                    amc_fill_frame(node, frame, got_frame, output_buffer_index, SDL_AMediaCodec_getSerial(opaque-&gt;acodec), &amp;bufferInfo);</span><br><span class="line">                    opaque-&gt;last_queued_pts = pts;</span><br><span class="line">                    <span class="comment">// ALOGD("pts = %f", pts);</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* find one to send */</span></span><br><span class="line">                    <span class="keyword">for</span> (i = opaque-&gt;off_buf_out - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        buf_out = &amp;opaque-&gt;amc_buf_out[i];</span><br><span class="line">                        <span class="keyword">if</span> (pts &gt; buf_out-&gt;pts) &#123;</span><br><span class="line">                            amc_fill_frame(node, frame, got_frame, buf_out-&gt;port, buf_out-&gt;acodec_serial, &amp;buf_out-&gt;info);</span><br><span class="line">                            opaque-&gt;last_queued_pts = buf_out-&gt;pts;</span><br><span class="line">                            <span class="comment">// ALOGD("pts = %f", buf_out-&gt;pts);</span></span><br><span class="line">                            <span class="comment">/* replace for sort later */</span></span><br><span class="line">                            buf_out-&gt;acodec_serial = SDL_AMediaCodec_getSerial(opaque-&gt;acodec);</span><br><span class="line">                            buf_out-&gt;port = output_buffer_index;</span><br><span class="line">                            buf_out-&gt;info = bufferInfo;</span><br><span class="line">                            buf_out-&gt;pts = pts_from_buffer_info(node, &amp;bufferInfo);</span><br><span class="line">                            sort_amc_buf_out(opaque-&gt;amc_buf_out, opaque-&gt;n_buf_out);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* need to discard current buffer */</span></span><br><span class="line">                    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// ALOGE("buffer too small, drop picture!");</span></span><br><span class="line">                        <span class="keyword">if</span> (!(bufferInfo.flags &amp; AMEDIACODEC__BUFFER_FLAG_FAKE_FRAME)) &#123;</span><br><span class="line">                            SDL_AMediaCodec_releaseOutputBuffer(opaque-&gt;acodec, output_buffer_index, <span class="literal">false</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            amc_fill_frame(node, frame, got_frame, output_buffer_index, SDL_AMediaCodec_getSerial(opaque-&gt;acodec), &amp;bufferInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到MediaCodec操作input的关键流程，最后通过amc_fill_frame填充frame，把数据交回ffplay进行显示。<br>继续看amc_fill_frame代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">amc_fill_frame</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IJKFF_Pipenode            *node,</span></span></span><br><span class="line"><span class="function"><span class="params">    AVFrame                   *frame,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>                       *got_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>                        output_buffer_index,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>                        acodec_serial,</span></span></span><br><span class="line"><span class="function"><span class="params">    SDL_AMediaCodecBufferInfo *buffer_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque     = node-&gt;opaque;</span><br><span class="line">    FFPlayer              *ffp        = opaque-&gt;ffp;</span><br><span class="line">    VideoState            *is         = ffp-&gt;is;</span><br><span class="line"></span><br><span class="line">    frame-&gt;opaque = SDL_VoutAndroid_obtainBufferProxy(opaque-&gt;weak_vout, acodec_serial, output_buffer_index, buffer_info);</span><br><span class="line">    <span class="keyword">if</span> (!frame-&gt;opaque)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    frame-&gt;width  = opaque-&gt;frame_width;</span><br><span class="line">    frame-&gt;height = opaque-&gt;frame_height;</span><br><span class="line">    frame-&gt;format = IJK_AV_PIX_FMT__ANDROID_MEDIACODEC;</span><br><span class="line">    frame-&gt;sample_aspect_ratio = opaque-&gt;codecpar-&gt;sample_aspect_ratio;</span><br><span class="line">    frame-&gt;pts    = av_rescale_q(buffer_info-&gt;presentationTimeUs, AV_TIME_BASE_Q, is-&gt;video_st-&gt;time_base);</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;pts &lt; <span class="number">0</span>)</span><br><span class="line">        frame-&gt;pts = AV_NOPTS_VALUE;</span><br><span class="line">    <span class="comment">// ALOGE("%s: %f", __func__, (float)frame-&gt;pts);</span></span><br><span class="line"></span><br><span class="line">    *got_frame = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">    *got_frame = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IJKFF_Pipenode_Opaque是解码结构体，用于输出和显示，在前面初始化IJKFF_Pipenode时也被创建。显示部分就不再分析。</p>
<h4 id="异步解码"><a href="#异步解码" class="headerlink" title="异步解码"></a>异步解码</h4><p>mediacodec_sync设置为0时开启异步解码，也是默认模式。看func_run_sync线程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func_run_sync</span><span class="params">(IJKFF_Pipenode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JNIEnv                *env      = <span class="literal">NULL</span>;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque   = node-&gt;opaque;</span><br><span class="line">    FFPlayer              *ffp      = opaque-&gt;ffp;</span><br><span class="line">    VideoState            *is       = ffp-&gt;is;</span><br><span class="line">    Decoder               *d        = &amp;is-&gt;viddec;</span><br><span class="line">    PacketQueue           *q        = d-&gt;<span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">int</span>                    ret      = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>                    dequeue_count = <span class="number">0</span>;</span><br><span class="line">    AVFrame               *frame    = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span>                    got_frame = <span class="number">0</span>;</span><br><span class="line">    AVRational             tb         = is-&gt;video_st-&gt;time_base;</span><br><span class="line">    AVRational             frame_rate = av_guess_frame_rate(is-&gt;ic, is-&gt;video_st, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">double</span>                 duration;</span><br><span class="line">    <span class="keyword">double</span>                 pts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再次容错切换软解</span></span><br><span class="line">    <span class="keyword">if</span> (!opaque-&gt;acodec) &#123;</span><br><span class="line">        <span class="keyword">return</span> ffp_video_thread(ffp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (JNI_OK != SDL_JNI_SetupThreadEnv(&amp;env)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: SetupThreadEnv failed\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame = av_frame_alloc();</span><br><span class="line">    <span class="keyword">if</span> (!frame)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过opaque开启input队列线程</span></span><br><span class="line">    opaque-&gt;enqueue_thread = SDL_CreateThreadEx(&amp;opaque-&gt;_enqueue_thread, enqueue_thread_func, node, <span class="string">"amediacodec_input_thread"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!opaque-&gt;enqueue_thread) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: SDL_CreateThreadEx failed\n"</span>, __func__);</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q-&gt;abort_request) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> timeUs = opaque-&gt;acodec_first_dequeue_output_request ? <span class="number">0</span> : AMC_OUTPUT_TIMEOUT_US;</span><br><span class="line">        got_frame = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取输出方法</span></span><br><span class="line">        ret = drain_output_buffer(env, node, timeUs, &amp;dequeue_count, frame, &amp;got_frame);</span><br><span class="line">        <span class="keyword">if</span> (opaque-&gt;acodec_first_dequeue_output_request) &#123;</span><br><span class="line">            SDL_LockMutex(opaque-&gt;acodec_first_dequeue_output_mutex);</span><br><span class="line">            opaque-&gt;acodec_first_dequeue_output_request = <span class="literal">false</span>;</span><br><span class="line">            SDL_CondSignal(opaque-&gt;acodec_first_dequeue_output_cond);</span><br><span class="line">            SDL_UnlockMutex(opaque-&gt;acodec_first_dequeue_output_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (got_frame &amp;&amp; frame-&gt;opaque)</span><br><span class="line">                SDL_VoutAndroid_releaseBufferProxyP(opaque-&gt;weak_vout, (SDL_AMediaCodecBufferProxy **)&amp;frame-&gt;opaque, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取到帧，和同步逻辑一样</span></span><br><span class="line">        <span class="keyword">if</span> (got_frame) &#123;</span><br><span class="line">            duration = (frame_rate.num &amp;&amp; frame_rate.den ? av_q2d((AVRational)&#123;frame_rate.den, frame_rate.num&#125;) : <span class="number">0</span>);</span><br><span class="line">            pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);</span><br><span class="line">            <span class="keyword">if</span> (ffp-&gt;framedrop &gt; <span class="number">0</span> || (ffp-&gt;framedrop &amp;&amp; ffp_get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &#123;</span><br><span class="line">                ffp-&gt;stat.decode_frame_count++;</span><br><span class="line">                <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">double</span> dpts = pts;</span><br><span class="line">                    <span class="keyword">double</span> diff = dpts - ffp_get_master_clock(is);</span><br><span class="line">                    <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD &amp;&amp;</span><br><span class="line">                        diff - is-&gt;frame_last_filter_delay &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        is-&gt;viddec.pkt_serial == is-&gt;vidclk.serial &amp;&amp;</span><br><span class="line">                        is-&gt;videoq.nb_packets) &#123;</span><br><span class="line">                        is-&gt;frame_drops_early++;</span><br><span class="line">                        is-&gt;continuous_frame_drops_early++;</span><br><span class="line">                        <span class="keyword">if</span> (is-&gt;continuous_frame_drops_early &gt; ffp-&gt;framedrop) &#123;</span><br><span class="line">                            is-&gt;continuous_frame_drops_early = <span class="number">0</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ffp-&gt;stat.drop_frame_count++;</span><br><span class="line">                            ffp-&gt;stat.drop_frame_rate = (<span class="keyword">float</span>)(ffp-&gt;stat.drop_frame_count) / (<span class="keyword">float</span>)(ffp-&gt;stat.decode_frame_count);</span><br><span class="line">                            <span class="keyword">if</span> (frame-&gt;opaque) &#123;</span><br><span class="line">                                SDL_VoutAndroid_releaseBufferProxyP(opaque-&gt;weak_vout, (SDL_AMediaCodecBufferProxy **)&amp;frame-&gt;opaque, <span class="literal">false</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            av_frame_unref(frame);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//推送显示</span></span><br><span class="line">            ret = ffp_queue_picture(ffp, frame, pts, duration, av_frame_get_pkt_pos(frame), is-&gt;viddec.pkt_serial);</span><br><span class="line">            <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                <span class="keyword">if</span> (frame-&gt;opaque)</span><br><span class="line">                    SDL_VoutAndroid_releaseBufferProxyP(opaque-&gt;weak_vout, (SDL_AMediaCodecBufferProxy **)&amp;frame-&gt;opaque, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            av_frame_unref(frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    av_frame_free(&amp;frame);</span><br><span class="line">    opaque-&gt;<span class="built_in">abort</span> = <span class="literal">true</span>;</span><br><span class="line">    SDL_WaitThread(opaque-&gt;enqueue_thread, <span class="literal">NULL</span>);</span><br><span class="line">    SDL_AMediaCodecFake_abort(opaque-&gt;acodec);</span><br><span class="line">    <span class="keyword">if</span> (opaque-&gt;n_buf_out) &#123;</span><br><span class="line">        <span class="built_in">free</span>(opaque-&gt;amc_buf_out);</span><br><span class="line">        opaque-&gt;n_buf_out = <span class="number">0</span>;</span><br><span class="line">        opaque-&gt;amc_buf_out = <span class="literal">NULL</span>;</span><br><span class="line">        opaque-&gt;off_buf_out = <span class="number">0</span>;</span><br><span class="line">        opaque-&gt;last_queued_pts = AV_NOPTS_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opaque-&gt;acodec) &#123;</span><br><span class="line">        SDL_VoutAndroid_invalidateAllBuffers(opaque-&gt;weak_vout);</span><br><span class="line">        SDL_LockMutex(opaque-&gt;acodec_mutex);</span><br><span class="line">        SDL_UnlockMutex(opaque-&gt;acodec_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    SDL_AMediaCodec_stop(opaque-&gt;acodec);</span><br><span class="line">    SDL_AMediaCodec_decreaseReferenceP(&amp;opaque-&gt;acodec);</span><br><span class="line">    ALOGI(<span class="string">"MediaCodec: %s: exit: %d"</span>, __func__, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">fallback_to_ffplay:</span><br><span class="line">    ALOGW(<span class="string">"fallback to ffplay decoder\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> ffp_video_thread(opaque-&gt;ffp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异步解码单独开启了输入的线程，输入输出分离，增加吞吐效率。<br>看输出关键方法drain_output_buffer：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drain_output_buffer</span><span class="params">(JNIEnv *env, IJKFF_Pipenode *node, <span class="keyword">int64_t</span> timeUs, <span class="keyword">int</span> *dequeue_count, AVFrame *frame, <span class="keyword">int</span> *got_frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque = node-&gt;opaque;</span><br><span class="line">    SDL_LockMutex(opaque-&gt;acodec_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (opaque-&gt;acodec_flush_request || opaque-&gt;acodec_reconfigure_request) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> invalid picture here?</span></span><br><span class="line">        <span class="comment">// let feed_input_buffer() get mutex</span></span><br><span class="line">        SDL_CondWaitTimeout(opaque-&gt;acodec_cond, opaque-&gt;acodec_mutex, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = drain_output_buffer_l(env, node, timeUs, dequeue_count, frame, got_frame);</span><br><span class="line">    SDL_UnlockMutex(opaque-&gt;acodec_mutex);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等待输出，然后调用核心方法drain_output_buffer_l：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drain_output_buffer_l</span><span class="params">(JNIEnv *env, IJKFF_Pipenode *node, <span class="keyword">int64_t</span> timeUs, <span class="keyword">int</span> *dequeue_count, AVFrame *frame, <span class="keyword">int</span> *got_frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque   = node-&gt;opaque;</span><br><span class="line">    FFPlayer              *ffp      = opaque-&gt;ffp;</span><br><span class="line">    <span class="keyword">int</span>                    ret      = <span class="number">0</span>;</span><br><span class="line">    SDL_AMediaCodecBufferInfo bufferInfo;</span><br><span class="line">    <span class="keyword">ssize_t</span>                   output_buffer_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dequeue_count)</span><br><span class="line">        *dequeue_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (JNI_OK != SDL_JNI_SetupThreadEnv(&amp;env)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s:create: SetupThreadEnv failed\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output_buffer_index = SDL_AMediaCodecFake_dequeueOutputBuffer(opaque-&gt;acodec, &amp;bufferInfo, timeUs);</span><br><span class="line">    <span class="keyword">if</span> (output_buffer_index == AMEDIACODEC__INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">        ALOGI(<span class="string">"AMEDIACODEC__INFO_OUTPUT_BUFFERS_CHANGED\n"</span>);</span><br><span class="line">        <span class="comment">// continue;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output_buffer_index == AMEDIACODEC__INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">        ALOGI(<span class="string">"AMEDIACODEC__INFO_OUTPUT_FORMAT_CHANGED\n"</span>);</span><br><span class="line">        SDL_AMediaFormat_deleteP(&amp;opaque-&gt;output_aformat);</span><br><span class="line">        opaque-&gt;output_aformat = SDL_AMediaCodec_getOutputFormat(opaque-&gt;acodec);</span><br><span class="line">        <span class="keyword">if</span> (opaque-&gt;output_aformat) &#123;</span><br><span class="line">            <span class="keyword">int</span> width        = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> height       = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> color_format = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> stride       = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> slice_height = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> crop_left    = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> crop_top     = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> crop_right   = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> crop_bottom  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"width"</span>,          &amp;width);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"height"</span>,         &amp;height);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"color-format"</span>,   &amp;color_format);</span><br><span class="line"></span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"stride"</span>,         &amp;stride);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"slice-height"</span>,   &amp;slice_height);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"crop-left"</span>,      &amp;crop_left);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"crop-top"</span>,       &amp;crop_top);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"crop-right"</span>,     &amp;crop_right);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"crop-bottom"</span>,    &amp;crop_bottom);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// TI decoder could crash after reconfigure</span></span><br><span class="line">            <span class="comment">// ffp_notify_msg3(ffp, FFP_MSG_VIDEO_SIZE_CHANGED, width, height);</span></span><br><span class="line">            <span class="comment">// opaque-&gt;frame_width  = width;</span></span><br><span class="line">            <span class="comment">// opaque-&gt;frame_height = height;</span></span><br><span class="line">            ALOGI(</span><br><span class="line">                <span class="string">"AMEDIACODEC__INFO_OUTPUT_FORMAT_CHANGED\n"</span></span><br><span class="line">                <span class="string">"    width-height: (%d x %d)\n"</span></span><br><span class="line">                <span class="string">"    color-format: (%s: 0x%x)\n"</span></span><br><span class="line">                <span class="string">"    stride:       (%d)\n"</span></span><br><span class="line">                <span class="string">"    slice-height: (%d)\n"</span></span><br><span class="line">                <span class="string">"    crop:         (%d, %d, %d, %d)\n"</span></span><br><span class="line">                ,</span><br><span class="line">                width, height,</span><br><span class="line">                SDL_AMediaCodec_getColorFormatName(color_format), color_format,</span><br><span class="line">                stride,</span><br><span class="line">                slice_height,</span><br><span class="line">                crop_left, crop_top, crop_right, crop_bottom);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// continue;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output_buffer_index == AMEDIACODEC__INFO_TRY_AGAIN_LATER) &#123;</span><br><span class="line">        AMCTRACE(<span class="string">"AMEDIACODEC__INFO_TRY_AGAIN_LATER\n"</span>);</span><br><span class="line">        <span class="comment">// continue;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output_buffer_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//没有输出时进行等待输入同步信号</span></span><br><span class="line">        SDL_LockMutex(opaque-&gt;any_input_mutex);</span><br><span class="line">        SDL_CondWaitTimeout(opaque-&gt;any_input_cond, opaque-&gt;any_input_mutex, <span class="number">1000</span>);</span><br><span class="line">        SDL_UnlockMutex(opaque-&gt;any_input_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output_buffer_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ffp-&gt;stat.vdps = SDL_SpeedSamplerAdd(&amp;opaque-&gt;sampler, FFP_SHOW_VDPS_MEDIACODEC, <span class="string">"vdps[MediaCodec]"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dequeue_count)</span><br><span class="line">            ++*dequeue_count;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FFP_SHOW_AMC_VDPS</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (opaque-&gt;benchmark_start_time == <span class="number">0</span>) &#123;</span><br><span class="line">                opaque-&gt;benchmark_start_time   = SDL_GetTickHR();</span><br><span class="line">            &#125;</span><br><span class="line">            opaque-&gt;benchmark_frame_count += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == (opaque-&gt;benchmark_frame_count % <span class="number">240</span>)) &#123;</span><br><span class="line">                Uint64 diff = SDL_GetTickHR() - opaque-&gt;benchmark_start_time;</span><br><span class="line">                <span class="keyword">double</span> per_frame_ms = ((<span class="keyword">double</span>) diff) / opaque-&gt;benchmark_frame_count;</span><br><span class="line">                <span class="keyword">double</span> fps          = ((<span class="keyword">double</span>) opaque-&gt;benchmark_frame_count) * <span class="number">1000</span> / diff;</span><br><span class="line">                ALOGE(<span class="string">"%lf fps, %lf ms/frame, %"</span>PRIu64<span class="string">" frames\n"</span>,</span><br><span class="line">                      fps, per_frame_ms, opaque-&gt;benchmark_frame_count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FFP_AMC_DISABLE_OUTPUT</span></span><br><span class="line">        <span class="keyword">if</span> (!(bufferInfo.flags &amp; AMEDIACODEC__BUFFER_FLAG_FAKE_FRAME)) &#123;</span><br><span class="line">            SDL_AMediaCodec_releaseOutputBuffer(opaque-&gt;acodec, output_buffer_index, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opaque-&gt;n_buf_out) &#123;</span><br><span class="line">            AMC_Buf_Out *buf_out;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (opaque-&gt;off_buf_out &lt; opaque-&gt;n_buf_out) &#123;</span><br><span class="line">                <span class="comment">// ALOGD("filling buffer... %d", opaque-&gt;off_buf_out);</span></span><br><span class="line">                buf_out = &amp;opaque-&gt;amc_buf_out[opaque-&gt;off_buf_out++];</span><br><span class="line">                buf_out-&gt;acodec_serial = SDL_AMediaCodec_getSerial(opaque-&gt;acodec);</span><br><span class="line">                buf_out-&gt;port = output_buffer_index;</span><br><span class="line">                buf_out-&gt;info = bufferInfo;</span><br><span class="line">                buf_out-&gt;pts = pts_from_buffer_info(node, &amp;bufferInfo);</span><br><span class="line">                sort_amc_buf_out(opaque-&gt;amc_buf_out, opaque-&gt;off_buf_out);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">double</span> pts;</span><br><span class="line"></span><br><span class="line">                pts = pts_from_buffer_info(node, &amp;bufferInfo);</span><br><span class="line">                <span class="keyword">if</span> (opaque-&gt;last_queued_pts != AV_NOPTS_VALUE &amp;&amp;</span><br><span class="line">                    pts &lt; opaque-&gt;last_queued_pts) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">FIXME:</span> drop unordered picture to avoid dither</span></span><br><span class="line">                    <span class="comment">// ALOGE("early picture, drop!");</span></span><br><span class="line">                    <span class="comment">// SDL_AMediaCodec_releaseOutputBuffer(opaque-&gt;acodec, output_buffer_index, false);</span></span><br><span class="line">                    <span class="comment">// goto done;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* already sorted */</span></span><br><span class="line">                buf_out = &amp;opaque-&gt;amc_buf_out[opaque-&gt;off_buf_out - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">/* new picture is the most aged, send now */</span></span><br><span class="line">                <span class="keyword">if</span> (pts &lt; buf_out-&gt;pts) &#123;</span><br><span class="line">                    ret = amc_fill_frame(node, frame, got_frame, output_buffer_index, SDL_AMediaCodec_getSerial(opaque-&gt;acodec), &amp;bufferInfo);</span><br><span class="line">                    opaque-&gt;last_queued_pts = pts;</span><br><span class="line">                    <span class="comment">// ALOGD("pts = %f", pts);</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* find one to send */</span></span><br><span class="line">                    <span class="keyword">for</span> (i = opaque-&gt;off_buf_out - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        buf_out = &amp;opaque-&gt;amc_buf_out[i];</span><br><span class="line">                        <span class="keyword">if</span> (pts &gt; buf_out-&gt;pts) &#123;</span><br><span class="line">                            ret = amc_fill_frame(node, frame, got_frame, buf_out-&gt;port, buf_out-&gt;acodec_serial, &amp;buf_out-&gt;info);</span><br><span class="line">                            opaque-&gt;last_queued_pts = buf_out-&gt;pts;</span><br><span class="line">                            <span class="comment">// ALOGD("pts = %f", buf_out-&gt;pts);</span></span><br><span class="line">                            <span class="comment">/* replace for sort later */</span></span><br><span class="line">                            buf_out-&gt;acodec_serial = SDL_AMediaCodec_getSerial(opaque-&gt;acodec);</span><br><span class="line">                            buf_out-&gt;port = output_buffer_index;</span><br><span class="line">                            buf_out-&gt;info = bufferInfo;</span><br><span class="line">                            buf_out-&gt;pts = pts_from_buffer_info(node, &amp;bufferInfo);</span><br><span class="line">                            sort_amc_buf_out(opaque-&gt;amc_buf_out, opaque-&gt;n_buf_out);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* need to discard current buffer */</span></span><br><span class="line">                    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// ALOGE("buffer too small, drop picture!");</span></span><br><span class="line">                        <span class="keyword">if</span> (!(bufferInfo.flags &amp; AMEDIACODEC__BUFFER_FLAG_FAKE_FRAME)) &#123;</span><br><span class="line">                            SDL_AMediaCodec_releaseOutputBuffer(opaque-&gt;acodec, output_buffer_index, <span class="literal">false</span>);</span><br><span class="line">                            <span class="keyword">goto</span> done;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret = amc_fill_frame(node, frame, got_frame, output_buffer_index, SDL_AMediaCodec_getSerial(opaque-&gt;acodec), &amp;bufferInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">if</span> (opaque-&gt;decoder-&gt;<span class="built_in">queue</span>-&gt;abort_request)</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>drain_output_buffer_l流程和drain_output_buffer2_l和差不多一样。<br>异步请求drain_output_buffer_l失败时会等待输入，<br>同步请求drain_output_buffer2_l失败时直接返回ACODEC_RETRY，直接失败。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前面已经把解码流程分析完毕，从option设置，到ffmPlayer初始化,再到解码器初始化，再分析到同步和异步解码。整体解码流程和管道使用都熟悉了。SDL的AMediaCodec方法如何调用到java的AMediaCodec还没有分析，这个留待下篇再分析。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/音视频/" rel="tag"># 音视频</a>
          
            <a href="/tags/C/" rel="tag"># C</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/18/2020-1-18-2019年终总结/" rel="next" title="2019年终总结：拓展新边界">
                <i class="fa fa-chevron-left"></i> 2019年终总结：拓展新边界
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/25/2020-6-25-ijkPlayer深入探究(二)/" rel="prev" title="ijkPlayer深入探究(二)">
                ijkPlayer深入探究(二) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/img/avatar.jpg" alt="AnddyMao">
            
              <p class="site-author-name" itemprop="name">AnddyMao</p>
              <p class="site-description motion-element" itemprop="description">Yesterday you said tomorrow</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:andymao1991@gmail.com" target="_blank" title="Email">
                      
                        <i class="fa fa-fw fa-globe"></i>Email</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.weibo.com/anddymao" target="_blank" title="新浪微博">
                      
                        <i class="fa fa-fw fa-globe"></i>新浪微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.github.com/myandy" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数设置"><span class="nav-number">2.</span> <span class="nav-text">参数设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分析"><span class="nav-number">3.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">3.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解码"><span class="nav-number">3.2.</span> <span class="nav-text">解码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#启动解码线程"><span class="nav-number">3.2.1.</span> <span class="nav-text">启动解码线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步解码"><span class="nav-number">3.2.2.</span> <span class="nav-text">同步解码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步解码"><span class="nav-number">3.2.3.</span> <span class="nav-text">异步解码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AnddyMao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

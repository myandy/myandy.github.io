<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/img/avatar.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/img/avatar.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android,Camera,">










<meta name="description" content="相机流程深入解析:高通Camera的HAL">
<meta name="keywords" content="Android,Camera">
<meta property="og:type" content="article">
<meta property="og:title" content="Android8.0相机源码深入解析(六)">
<meta property="og:url" content="http://anddymao.com/2018/06/13/2018-6-13-相机源码深入解析(六)/index.html">
<meta property="og:site_name" content="AnddyMao&#39;s Bolg">
<meta property="og:description" content="相机流程深入解析:高通Camera的HAL">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-02-27T06:56:26.027Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android8.0相机源码深入解析(六)">
<meta name="twitter:description" content="相机流程深入解析:高通Camera的HAL">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://anddymao.com/2018/06/13/2018-6-13-相机源码深入解析(六)/">





  <title>Android8.0相机源码深入解析(六) | AnddyMao's Bolg</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AnddyMao's Bolg</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Yesterday you said tomorrow</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://anddymao.com/2018/06/13/2018-6-13-相机源码深入解析(六)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AnddyMao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/img/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnddyMao's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android8.0相机源码深入解析(六)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-13T13:00:00+08:00">
                2018-06-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  相机流程深入解析:高通Camera的HAL
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>之前讲解的几篇相机解析文章虽然都有介绍到hal,但hal层都是点到为止.这一篇来详细讲一下hal的调用流程.基于android8.0的上的高通框架,代码可以在googlesource上下到.<br>本篇是基于API1分析.</p>
<p>本篇基于的源码链接:</p>
<p><a href="https://android.googlesource.com/platform/hardware/qcom/camera/+/android-8.1.0_r33" target="_blank" rel="noopener">https://android.googlesource.com/platform/hardware/qcom/camera/+/android-8.1.0_r33</a></p>
<h2 id="hal代码结构分析"><a href="#hal代码结构分析" class="headerlink" title="hal代码结构分析"></a>hal代码结构分析</h2><h3 id="接口部分"><a href="#接口部分" class="headerlink" title="接口部分"></a>接口部分</h3><p>hal接口方法定义在hardware/interface/camera里.hal接口以hal为后缀,写法类似java的接口.</p>
<p>ICameraDevice.hal,api1的接口方法,其它还包括ICameraDeviceCallback.hal和ICameraDevicePreviewCallback.hal,包含一些回调.<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.hardware.camera.device@<span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.common@<span class="number">1.0</span>::types;</span><br><span class="line"><span class="keyword">import</span> ICameraDeviceCallback;</span><br><span class="line"><span class="keyword">import</span> ICameraDevicePreviewCallback;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ICameraDevice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    getResourceCost() generates (Status status, CameraResourceCost resourceCost);</span><br><span class="line"></span><br><span class="line">    getCameraInfo() generates (Status status, CameraInfo info);</span><br><span class="line"></span><br><span class="line">    setTorchMode(TorchMode mode) generates (Status status);</span><br><span class="line"></span><br><span class="line">    dumpState(handle fd) generates (Status status);</span><br><span class="line"></span><br><span class="line">    open(ICameraDeviceCallback callback) generates (Status status);</span><br><span class="line"></span><br><span class="line">    setPreviewWindow(ICameraDevicePreviewCallback window)</span><br><span class="line">            generates (Status status);</span><br><span class="line"></span><br><span class="line">    enableMsgType(FrameCallbackFlags msgType);</span><br><span class="line"></span><br><span class="line">    disableMsgType(FrameCallbackFlags msgType);</span><br><span class="line"></span><br><span class="line">    msgTypeEnabled(FrameCallbackFlags msgType) generates (bool enabled);</span><br><span class="line"></span><br><span class="line">    startPreview() generates (Status status);</span><br><span class="line"></span><br><span class="line">    stopPreview();</span><br><span class="line"></span><br><span class="line">    previewEnabled() generates (bool enabled);</span><br><span class="line"></span><br><span class="line">    storeMetaDataInBuffers(bool enable) generates (Status status);</span><br><span class="line"></span><br><span class="line">    startRecording() generates (Status status);</span><br><span class="line"></span><br><span class="line">    stopRecording();</span><br><span class="line"></span><br><span class="line">    recordingEnabled() generates (bool enabled);</span><br><span class="line"></span><br><span class="line">    releaseRecordingFrame(MemoryId memId, uint32_t bufferIndex);</span><br><span class="line"></span><br><span class="line">    releaseRecordingFrameHandle(MemoryId memId, uint32_t bufferIndex, handle frame);</span><br><span class="line"></span><br><span class="line">    releaseRecordingFrameHandleBatch(vec&lt;VideoFrameMessage&gt; batch);</span><br><span class="line"></span><br><span class="line">    autoFocus() generates (Status status);</span><br><span class="line"></span><br><span class="line">    cancelAutoFocus() generates (Status status);</span><br><span class="line"></span><br><span class="line">    takePicture() generates (Status status);</span><br><span class="line"></span><br><span class="line">    cancelPicture() generates (Status status);</span><br><span class="line"></span><br><span class="line">    setParameters(string params) generates (Status status);</span><br><span class="line"></span><br><span class="line">    getParameters() generates (string parms);</span><br><span class="line"></span><br><span class="line">    sendCommand(CommandType cmd, int32_t arg1, int32_t arg2)</span><br><span class="line">            generates (Status status);</span><br><span class="line"></span><br><span class="line">    close();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>hardware接口方法写在libhardware/include/hardware/camera.h里,另外还有camera2.h,camera3.h和camera_common.h.</p>
<p>里面定义了一些hal层用到的struct,如camera_device,camera_device_ops_t等.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ANDROID_INCLUDE_CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_INCLUDE_CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"camera_common.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__BEGIN_DECLS</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">camera_memory</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*camera_release_memory)</span><span class="params">(struct camera_memory *mem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera_memory</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">void</span> *handle;</span><br><span class="line">    camera_release_memory release;</span><br><span class="line">&#125; <span class="keyword">camera_memory_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">camera_memory_t</span>* (*camera_request_memory)(<span class="keyword">int</span> fd, <span class="keyword">size_t</span> buf_size, <span class="keyword">unsigned</span> <span class="keyword">int</span> num_bufs,</span><br><span class="line">                                                  <span class="keyword">void</span> *user);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*camera_notify_callback)</span><span class="params">(<span class="keyword">int32_t</span> msg_type,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int32_t</span> ext1,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int32_t</span> ext2,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*camera_data_callback)</span><span class="params">(<span class="keyword">int32_t</span> msg_type,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">camera_memory_t</span> *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">camera_frame_metadata_t</span> *metadata, <span class="keyword">void</span> *user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*camera_data_timestamp_callback)</span><span class="params">(<span class="keyword">int64_t</span> timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int32_t</span> msg_type,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">camera_memory_t</span> *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_CAMERA_PREVIEW_WINDOW_TAG 0xcafed00d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">preview_stream_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*dequeue_buffer)(struct preview_stream_ops* w,</span><br><span class="line">                          <span class="keyword">buffer_handle_t</span>** buffer, <span class="keyword">int</span> *stride);</span><br><span class="line">    <span class="keyword">int</span> (*enqueue_buffer)(struct preview_stream_ops* w,</span><br><span class="line">                <span class="keyword">buffer_handle_t</span>* buffer);</span><br><span class="line">    <span class="keyword">int</span> (*cancel_buffer)(struct preview_stream_ops* w,</span><br><span class="line">                <span class="keyword">buffer_handle_t</span>* buffer);</span><br><span class="line">    <span class="keyword">int</span> (*set_buffer_count)(struct preview_stream_ops* w, <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">int</span> (*set_buffers_geometry)(struct preview_stream_ops* pw,</span><br><span class="line">                <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format);</span><br><span class="line">    <span class="keyword">int</span> (*set_crop)(struct preview_stream_ops *w,</span><br><span class="line">                <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom);</span><br><span class="line">    <span class="keyword">int</span> (*set_usage)(struct preview_stream_ops* w, <span class="keyword">int</span> usage);</span><br><span class="line">    <span class="keyword">int</span> (*set_swap_interval)(struct preview_stream_ops *w, <span class="keyword">int</span> interval);</span><br><span class="line">    <span class="keyword">int</span> (*get_min_undequeued_buffer_count)(<span class="keyword">const</span> struct preview_stream_ops *w,</span><br><span class="line">                <span class="keyword">int</span> *count);</span><br><span class="line">    <span class="keyword">int</span> (*lock_buffer)(struct preview_stream_ops* w,</span><br><span class="line">                <span class="keyword">buffer_handle_t</span>* buffer);</span><br><span class="line">    <span class="comment">// Timestamps are measured in nanoseconds, and must be comparable</span></span><br><span class="line">    <span class="comment">// and monotonically increasing between two frames in the same</span></span><br><span class="line">    <span class="comment">// preview stream. They do not need to be comparable between</span></span><br><span class="line">    <span class="comment">// consecutive or parallel preview streams, cameras, or app runs.</span></span><br><span class="line">    <span class="keyword">int</span> (*set_timestamp)(struct preview_stream_ops *w, <span class="keyword">int64_t</span> timestamp);</span><br><span class="line">&#125; <span class="keyword">preview_stream_ops_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">camera_device</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera_device_ops</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Start preview mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*start_preview)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stop a previously started preview.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*stop_preview)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if preview is enabled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*preview_enabled)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*store_meta_data_in_buffers)(struct camera_device *, <span class="keyword">int</span> enable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Start record mode. When a record image is available, a</span></span><br><span class="line"><span class="comment">     * CAMERA_MSG_VIDEO_FRAME message is sent with the corresponding</span></span><br><span class="line"><span class="comment">     * frame. Every record frame must be released by a camera HAL client via</span></span><br><span class="line"><span class="comment">     * releaseRecordingFrame() before the client calls</span></span><br><span class="line"><span class="comment">     * disableMsgType(CAMERA_MSG_VIDEO_FRAME). After the client calls</span></span><br><span class="line"><span class="comment">     * disableMsgType(CAMERA_MSG_VIDEO_FRAME), it is the camera HAL's</span></span><br><span class="line"><span class="comment">     * responsibility to manage the life-cycle of the video recording frames,</span></span><br><span class="line"><span class="comment">     * and the client must not modify/access any video recording frames.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*start_recording)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stop a previously started recording.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*stop_recording)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if recording is enabled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*recording_enabled)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Release a record frame previously returned by CAMERA_MSG_VIDEO_FRAME.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It is camera HAL client's responsibility to release video recording</span></span><br><span class="line"><span class="comment">     * frames sent out by the camera HAL before the camera HAL receives a call</span></span><br><span class="line"><span class="comment">     * to disableMsgType(CAMERA_MSG_VIDEO_FRAME). After it receives the call to</span></span><br><span class="line"><span class="comment">     * disableMsgType(CAMERA_MSG_VIDEO_FRAME), it is the camera HAL's</span></span><br><span class="line"><span class="comment">     * responsibility to manage the life-cycle of the video recording frames.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*release_recording_frame)(struct camera_device *,</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">void</span> *opaque);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Start auto focus, the notification callback routine is called with</span></span><br><span class="line"><span class="comment">     * CAMERA_MSG_FOCUS once when focusing is complete. autoFocus() will be</span></span><br><span class="line"><span class="comment">     * called again if another auto focus is needed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*auto_focus)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cancels auto-focus function. If the auto-focus is still in progress,</span></span><br><span class="line"><span class="comment">     * this function will cancel it. Whether the auto-focus is in progress or</span></span><br><span class="line"><span class="comment">     * not, this function will return the focus position to the default.  If</span></span><br><span class="line"><span class="comment">     * the camera does not support auto-focus, this is a no-op.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*cancel_auto_focus)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Take a picture.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*take_picture)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cancel a picture that was started with takePicture. Calling this method</span></span><br><span class="line"><span class="comment">     * when no picture is being taken is a no-op.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*cancel_picture)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the camera parameters. This returns BAD_VALUE if any parameter is</span></span><br><span class="line"><span class="comment">     * invalid or not supported.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*set_parameters)(struct camera_device *, <span class="keyword">const</span> <span class="keyword">char</span> *parms);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Retrieve the camera parameters.  The buffer returned by the camera HAL</span></span><br><span class="line"><span class="comment">        must be returned back to it with put_parameters, if put_parameters</span></span><br><span class="line"><span class="comment">        is not NULL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span> *(*get_parameters)(struct camera_device *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The camera HAL uses its own memory to pass us the parameters when we</span></span><br><span class="line"><span class="comment">        call get_parameters.  Use this function to return the memory back to</span></span><br><span class="line"><span class="comment">        the camera HAL, if put_parameters is not NULL.  If put_parameters</span></span><br><span class="line"><span class="comment">        is NULL, then you have to use free() to release the memory.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> (*put_parameters)(struct camera_device *, <span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">camera_device_ops_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera_device</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * camera_device.common.version must be in the range</span></span><br><span class="line"><span class="comment">     * HARDWARE_DEVICE_API_VERSION(0,0)-(1,FF). CAMERA_DEVICE_API_VERSION_1_0 is</span></span><br><span class="line"><span class="comment">     * recommended.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">hw_device_t</span> common;</span><br><span class="line">    <span class="keyword">camera_device_ops_t</span> *ops;</span><br><span class="line">    <span class="keyword">void</span> *priv;</span><br><span class="line">&#125; <span class="keyword">camera_device_t</span>;</span><br></pre></td></tr></table></figure>
<h3 id="hal代码结构"><a href="#hal代码结构" class="headerlink" title="hal代码结构"></a>hal代码结构</h3><p>hal代码在QCamera2下,HAL,HAL3,stack,utils等包.从Android.mk找LOCAL_SRC_FILES,即用到的源码.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_SRC_FILES := \</span><br><span class="line">        util/QCameraBufferMaps.cpp \</span><br><span class="line">        util/QCameraCmdThread.cpp \</span><br><span class="line">        util/QCameraFlash.cpp \</span><br><span class="line">        util/QCameraPerf.cpp \</span><br><span class="line">        util/QCameraQueue.cpp \</span><br><span class="line">        util/QCameraCommon.cpp \</span><br><span class="line">        util/QCameraTrace.cpp \</span><br><span class="line">        util/camscope_packet_type.cpp \</span><br><span class="line">        QCamera2Hal.cpp \</span><br><span class="line">        QCamera2Factory.cpp</span><br><span class="line">ifeq ($(TARGET_SUPPORT_HAL1),<span class="literal">false</span>)</span><br><span class="line">LOCAL_CFLAGS += -DQCAMERA_HAL3_SUPPORT</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LOCAL_CFLAGS += -DQCAMERA_HAL1_SUPPORT</span><br><span class="line">LOCAL_SRC_FILES += \</span><br><span class="line">        HAL/QCamera2HWI.cpp \</span><br><span class="line">        HAL/QCameraMuxer.cpp \</span><br><span class="line">        HAL/QCameraMem.cpp \</span><br><span class="line">        HAL/QCameraStateMachine.cpp \</span><br><span class="line">        HAL/QCameraChannel.cpp \</span><br><span class="line">        HAL/QCameraStream.cpp \</span><br><span class="line">        HAL/QCameraPostProc.cpp \</span><br><span class="line">        HAL/QCamera2HWICallbacks.cpp \</span><br><span class="line">        HAL/QCameraParameters.cpp \</span><br><span class="line">        HAL/QCameraParametersIntf.cpp \</span><br><span class="line">        HAL/QCameraThermalAdapter.cpp \</span><br><span class="line">        util/QCameraFOVControl.cpp \</span><br><span class="line">        util/QCameraHALPP.cpp \</span><br><span class="line">        util/QCameraDualFOVPP.cpp \</span><br><span class="line">        util/QCameraExtZoomTranslator.cpp</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>第一部分是公共的,第二部分是hal1的.</p>
<h2 id="hal打开设备流程"><a href="#hal打开设备流程" class="headerlink" title="hal打开设备流程"></a>hal打开设备流程</h2><h3 id="模块注册"><a href="#模块注册" class="headerlink" title="模块注册"></a>模块注册</h3><p>先看公共部分的QCamera2Hal.cpp:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"QCamera2Factory.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"HAL3/QCamera3VendorTags.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">hw_module_t</span> camera_common = &#123;</span><br><span class="line">    .tag                    = HARDWARE_MODULE_TAG,</span><br><span class="line">    .module_api_version     = CAMERA_MODULE_API_VERSION_2_4,</span><br><span class="line">    .hal_api_version        = HARDWARE_HAL_API_VERSION,</span><br><span class="line">    .id                     = CAMERA_HARDWARE_MODULE_ID,</span><br><span class="line">    .name                   = <span class="string">"QCamera Module"</span>,</span><br><span class="line">    .author                 = <span class="string">"Qualcomm Innovation Center Inc"</span>,</span><br><span class="line">    .methods                = &amp;qcamera::QCamera2Factory::mModuleMethods,</span><br><span class="line">    .dso                    = <span class="literal">NULL</span>,</span><br><span class="line">    .reserved               = &#123;<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">camera_module_t</span> HAL_MODULE_INFO_SYM = &#123;</span><br><span class="line">    .common                 = camera_common,</span><br><span class="line">    .get_number_of_cameras  = qcamera::QCamera2Factory::get_number_of_cameras,</span><br><span class="line">    .get_camera_info        = qcamera::QCamera2Factory::get_camera_info,</span><br><span class="line">    .set_callbacks          = qcamera::QCamera2Factory::set_callbacks,</span><br><span class="line">    .get_vendor_tag_ops     = qcamera::QCamera3VendorTags::get_vendor_tag_ops,</span><br><span class="line">    .open_legacy            = <span class="literal">NULL</span>,</span><br><span class="line">    .set_torch_mode         = qcamera::QCamera2Factory::set_torch_mode,</span><br><span class="line">    .init                   = <span class="literal">NULL</span>,</span><br><span class="line">    .reserved               = &#123;<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个hardware模块模板hw_module_t,有模块名,版本,方法等,每一个hal模块都需要定义一个hw_module_t.<br>camera_module_t定义在前面讲的camera_common.h中,包含一些获取相机模块基础信息的方法.</p>
<h3 id="QCamera2Factory"><a href="#QCamera2Factory" class="headerlink" title="QCamera2Factory"></a>QCamera2Factory</h3><p>获取信息的方法都非常简单,可以在QCamera2Factory看到,我们继续探究模块方法mModuleMethods:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : cameraDeviceOpen</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: open a camera device with its ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @camera_id : camera ID</span></span><br><span class="line"><span class="comment"> *   @hw_device : ptr to struct storing camera hardware device info</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : int32_t type of status</span></span><br><span class="line"><span class="comment"> *              NO_ERROR  -- success</span></span><br><span class="line"><span class="comment"> *              none-zero failure code</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">int</span> QCamera2Factory::cameraDeviceOpen(<span class="keyword">int</span> camera_id,</span><br><span class="line">                    struct <span class="keyword">hw_device_t</span> **hw_device)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = NO_ERROR;</span><br><span class="line">    <span class="keyword">if</span> (camera_id &lt; <span class="number">0</span> || camera_id &gt;= mNumOfCameras)</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == mHalDescriptors ) &#123;</span><br><span class="line">        LOGE(<span class="string">"Hal descriptor table is not initialized!"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGI(<span class="string">"Open camera id %d API version %d"</span>,</span><br><span class="line">            camera_id, mHalDescriptors[camera_id].device_version);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( mHalDescriptors[camera_id].device_version == CAMERA_DEVICE_API_VERSION_3_0 ) &#123;</span><br><span class="line">        CAMSCOPE_INIT(CAMSCOPE_SECTION_HAL);</span><br><span class="line">        QCamera3HardwareInterface *hw = <span class="keyword">new</span> QCamera3HardwareInterface(mHalDescriptors[camera_id].cameraId,</span><br><span class="line">                mCallbacks);</span><br><span class="line">        <span class="keyword">if</span> (!hw) &#123;</span><br><span class="line">            LOGE(<span class="string">"Allocation of hardware interface failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">        &#125;</span><br><span class="line">        rc = hw-&gt;openCamera(hw_device);</span><br><span class="line">        <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> hw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> QCAMERA_HAL1_SUPPORT</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mHalDescriptors[camera_id].device_version == CAMERA_DEVICE_API_VERSION_1_0) &#123;</span><br><span class="line">        QCamera2HardwareInterface *hw = <span class="keyword">new</span> QCamera2HardwareInterface((<span class="keyword">uint32_t</span>)camera_id);</span><br><span class="line">        <span class="keyword">if</span> (!hw) &#123;</span><br><span class="line">            LOGE(<span class="string">"Allocation of hardware interface failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">        &#125;</span><br><span class="line">        rc = hw-&gt;openCamera(hw_device);</span><br><span class="line">        <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">            <span class="keyword">delete</span> hw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGE(<span class="string">"Device version for camera id %d invalid %d"</span>,</span><br><span class="line">              camera_id,</span><br><span class="line">              mHalDescriptors[camera_id].device_version);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : camera_device_open</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: static function to open a camera device by its ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @camera_id : camera ID</span></span><br><span class="line"><span class="comment"> *   @hw_device : ptr to struct storing camera hardware device info</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : int32_t type of status</span></span><br><span class="line"><span class="comment"> *              NO_ERROR  -- success</span></span><br><span class="line"><span class="comment"> *              none-zero failure code</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">int</span> QCamera2Factory::camera_device_open(</span><br><span class="line">    <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> *<span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span> *id,</span><br><span class="line">    struct <span class="keyword">hw_device_t</span> **hw_device)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = NO_ERROR;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span> != &amp;HAL_MODULE_INFO_SYM.common) &#123;</span><br><span class="line">        LOGE(<span class="string">"Invalid module. Trying to open %p, expect %p"</span>,</span><br><span class="line">            <span class="keyword">module</span>, &amp;HAL_MODULE_INFO_SYM.common);</span><br><span class="line">        <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!id) &#123;</span><br><span class="line">        LOGE(<span class="string">"Invalid camera id"</span>);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> QCAMERA_HAL1_SUPPORT</span></span><br><span class="line">    <span class="keyword">if</span>(gQCameraMuxer)</span><br><span class="line">        rc =  gQCameraMuxer-&gt;camera_device_open(<span class="keyword">module</span>, id, hw_device);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">        rc = gQCamera2Factory-&gt;cameraDeviceOpen(atoi(id), hw_device);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> <span class="title">QCamera2Factory</span>:</span>:mModuleMethods = &#123;</span><br><span class="line">    .open = QCamera2Factory::camera_device_open,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>模块方法只有一个open方法,然后如果支持是hal1多摄,则走QCameraMuxer,如何是hal3,直接走QCamera3HardwareInterface,否则走QCamera2HardwareInterface.最后都会调用openCamera方法.<br>QCameraMuxer用于多个物理相机对应一个逻辑相机,这部分不细看.继续看QCamera2HardwareInterface的openCamera方法.<br>QCamera2HardwareInterface定义在QCamera2HWI里,就是一个简写.</p>
<h3 id="QCamera2HardwareInterface"><a href="#QCamera2HardwareInterface" class="headerlink" title="QCamera2HardwareInterface"></a>QCamera2HardwareInterface</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QCamera2HardwareInterface::openCamera(struct <span class="keyword">hw_device_t</span> **hw_device)</span><br><span class="line">&#123;</span><br><span class="line">    KPI_ATRACE_CAMSCOPE_CALL(CAMSCOPE_HAL1_OPENCAMERA);</span><br><span class="line">    <span class="keyword">int</span> rc = NO_ERROR;</span><br><span class="line">    <span class="keyword">if</span> (mCameraOpened) &#123;</span><br><span class="line">        *hw_device = <span class="literal">NULL</span>;</span><br><span class="line">        LOGE(<span class="string">"Permission Denied"</span>);</span><br><span class="line">        <span class="keyword">return</span> PERMISSION_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGI(<span class="string">"[KPI Perf]: E PROFILE_OPEN_CAMERA camera id %d"</span>,</span><br><span class="line">            mCameraId);</span><br><span class="line"></span><br><span class="line">    m_perfLockMgr.acquirePerfLock(PERF_LOCK_OPEN_CAMERA);</span><br><span class="line"></span><br><span class="line">    rc = openCamera();</span><br><span class="line">    <span class="keyword">if</span> (rc == NO_ERROR)&#123;</span><br><span class="line">        *hw_device = &amp;mCameraDevice.common;</span><br><span class="line">        <span class="keyword">if</span> (m_thermalAdapter.init(<span class="keyword">this</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">          LOGW(<span class="string">"Init thermal adapter failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *hw_device = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    LOGI(<span class="string">"[KPI Perf]: X PROFILE_OPEN_CAMERA camera id %d, rc: %d"</span>,</span><br><span class="line">            mCameraId, rc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mCameraDevice是一个camera_device,camera_device的common是一个hw_device,打开相机成功则返回给*hw_device.<br>继续看openCamera方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QCamera2HardwareInterface::openCamera()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> rc = NO_ERROR;</span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCameraHandle) &#123;</span><br><span class="line">        LOGE(<span class="string">"Failure: Camera already opened"</span>);</span><br><span class="line">        <span class="keyword">return</span> ALREADY_EXISTS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = QCameraFlash::getInstance().reserveFlashForCamera(mCameraId);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"Failed to reserve flash for camera id: %d"</span>,</span><br><span class="line">                mCameraId);</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alloc param buffer</span></span><br><span class="line">    DeferWorkArgs args;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;args, <span class="number">0</span>, <span class="keyword">sizeof</span>(args));</span><br><span class="line">    mParamAllocJob = queueDeferredWork(CMD_DEF_PARAM_ALLOC, args);</span><br><span class="line">    <span class="keyword">if</span> (mParamAllocJob == <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"Failed queueing PARAM_ALLOC job"</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gCamCapability[mCameraId] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// allocate metadata buffers</span></span><br><span class="line">        DeferWorkArgs args;</span><br><span class="line">        DeferMetadataAllocArgs metadataAllocArgs;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;args, <span class="number">0</span>, <span class="keyword">sizeof</span>(args));</span><br><span class="line">        <span class="built_in">memset</span>(&amp;metadataAllocArgs, <span class="number">0</span>, <span class="keyword">sizeof</span>(metadataAllocArgs));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> padding =</span><br><span class="line">                gCamCapability[mCameraId]-&gt;padding_info.plane_padding;</span><br><span class="line">        metadataAllocArgs.size = PAD_TO_SIZE(<span class="keyword">sizeof</span>(<span class="keyword">metadata_buffer_t</span>),</span><br><span class="line">                padding);</span><br><span class="line">        metadataAllocArgs.bufferCnt = CAMERA_MIN_METADATA_BUFFERS;</span><br><span class="line">        args.metadataAllocArgs = metadataAllocArgs;</span><br><span class="line"></span><br><span class="line">        mMetadataAllocJob = queueDeferredWork(CMD_DEF_METADATA_ALLOC, args);</span><br><span class="line">        <span class="keyword">if</span> (mMetadataAllocJob == <span class="number">0</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"Failed to allocate metadata buffer"</span>);</span><br><span class="line">            rc = -ENOMEM;</span><br><span class="line">            <span class="keyword">goto</span> error_exit1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rc = camera_open((<span class="keyword">uint8_t</span>)mCameraId, &amp;mCameraHandle);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            LOGE(<span class="string">"camera_open failed. rc = %d, mCameraHandle = %p"</span>,</span><br><span class="line">                     rc, mCameraHandle);</span><br><span class="line">            <span class="keyword">goto</span> error_exit2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCameraHandle-&gt;ops-&gt;register_event_notify(mCameraHandle-&gt;camera_handle,</span><br><span class="line">                camEvtHandle,</span><br><span class="line">                (<span class="keyword">void</span> *) <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGH(<span class="string">"Capabilities not inited, initializing now."</span>);</span><br><span class="line"></span><br><span class="line">        rc = camera_open((<span class="keyword">uint8_t</span>)mCameraId, &amp;mCameraHandle);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            LOGE(<span class="string">"camera_open failed. rc = %d, mCameraHandle = %p"</span>,</span><br><span class="line">                     rc, mCameraHandle);</span><br><span class="line">            <span class="keyword">goto</span> error_exit2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(NO_ERROR != initCapabilities(mCameraId,mCameraHandle)) &#123;</span><br><span class="line">            LOGE(<span class="string">"initCapabilities failed."</span>);</span><br><span class="line">            rc = UNKNOWN_ERROR;</span><br><span class="line">            <span class="keyword">goto</span> error_exit3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCameraHandle-&gt;ops-&gt;register_event_notify(mCameraHandle-&gt;camera_handle,</span><br><span class="line">                camEvtHandle,</span><br><span class="line">                (<span class="keyword">void</span> *) <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mBundledSnapshot = <span class="number">0</span>;</span><br><span class="line">    mActiveCameras = MM_CAMERA_TYPE_MAIN;</span><br><span class="line">    <span class="keyword">if</span> (isDualCamera()) &#123;</span><br><span class="line">        mActiveCameras |= MM_CAMERA_TYPE_AUX;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create and initialize FOV-control object</span></span><br><span class="line">        m_pFovControl = QCameraFOVControl::create(gCamCapability[mCameraId]-&gt;main_cam_cap,</span><br><span class="line">                gCamCapability[mCameraId]-&gt;aux_cam_cap);</span><br><span class="line">        <span class="keyword">if</span> (m_pFovControl) &#123;</span><br><span class="line">            *gCamCapability[mCameraId] = m_pFovControl-&gt;consolidateCapabilities(</span><br><span class="line">                    gCamCapability[mCameraId]-&gt;main_cam_cap,</span><br><span class="line">                    gCamCapability[mCameraId]-&gt;aux_cam_cap);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOGE(<span class="string">"FOV-control: Failed to create an object"</span>);</span><br><span class="line">            rc = NO_MEMORY;</span><br><span class="line">            <span class="keyword">goto</span> error_exit3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Init params in the background</span></span><br><span class="line">    <span class="comment">// 1. It's safe to queue init job, even if alloc job is not yet complete.</span></span><br><span class="line">    <span class="comment">// It will be queued to the same thread, so the alloc is guaranteed to</span></span><br><span class="line">    <span class="comment">// finish first.</span></span><br><span class="line">    <span class="comment">// 2. However, it is not safe to begin param init until after camera is</span></span><br><span class="line">    <span class="comment">// open. That is why we wait until after camera open completes to schedule</span></span><br><span class="line">    <span class="comment">// this task.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;args, <span class="number">0</span>, <span class="keyword">sizeof</span>(args));</span><br><span class="line">    mParamInitJob = queueDeferredWork(CMD_DEF_PARAM_INIT, args);</span><br><span class="line">    <span class="keyword">if</span> (mParamInitJob == <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"Failed queuing PARAM_INIT job"</span>);</span><br><span class="line">        rc = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> error_exit3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCameraOpened = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Notify display HAL that a camera session is active.</span></span><br><span class="line">    <span class="comment">//But avoid calling the same during bootup because camera service might open/close</span></span><br><span class="line">    <span class="comment">//cameras at boot time during its initialization and display service will also internally</span></span><br><span class="line">    <span class="comment">//wait for camera service to initialize first while calling this display API, resulting in a</span></span><br><span class="line">    <span class="comment">//deadlock situation. Since boot time camera open/close calls are made only to fetch</span></span><br><span class="line">    <span class="comment">//capabilities, no need of this display bw optimization.</span></span><br><span class="line">    <span class="comment">//Use "service.bootanim.exit" property to know boot status.</span></span><br><span class="line">    property_get(<span class="string">"service.bootanim.exit"</span>, value, <span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">if</span> (atoi(value) == <span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;gCamLock);</span><br><span class="line">        <span class="keyword">if</span> (gNumCameraSessions++ == <span class="number">0</span>) &#123;</span><br><span class="line">            setCameraLaunchStatus(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;gCamLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setprop to decide the time source (whether boottime or monotonic).</span></span><br><span class="line">    <span class="comment">// By default, use monotonic time.</span></span><br><span class="line">    property_get(<span class="string">"persist.camera.time.monotonic"</span>, value, <span class="string">"1"</span>);</span><br><span class="line">    mBootToMonoTimestampOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (atoi(value) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// if monotonic is set, then need to use time in monotonic.</span></span><br><span class="line">        <span class="comment">// So, Measure the clock offset between BOOTTIME and MONOTONIC</span></span><br><span class="line">        <span class="comment">// The clock domain source for ISP is BOOTTIME and</span></span><br><span class="line">        <span class="comment">// for Video/display is MONOTONIC</span></span><br><span class="line">        <span class="comment">// The below offset is used to convert from clock domain of other subsystem</span></span><br><span class="line">        <span class="comment">// (video/hardware composer) to that of camera. Assumption is that this</span></span><br><span class="line">        <span class="comment">// offset won't change during the life cycle of the camera device. In other</span></span><br><span class="line">        <span class="comment">// words, camera device shouldn't be open during CPU suspend.</span></span><br><span class="line">        mBootToMonoTimestampOffset = getBootToMonoTimeOffset();</span><br><span class="line">    &#125;</span><br><span class="line">    LOGH(<span class="string">"mBootToMonoTimestampOffset = %lld"</span>, mBootToMonoTimestampOffset);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(value, <span class="number">0</span>, <span class="keyword">sizeof</span>(value));</span><br><span class="line">    property_get(<span class="string">"persist.camera.depth.focus.cb"</span>, value, <span class="string">"1"</span>);</span><br><span class="line">    bDepthAFCallbacks = atoi(value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(value, <span class="number">0</span>, <span class="keyword">sizeof</span>(value));</span><br><span class="line">    property_get(<span class="string">"persist.camera.cache.optimize"</span>, value, <span class="string">"1"</span>);</span><br><span class="line">    m_bOptimizeCacheOps = atoi(value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">error_exit3:</span><br><span class="line">    <span class="keyword">if</span>(mJpegClientHandle) &#123;</span><br><span class="line">        deinitJpegHandle();</span><br><span class="line">    &#125;</span><br><span class="line">    mCameraHandle-&gt;ops-&gt;close_camera(mCameraHandle-&gt;camera_handle);</span><br><span class="line">    mCameraHandle = <span class="literal">NULL</span>;</span><br><span class="line">error_exit2:</span><br><span class="line">    waitDeferredWork(mMetadataAllocJob);</span><br><span class="line">error_exit1:</span><br><span class="line">    waitDeferredWork(mParamAllocJob);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mm-camera-interface"><a href="#mm-camera-interface" class="headerlink" title="mm-camera-interface"></a>mm-camera-interface</h3><p>有一个camera_open方法,实现在QCamera2/stack/mm-camera-interface/src/mm_camera_interface.c里,这里都是一些相机非常底层方法了,一些公共定义的方法,进而调用到驱动层.打出的代码在libmmcamera_interface.so.</p>
<p>找到实现方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> camera_open(<span class="keyword">uint8_t</span> camera_idx, <span class="keyword">mm_camera_vtbl_t</span> **camera_vtbl)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> rc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mm_camera_obj_t</span> *cam_obj = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> cam_idx = camera_idx;</span><br><span class="line">    <span class="keyword">uint32_t</span> aux_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> is_multi_camera = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> QCAMERA_REDEFINE_LOG</span></span><br><span class="line">    mm_camera_debug_open();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    LOGD(<span class="string">"E camera_idx = %d\n"</span>, camera_idx);</span><br><span class="line">    <span class="keyword">if</span> (is_dual_camera_by_idx(camera_idx)) &#123;</span><br><span class="line">        is_multi_camera = <span class="number">1</span>;</span><br><span class="line">        cam_idx = mm_camera_util_get_handle_by_num(<span class="number">0</span>,</span><br><span class="line">                g_cam_ctrl.cam_index[camera_idx]);</span><br><span class="line">        aux_idx = (get_aux_camera_handle(g_cam_ctrl.cam_index[camera_idx])</span><br><span class="line">                &gt;&gt; MM_CAMERA_HANDLE_SHIFT_MASK);</span><br><span class="line">        LOGH(<span class="string">"Dual Camera: Main ID = %d Aux ID = %d"</span>, cam_idx, aux_idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cam_idx &gt;= (<span class="keyword">uint32_t</span>)g_cam_ctrl.num_cam || cam_idx &gt;=</span><br><span class="line">        MM_CAMERA_MAX_NUM_SENSORS || aux_idx &gt;= MM_CAMERA_MAX_NUM_SENSORS) &#123;</span><br><span class="line">        LOGE(<span class="string">"Invalid camera_idx (%d)"</span>, cam_idx);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;g_intf_lock);</span><br><span class="line">    <span class="comment">/* opened already */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != g_cam_ctrl.cam_obj[cam_idx] &amp;&amp;</span><br><span class="line">            g_cam_ctrl.cam_obj[cam_idx]-&gt;ref_count != <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">        LOGE(<span class="string">"Camera %d is already open"</span>, cam_idx);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cam_obj = (<span class="keyword">mm_camera_obj_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">mm_camera_obj_t</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == cam_obj) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">        LOGE(<span class="string">"no mem"</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize camera obj */</span></span><br><span class="line">    <span class="built_in">memset</span>(cam_obj, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">mm_camera_obj_t</span>));</span><br><span class="line">    cam_obj-&gt;ctrl_fd = <span class="number">-1</span>;</span><br><span class="line">    cam_obj-&gt;ds_fd = <span class="number">-1</span>;</span><br><span class="line">    cam_obj-&gt;ref_count++;</span><br><span class="line">    cam_obj-&gt;my_num = <span class="number">0</span>;</span><br><span class="line">    cam_obj-&gt;my_hdl = mm_camera_util_generate_handler(cam_idx);</span><br><span class="line">    cam_obj-&gt;vtbl.camera_handle = cam_obj-&gt;my_hdl; <span class="comment">/* set handler */</span></span><br><span class="line">    cam_obj-&gt;vtbl.ops = &amp;mm_camera_ops;</span><br><span class="line">    pthread_mutex_init(&amp;cam_obj-&gt;cam_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;cam_obj-&gt;muxer_lock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* unlock global interface lock, if not, in dual camera use case,</span></span><br><span class="line"><span class="comment">      * current open will block operation of another opened camera obj*/</span></span><br><span class="line">    pthread_mutex_lock(&amp;cam_obj-&gt;cam_lock);</span><br><span class="line">    pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line"></span><br><span class="line">    rc = mm_camera_open(cam_obj);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"mm_camera_open err = %d"</span>, rc);</span><br><span class="line">        pthread_mutex_destroy(&amp;cam_obj-&gt;cam_lock);</span><br><span class="line">        pthread_mutex_lock(&amp;g_intf_lock);</span><br><span class="line">        g_cam_ctrl.cam_obj[cam_idx] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(cam_obj);</span><br><span class="line">        cam_obj = <span class="literal">NULL</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">        *camera_vtbl = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_multi_camera) &#123;</span><br><span class="line">        <span class="comment">/*Open Aux camer's*/</span></span><br><span class="line">        pthread_mutex_lock(&amp;g_intf_lock);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> != g_cam_ctrl.cam_obj[aux_idx] &amp;&amp;</span><br><span class="line">                g_cam_ctrl.cam_obj[aux_idx]-&gt;ref_count != <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">            LOGE(<span class="string">"Camera %d is already open"</span>, aux_idx);</span><br><span class="line">            rc = -EBUSY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;cam_obj-&gt;muxer_lock);</span><br><span class="line">            pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">            rc = mm_camera_muxer_camera_open(aux_idx, cam_obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> temp_rc = <span class="number">0</span>;</span><br><span class="line">            LOGE(<span class="string">"muxer open err = %d"</span>, rc);</span><br><span class="line">            pthread_mutex_lock(&amp;g_intf_lock);</span><br><span class="line">            g_cam_ctrl.cam_obj[cam_idx] = <span class="literal">NULL</span>;</span><br><span class="line">            pthread_mutex_lock(&amp;cam_obj-&gt;cam_lock);</span><br><span class="line">            pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">            temp_rc = mm_camera_close(cam_obj);</span><br><span class="line">            pthread_mutex_destroy(&amp;cam_obj-&gt;cam_lock);</span><br><span class="line">            pthread_mutex_destroy(&amp;cam_obj-&gt;muxer_lock);</span><br><span class="line">            <span class="built_in">free</span>(cam_obj);</span><br><span class="line">            cam_obj = <span class="literal">NULL</span>;</span><br><span class="line">            *camera_vtbl = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// Propagate the original error to caller</span></span><br><span class="line">            <span class="keyword">return</span> rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGH(<span class="string">"Open succeded: handle = %d"</span>, cam_obj-&gt;vtbl.camera_handle);</span><br><span class="line">    g_cam_ctrl.cam_obj[cam_idx] = cam_obj;</span><br><span class="line">    *camera_vtbl = &amp;cam_obj-&gt;vtbl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里出了一些状态值设置,实际调用的是mm_camera_open方法,如果双摄,则是mm_camera_muxer_camera_open方法,在mm_camera.c中找到实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> mm_camera_open(<span class="keyword">mm_camera_obj_t</span> *my_obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> dev_name[MM_CAMERA_DEV_NAME_LEN];</span><br><span class="line">    <span class="keyword">int32_t</span> rc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int8_t</span> n_try=MM_CAMERA_DEV_OPEN_TRIES;</span><br><span class="line">    <span class="keyword">uint8_t</span> sleep_msec=MM_CAMERA_DEV_OPEN_RETRY_SLEEP;</span><br><span class="line">    <span class="keyword">int</span> cam_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dev_name_value = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> l_errno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    LOGD(<span class="string">"begin\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == my_obj) &#123;</span><br><span class="line">        <span class="keyword">goto</span> on_error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev_name_value = mm_camera_util_get_dev_name_by_num(my_obj-&gt;my_num,</span><br><span class="line">            my_obj-&gt;my_hdl);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == dev_name_value) &#123;</span><br><span class="line">        <span class="keyword">goto</span> on_error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">snprintf</span>(dev_name, <span class="keyword">sizeof</span>(dev_name), <span class="string">"/dev/%s"</span>,</span><br><span class="line">             dev_name_value);</span><br><span class="line">    <span class="built_in">sscanf</span>(dev_name, <span class="string">"/dev/video%d"</span>, &amp;cam_idx);</span><br><span class="line">    LOGD(<span class="string">"dev name = %s, cam_idx = %d"</span>, dev_name, cam_idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        n_try--;</span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        my_obj-&gt;ctrl_fd = open(dev_name, O_RDWR | O_NONBLOCK);</span><br><span class="line">        l_errno = errno;</span><br><span class="line">        LOGD(<span class="string">"ctrl_fd = %d, errno == %d"</span>, my_obj-&gt;ctrl_fd, l_errno);</span><br><span class="line">        <span class="keyword">if</span>((my_obj-&gt;ctrl_fd &gt;= <span class="number">0</span>) || (errno != EIO &amp;&amp; errno != ETIMEDOUT) || (n_try &lt;= <span class="number">0</span> )) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LOGE(<span class="string">"Failed with %s error, retrying after %d milli-seconds"</span>,</span><br><span class="line">              strerror(errno), sleep_msec);</span><br><span class="line">        usleep(sleep_msec * <span class="number">1000U</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span> (n_try &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_obj-&gt;ctrl_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"cannot open control fd of '%s' (%s)\n"</span>,</span><br><span class="line">                  dev_name, strerror(l_errno));</span><br><span class="line">        <span class="keyword">if</span> (l_errno == EBUSY)</span><br><span class="line">            rc = -EUSERS;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rc = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> on_error;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mm_camera_get_session_id(my_obj, &amp;my_obj-&gt;sessionid);</span><br><span class="line">        LOGH(<span class="string">"Camera Opened id = %d sessionid = %d"</span>, cam_idx, my_obj-&gt;sessionid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DAEMON_PRESENT</span></span><br><span class="line">    <span class="comment">/* open domain socket*/</span></span><br><span class="line">    n_try = MM_CAMERA_DEV_OPEN_TRIES;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        n_try--;</span><br><span class="line">        my_obj-&gt;ds_fd = mm_camera_socket_create(cam_idx, MM_CAMERA_SOCK_TYPE_UDP);</span><br><span class="line">        l_errno = errno;</span><br><span class="line">        LOGD(<span class="string">"ds_fd = %d, errno = %d"</span>, my_obj-&gt;ds_fd, l_errno);</span><br><span class="line">        <span class="keyword">if</span>((my_obj-&gt;ds_fd &gt;= <span class="number">0</span>) || (n_try &lt;= <span class="number">0</span> )) &#123;</span><br><span class="line">            LOGD(<span class="string">"opened, break out while loop"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LOGD(<span class="string">"failed with I/O error retrying after %d milli-seconds"</span>,</span><br><span class="line">              sleep_msec);</span><br><span class="line">        usleep(sleep_msec * <span class="number">1000U</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (n_try &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_obj-&gt;ds_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"cannot open domain socket fd of '%s'(%s)\n"</span>,</span><br><span class="line">                  dev_name, strerror(l_errno));</span><br><span class="line">        rc = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> on_error;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* DAEMON_PRESENT */</span></span></span><br><span class="line">    <span class="keyword">cam_status_t</span> cam_status;</span><br><span class="line">    cam_status = mm_camera_module_open_session(my_obj-&gt;sessionid,</span><br><span class="line">            mm_camera_module_event_handler);</span><br><span class="line">    <span class="keyword">if</span> (cam_status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"Failed to open session"</span>);</span><br><span class="line">        <span class="keyword">if</span> (cam_status == CAM_STATUS_BUSY) &#123;</span><br><span class="line">            rc = -EUSERS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rc = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> on_error;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* DAEMON_PRESENT */</span></span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;my_obj-&gt;msg_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;my_obj-&gt;cb_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;my_obj-&gt;evt_lock, <span class="literal">NULL</span>);</span><br><span class="line">    PTHREAD_COND_INIT(&amp;my_obj-&gt;evt_cond);</span><br><span class="line"></span><br><span class="line">    LOGD(<span class="string">"Launch evt Thread in Cam Open"</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(my_obj-&gt;evt_thread.threadName, THREAD_NAME_SIZE, <span class="string">"CAM_Dispatch"</span>);</span><br><span class="line">    mm_camera_cmd_thread_launch(&amp;my_obj-&gt;evt_thread,</span><br><span class="line">                                mm_camera_dispatch_app_event,</span><br><span class="line">                                (<span class="keyword">void</span> *)my_obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* launch event poll thread</span></span><br><span class="line"><span class="comment">     * we will add evt fd into event poll thread upon user first register for evt */</span></span><br><span class="line">    LOGD(<span class="string">"Launch evt Poll Thread in Cam Open"</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(my_obj-&gt;evt_poll_thread.threadName, THREAD_NAME_SIZE, <span class="string">"CAM_evntPoll"</span>);</span><br><span class="line">    mm_camera_poll_thread_launch(&amp;my_obj-&gt;evt_poll_thread,</span><br><span class="line">                                 MM_CAMERA_POLL_TYPE_EVT);</span><br><span class="line">    mm_camera_evt_sub(my_obj, TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock cam_lock, we need release global intf_lock in camera_open(),</span></span><br><span class="line"><span class="comment">     * in order not block operation of other Camera in dual camera use case.*/</span></span><br><span class="line">    pthread_mutex_unlock(&amp;my_obj-&gt;cam_lock);</span><br><span class="line">    LOGD(<span class="string">"end (rc = %d)\n"</span>, rc);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">on_error:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == dev_name_value) &#123;</span><br><span class="line">        LOGE(<span class="string">"Invalid device name\n"</span>);</span><br><span class="line">        rc = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == my_obj) &#123;</span><br><span class="line">        LOGE(<span class="string">"Invalid camera object\n"</span>);</span><br><span class="line">        rc = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (my_obj-&gt;ctrl_fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            close(my_obj-&gt;ctrl_fd);</span><br><span class="line">            my_obj-&gt;ctrl_fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DAEMON_PRESENT</span></span><br><span class="line">        <span class="keyword">if</span> (my_obj-&gt;ds_fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            mm_camera_socket_close(my_obj-&gt;ds_fd);</span><br><span class="line">            my_obj-&gt;ds_fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlock cam_lock, we need release global intf_lock in camera_open(),</span></span><br><span class="line"><span class="comment">     * in order not block operation of other Camera in dual camera use case.*/</span></span><br><span class="line">    pthread_mutex_unlock(&amp;my_obj-&gt;cam_lock);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里看到一个很特别会尝试多次打开,MM_CAMERA_DEV_OPEN_TRIES值看到定义为20,每次失败都会睡眠一定时间.<br>打开驱动设备的方法是open(dev_name, O_RDWR | O_NONBLOCK),这里应该就调用到了驱动层了.剩下的操作看到有打开会话,初始化消息锁等.</p>
<p>回头看QCamera2HardwareInterface,其定义了一个camera_device_ops_t</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">camera_device_ops_t</span> QCamera2HardwareInterface::mCameraOps = &#123;</span><br><span class="line">    .set_preview_window =        QCamera2HardwareInterface::set_preview_window,</span><br><span class="line">    .set_callbacks =             QCamera2HardwareInterface::set_CallBacks,</span><br><span class="line">    .enable_msg_type =           QCamera2HardwareInterface::enable_msg_type,</span><br><span class="line">    .disable_msg_type =          QCamera2HardwareInterface::disable_msg_type,</span><br><span class="line">    .msg_type_enabled =          QCamera2HardwareInterface::msg_type_enabled,</span><br><span class="line"></span><br><span class="line">    .start_preview =             QCamera2HardwareInterface::start_preview,</span><br><span class="line">    .stop_preview =              QCamera2HardwareInterface::stop_preview,</span><br><span class="line">    .preview_enabled =           QCamera2HardwareInterface::preview_enabled,</span><br><span class="line">    .store_meta_data_in_buffers= QCamera2HardwareInterface::store_meta_data_in_buffers,</span><br><span class="line"></span><br><span class="line">    .start_recording =           QCamera2HardwareInterface::start_recording,</span><br><span class="line">    .stop_recording =            QCamera2HardwareInterface::stop_recording,</span><br><span class="line">    .recording_enabled =         QCamera2HardwareInterface::recording_enabled,</span><br><span class="line">    .release_recording_frame =   QCamera2HardwareInterface::release_recording_frame,</span><br><span class="line"></span><br><span class="line">    .auto_focus =                QCamera2HardwareInterface::auto_focus,</span><br><span class="line">    .cancel_auto_focus =         QCamera2HardwareInterface::cancel_auto_focus,</span><br><span class="line"></span><br><span class="line">    .take_picture =              QCamera2HardwareInterface::take_picture,</span><br><span class="line">    .cancel_picture =            QCamera2HardwareInterface::cancel_picture,</span><br><span class="line"></span><br><span class="line">    .set_parameters =            QCamera2HardwareInterface::set_parameters,</span><br><span class="line">    .get_parameters =            QCamera2HardwareInterface::get_parameters,</span><br><span class="line">    .put_parameters =            QCamera2HardwareInterface::put_parameters,</span><br><span class="line">    .send_command =              QCamera2HardwareInterface::send_command,</span><br><span class="line"></span><br><span class="line">    .release =                   QCamera2HardwareInterface::release,</span><br><span class="line">    .dump =                      QCamera2HardwareInterface::dump,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>初始化时传给了mCameraDevice.ops.</p>
<h3 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h3><p>相机hal注册及打开设备流程:</p>
<ol>
<li>QCamera2Hal注册一个hal模块结构hw_module_t,注册了模块方法QCamera2Factory::mModuleMethods</li>
<li>mModuleMethods的open方法包含camera_device_open方法</li>
<li>camera_device_open方法根据不同情况调用,最终调用QCamera2HardwareInterface的openCamera方法</li>
<li>QCamera2HardwareInterface有一个camera_device_t变量mCameraDevice,内包含注册注册hal方法的camera_device_ops_t和hal设备模板hw_device_t</li>
<li>openCamera方法调用mm_camera_interface的camera_open,再到mm_camera_open</li>
<li>mm_camera_open会尝试多次打开驱动,使用open(dev_name, O_RDWR | O_NONBLOCK)调用到驱动层方法</li>
</ol>
<h2 id="hal拍照流程"><a href="#hal拍照流程" class="headerlink" title="hal拍照流程"></a>hal拍照流程</h2><p>接下来分析下hal层拍照的流程从而梳理下hal层代码.</p>
<h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><p>发起请求的方法就是上面注册的take_picture方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QCamera2HardwareInterface::take_picture(struct camera_device *device)</span><br><span class="line">&#123;</span><br><span class="line">    KPI_ATRACE_CAMSCOPE_CALL(CAMSCOPE_HAL1_TAKE_PICTURE);</span><br><span class="line">    <span class="keyword">int</span> ret = NO_ERROR;</span><br><span class="line">    QCamera2HardwareInterface *hw =</span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;QCamera2HardwareInterface *&gt;(device-&gt;priv);</span><br><span class="line">    <span class="keyword">if</span> (!hw) &#123;</span><br><span class="line">        LOGE(<span class="string">"NULL camera device"</span>);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGI(<span class="string">"[KPI Perf]: E PROFILE_TAKE_PICTURE camera id %d"</span>,</span><br><span class="line">             hw-&gt;getCameraId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire the perf lock for JPEG snapshot only</span></span><br><span class="line">    <span class="keyword">if</span> (hw-&gt;mParameters.isJpegPictureFormat()) &#123;</span><br><span class="line">        hw-&gt;m_perfLockMgr.acquirePerfLock(PERF_LOCK_TAKE_SNAPSHOT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">qcamera_api_result_t</span> apiResult;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Added support for Retro-active Frames:</span></span><br><span class="line"><span class="comment">     *  takePicture() is called before preparing Snapshot to indicate the</span></span><br><span class="line"><span class="comment">     *  mm-camera-channel to pick up legacy frames even</span></span><br><span class="line"><span class="comment">     *  before LED estimation is triggered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    LOGH(<span class="string">"isLiveSnap %d, isZSL %d, isHDR %d longshot = %d"</span>,</span><br><span class="line">           hw-&gt;isLiveSnapshot(), hw-&gt;isZSLMode(), hw-&gt;isHDRMode(),</span><br><span class="line">           hw-&gt;isLongshotEnabled());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for Retro-active Frames</span></span><br><span class="line">    <span class="keyword">if</span> ((hw-&gt;mParameters.getNumOfRetroSnapshots() &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        !hw-&gt;isLiveSnapshot() &amp;&amp; hw-&gt;isZSLMode() &amp;&amp;</span><br><span class="line">        !hw-&gt;isHDRMode() &amp;&amp; !hw-&gt;isLongshotEnabled()) &#123;</span><br><span class="line">        <span class="comment">// Set Retro Picture Mode</span></span><br><span class="line">        hw-&gt;setRetroPicture(<span class="number">1</span>);</span><br><span class="line">        hw-&gt;m_bLedAfAecLock = <span class="number">0</span>;</span><br><span class="line">        LOGL(<span class="string">"Retro Enabled"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Give HWI control to call pre_take_picture in single camera mode.</span></span><br><span class="line">        <span class="comment">// In dual-cam mode, this control belongs to muxer.</span></span><br><span class="line">        <span class="keyword">if</span> (hw-&gt;getRelatedCamSyncInfo()-&gt;sync_control != CAM_SYNC_RELATED_SENSORS_ON) &#123;</span><br><span class="line">            ret = pre_take_picture(device);</span><br><span class="line">            <span class="keyword">if</span> (ret != NO_ERROR) &#123;</span><br><span class="line">                LOGE(<span class="string">"pre_take_picture failed with ret = %d"</span>,ret);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Call take Picture for total number of snapshots required.</span></span><br><span class="line"><span class="comment">             This includes the number of retro frames and normal frames */</span></span><br><span class="line">        hw-&gt;lockAPI();</span><br><span class="line">        ret = hw-&gt;processAPI(QCAMERA_SM_EVT_TAKE_PICTURE, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == NO_ERROR) &#123;</span><br><span class="line">          <span class="comment">// Wait for retro frames, before calling prepare snapshot</span></span><br><span class="line">          LOGD(<span class="string">"Wait for Retro frames to be done"</span>);</span><br><span class="line">          hw-&gt;waitAPIResult(QCAMERA_SM_EVT_TAKE_PICTURE, &amp;apiResult);</span><br><span class="line">            ret = apiResult.status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Unlock API since it is acquired in prepare snapshot seperately */</span></span><br><span class="line">        hw-&gt;unlockAPI();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Prepare snapshot in case LED needs to be flashed */</span></span><br><span class="line">        LOGD(<span class="string">"Start Prepare Snapshot"</span>);</span><br><span class="line">        ret = hw-&gt;prepare_snapshot(device);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        hw-&gt;setRetroPicture(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// Check if prepare snapshot is done</span></span><br><span class="line">        <span class="keyword">if</span> (!hw-&gt;mPrepSnapRun) &#123;</span><br><span class="line">            <span class="comment">// Ignore the status from prepare_snapshot</span></span><br><span class="line">            hw-&gt;prepare_snapshot(device);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Give HWI control to call pre_take_picture in single camera mode.</span></span><br><span class="line">        <span class="comment">// In dual-cam mode, this control belongs to muxer.</span></span><br><span class="line">        <span class="keyword">if</span> (hw-&gt;getRelatedCamSyncInfo()-&gt;sync_control != CAM_SYNC_RELATED_SENSORS_ON) &#123;</span><br><span class="line">            ret = pre_take_picture(device);</span><br><span class="line">            <span class="keyword">if</span> (ret != NO_ERROR) &#123;</span><br><span class="line">                LOGE(<span class="string">"pre_take_picture failed with ret = %d"</span>,ret);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Regardless what the result value for prepare_snapshot,</span></span><br><span class="line">        <span class="comment">// go ahead with capture anyway. Just like the way autofocus</span></span><br><span class="line">        <span class="comment">// is handled in capture case</span></span><br><span class="line">        <span class="comment">/* capture */</span></span><br><span class="line">        LOGL(<span class="string">"Capturing normal frames"</span>);</span><br><span class="line">        hw-&gt;lockAPI();</span><br><span class="line">        ret = hw-&gt;processAPI(QCAMERA_SM_EVT_TAKE_PICTURE, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == NO_ERROR) &#123;</span><br><span class="line">          hw-&gt;waitAPIResult(QCAMERA_SM_EVT_TAKE_PICTURE, &amp;apiResult);</span><br><span class="line">            ret = apiResult.status;</span><br><span class="line">        &#125;</span><br><span class="line">        hw-&gt;unlockAPI();</span><br><span class="line">        <span class="keyword">if</span> (!hw-&gt;isLongshotEnabled())&#123;</span><br><span class="line">            <span class="comment">// For longshot mode, we prepare snapshot only once</span></span><br><span class="line">            hw-&gt;mPrepSnapRun = <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGI(<span class="string">"[KPI Perf]: X ret = %d"</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用processAPI传递消息,如果没有错误,则使用waitAPIResult等待结果:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QCamera2HardwareInterface::processAPI(<span class="keyword">qcamera_sm_evt_enum_t</span> api, <span class="keyword">void</span> *api_payload)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = DEAD_OBJECT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_smThreadActive) &#123;</span><br><span class="line">        ret = m_stateMachine.procAPI(api, api_payload);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里又调用到相机状态机:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : procEvt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: process incoming envent from mm-camera-interface and</span></span><br><span class="line"><span class="comment"> *              mm-jpeg-interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @evt          : event to be processed</span></span><br><span class="line"><span class="comment"> *   @evt_payload  : event payload. Can be NULL if not needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : int32_t type of status</span></span><br><span class="line"><span class="comment"> *              NO_ERROR  -- success</span></span><br><span class="line"><span class="comment"> *              none-zero failure code</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">int32_t</span> QCameraStateMachine::procAPI(<span class="keyword">qcamera_sm_evt_enum_t</span> evt,</span><br><span class="line">                                     <span class="keyword">void</span> *api_payload)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">qcamera_sm_cmd_t</span> *node =</span><br><span class="line">        (<span class="keyword">qcamera_sm_cmd_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">qcamera_sm_cmd_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == node) &#123;</span><br><span class="line">        LOGE(<span class="string">"No memory for qcamera_sm_cmd_t"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">qcamera_sm_cmd_t</span>));</span><br><span class="line">    node-&gt;cmd = QCAMERA_SM_CMD_TYPE_API;</span><br><span class="line">    node-&gt;evt = evt;</span><br><span class="line">    node-&gt;evt_payload = api_payload;</span><br><span class="line">    <span class="keyword">if</span> (api_queue.enqueue((<span class="keyword">void</span> *)node)) &#123;</span><br><span class="line">        cam_sem_post(&amp;cmd_sem);</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGE(<span class="string">"API enqueue failed API = %d"</span>, evt);</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注释说明这里是处理mm-camera-interface和mm-jpeg-interface的消息.<br>这里在列队里添加一个消息,然后信号量同步.cam_sem_post方法在cam_semaphore.h中,不深入看了.<br>继续看QCameraQueue::enqueue方法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> QCameraQueue::enqueue(<span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> rc;</span><br><span class="line">    camera_q_node *node =</span><br><span class="line">        (camera_q_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(camera_q_node));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == node) &#123;</span><br><span class="line">        LOGE(<span class="string">"No memory for camera_q_node"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(camera_q_node));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;m_lock);</span><br><span class="line">    <span class="keyword">if</span> (m_active) &#123;</span><br><span class="line">        cam_list_add_tail_node(&amp;node-&gt;<span class="built_in">list</span>, &amp;m_head.<span class="built_in">list</span>);</span><br><span class="line">        m_size++;</span><br><span class="line">        rc = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        rc = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;m_lock);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在队尾添加了一个节点,cam_list_add_tail_node也是在stack/common中的方法.</p>
<h3 id="状态机处理"><a href="#状态机处理" class="headerlink" title="状态机处理"></a>状态机处理</h3><p>消息进队后还是得找到处理消息的方法,回到QCameraStateMachine,其有一个周期性方法smEvtProcRoutine,初始化时起了一个线程循环调用.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : smEvtProcRoutine</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: Statemachine process thread routine to handle events</span></span><br><span class="line"><span class="comment"> *              in different state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @data    : ptr to QCameraStateMachine object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : none</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">void</span> *QCameraStateMachine::smEvtProcRoutine(<span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>, ret;</span><br><span class="line">    QCameraStateMachine *pme = (QCameraStateMachine *)data;</span><br><span class="line"></span><br><span class="line">    LOGH(<span class="string">"E"</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ret = cam_sem_wait(&amp;pme-&gt;cmd_sem);</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span> &amp;&amp; errno != EINVAL) &#123;</span><br><span class="line">                LOGE(<span class="string">"cam_sem_wait error (%s)"</span>,</span><br><span class="line">                            strerror(errno));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (ret != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we got notified about new cmd avail in cmd queue</span></span><br><span class="line">        <span class="comment">// first check API cmd queue</span></span><br><span class="line">        <span class="keyword">qcamera_sm_cmd_t</span> *node = (<span class="keyword">qcamera_sm_cmd_t</span> *)pme-&gt;api_queue.dequeue();</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// no API cmd, then check evt cmd queue</span></span><br><span class="line">            node = (<span class="keyword">qcamera_sm_cmd_t</span> *)pme-&gt;evt_queue.dequeue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (node-&gt;cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> QCAMERA_SM_CMD_TYPE_API:</span><br><span class="line">                pme-&gt;stateMachine(node-&gt;evt, node-&gt;evt_payload);</span><br><span class="line">                <span class="comment">// API is in a way sync call, so evt_payload is managed by HWI</span></span><br><span class="line">                <span class="comment">// no need to free payload for API</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> QCAMERA_SM_CMD_TYPE_EVT:</span><br><span class="line">                pme-&gt;stateMachine(node-&gt;evt, node-&gt;evt_payload);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// EVT is async call, so payload need to be free after use</span></span><br><span class="line">                <span class="built_in">free</span>(node-&gt;evt_payload);</span><br><span class="line">                node-&gt;evt_payload = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> QCAMERA_SM_CMD_TYPE_EXIT:</span><br><span class="line">                running = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            node = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (running);</span><br><span class="line">    LOGH(<span class="string">"X"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : QCameraStateMachine</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: constructor of QCameraStateMachine. Will start process thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @ctrl    : ptr to HWI object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : none</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line">QCameraStateMachine::QCameraStateMachine(QCamera2HardwareInterface *ctrl) :</span><br><span class="line">    api_queue(),</span><br><span class="line">    evt_queue()</span><br><span class="line">&#123;</span><br><span class="line">    m_parent = ctrl;</span><br><span class="line">    m_state = QCAMERA_SM_STATE_PREVIEW_STOPPED;</span><br><span class="line">    cmd_pid = <span class="number">0</span>;</span><br><span class="line">    cam_sem_init(&amp;cmd_sem, <span class="number">0</span>);</span><br><span class="line">    xunh(&amp;cmd_pid,</span><br><span class="line">                   <span class="literal">NULL</span>,</span><br><span class="line">                   smEvtProcRoutine,</span><br><span class="line">                   <span class="keyword">this</span>);</span><br><span class="line">    pthread_setname_np(cmd_pid, <span class="string">"CAM_stMachine"</span>);</span><br><span class="line">    m_bDelayPreviewMsgs = <span class="literal">false</span>;</span><br><span class="line">    m_DelayedMsgs = <span class="number">0</span>;</span><br><span class="line">    m_RestoreZSL = TRUE;</span><br><span class="line">    m_bPreviewCallbackNeeded = TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>smEvtProcRoutine就是通过信号量判断是否有消息等待,然后通过api_queue.dequeue()就是QCameraQueue的出队方法获取命令.<br>然后通过stateMachine(node-&gt;evt, node-&gt;evt_payload)方法处理,QCAMERA_SM_CMD_TYPE_API不需要清空消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> QCameraStateMachine::stateMachine(<span class="keyword">qcamera_sm_evt_enum_t</span> evt, <span class="keyword">void</span> *payload)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> rc = NO_ERROR;</span><br><span class="line">    LOGL(<span class="string">"m_state %d, event (%d)"</span>, m_state, evt);</span><br><span class="line">    <span class="keyword">switch</span> (m_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PREVIEW_STOPPED:</span><br><span class="line">        rc = procEvtPreviewStoppedState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PREVIEW_READY:</span><br><span class="line">        rc = procEvtPreviewReadyState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PREVIEWING:</span><br><span class="line">        rc = procEvtPreviewingState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PREPARE_SNAPSHOT:</span><br><span class="line">        rc = procEvtPrepareSnapshotState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PIC_TAKING:</span><br><span class="line">        rc = procEvtPicTakingState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_RECORDING:</span><br><span class="line">        rc = procEvtRecordingState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_VIDEO_PIC_TAKING:</span><br><span class="line">        rc = procEvtVideoPicTakingState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_STATE_PREVIEW_PIC_TAKING:</span><br><span class="line">        rc = procEvtPreviewPicTakingState(evt, payload);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设当前是preview状态,看procEvtPreviewingState代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> QCameraStateMachine::procEvtPreviewingState(<span class="keyword">qcamera_sm_evt_enum_t</span> evt,</span><br><span class="line">                                                    <span class="keyword">void</span> *payload)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> rc = NO_ERROR;</span><br><span class="line">    <span class="keyword">qcamera_api_result_t</span> result;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;result, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">qcamera_api_result_t</span>));</span><br><span class="line"></span><br><span class="line">    LOGL(<span class="string">"event (%d)"</span>, evt);</span><br><span class="line">    <span class="keyword">switch</span> (evt) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> QCAMERA_SM_EVT_TAKE_PICTURE:</span><br><span class="line">       &#123;</span><br><span class="line">           LOGL(<span class="string">"QCAMERA_SM_EVT_TAKE_PICTURE "</span>);</span><br><span class="line">           <span class="keyword">if</span> ( m_parent-&gt;mParameters.getRecordingHintValue() == <span class="literal">true</span>) &#123;</span><br><span class="line">                m_parent-&gt;stopPreview();</span><br><span class="line">                m_parent-&gt;mParameters.updateRecordingHintValue(FALSE);</span><br><span class="line">                <span class="comment">// start preview again</span></span><br><span class="line">                rc = m_parent-&gt;preparePreview();</span><br><span class="line">                <span class="keyword">if</span> (rc == NO_ERROR) &#123;</span><br><span class="line">                    rc = m_parent-&gt;startPreview();</span><br><span class="line">                    <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                        m_parent-&gt;unpreparePreview();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (m_parent-&gt;isZSLMode() || m_parent-&gt;isLongshotEnabled()) &#123;</span><br><span class="line">               <span class="keyword">bool</span> restartPreview = m_parent-&gt;isPreviewRestartEnabled();</span><br><span class="line">               <span class="keyword">if</span> ((restartPreview) &amp;&amp; (m_parent-&gt;mParameters.getManualCaptureMode()</span><br><span class="line">                       &gt;= CAM_MANUAL_CAPTURE_TYPE_3)) &#123;</span><br><span class="line">                   <span class="comment">/* stop preview and disable ZSL now */</span></span><br><span class="line">                   m_parent-&gt;stopPreview();</span><br><span class="line">                   m_parent-&gt;mParameters.updateZSLModeValue(FALSE);</span><br><span class="line">                   m_RestoreZSL = TRUE;</span><br><span class="line">                   m_bDelayPreviewMsgs = <span class="literal">true</span>;</span><br><span class="line">                   m_state = QCAMERA_SM_STATE_PIC_TAKING;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   m_state = QCAMERA_SM_STATE_PREVIEW_PIC_TAKING;</span><br><span class="line">                   m_bDelayPreviewMsgs = <span class="literal">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               rc = m_parent-&gt;takePicture();</span><br><span class="line">               <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                   <span class="comment">// move state to previewing state</span></span><br><span class="line">                   m_parent-&gt;unconfigureAdvancedCapture();</span><br><span class="line">                   m_state = QCAMERA_SM_STATE_PREVIEWING;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (!(m_parent-&gt;isRetroPicture()) || (rc != NO_ERROR)) &#123;</span><br><span class="line">                   LOGD(<span class="string">"signal API result, m_state = %d"</span>,</span><br><span class="line">                          m_state);</span><br><span class="line">                   result.status = rc;</span><br><span class="line">                   result.request_api = evt;</span><br><span class="line">                   result.result_type = QCAMERA_API_RESULT_TYPE_DEF;</span><br><span class="line">                   m_parent-&gt;signalAPIResult(&amp;result);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               m_state = QCAMERA_SM_STATE_PIC_TAKING;</span><br><span class="line">               rc = m_parent-&gt;takePicture();</span><br><span class="line">               <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                   <span class="keyword">int32_t</span> temp_rc = NO_ERROR;</span><br><span class="line">                   <span class="comment">// move state to preview stopped state</span></span><br><span class="line">                   m_parent-&gt;unconfigureAdvancedCapture();</span><br><span class="line">                   m_parent-&gt;stopPreview();</span><br><span class="line">                   <span class="comment">// start preview again</span></span><br><span class="line">                   temp_rc = m_parent-&gt;preparePreview();</span><br><span class="line">                   <span class="keyword">if</span> (temp_rc == NO_ERROR) &#123;</span><br><span class="line">                       temp_rc = m_parent-&gt;startPreview();</span><br><span class="line">                       <span class="keyword">if</span> (temp_rc != NO_ERROR) &#123;</span><br><span class="line">                           m_parent-&gt;unpreparePreview();</span><br><span class="line">                           m_state = QCAMERA_SM_STATE_PREVIEW_STOPPED;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           m_state = QCAMERA_SM_STATE_PREVIEWING;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       m_state = QCAMERA_SM_STATE_PREVIEW_STOPPED;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               result.status = rc;</span><br><span class="line">               result.request_api = evt;</span><br><span class="line">               result.result_type = QCAMERA_API_RESULT_TYPE_DEF;</span><br><span class="line">               m_parent-&gt;signalAPIResult(&amp;result);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        LOGW(<span class="string">"Cannot handle evt(%d) in state(%d)"</span>, evt, m_state);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把状态置为QCAMERA_SM_STATE_PIC_TAKING,调用QCamera2HardwareInterface的takePicture,如果返回没有错误,则重新startPreview.<br>最后用signalAPIResult回调状态结果.</p>
<h3 id="拍照实现"><a href="#拍照实现" class="headerlink" title="拍照实现"></a>拍照实现</h3><p>takePicture方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> QCamera2HardwareInterface::takePicture()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get total number for snapshots (retro + regular)</span></span><br><span class="line">    <span class="keyword">uint8_t</span> numSnapshots = mParameters.getNumOfSnapshots();</span><br><span class="line">    <span class="comment">// Get number of retro-active snapshots</span></span><br><span class="line">    <span class="keyword">uint8_t</span> numRetroSnapshots = mParameters.getNumOfRetroSnapshots();</span><br><span class="line">    LOGH(<span class="string">"E"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Set rotation value from user settings as Jpeg rotation</span></span><br><span class="line">    <span class="comment">//to configure back-end modules.</span></span><br><span class="line">    mParameters.setJpegRotation(mParameters.getRotation());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if retro-active snapshots are not enabled</span></span><br><span class="line">    <span class="keyword">if</span> (!isRetroPicture() || !mParameters.isZSLMode()) &#123;</span><br><span class="line">      numRetroSnapshots = <span class="number">0</span>;</span><br><span class="line">      LOGH(<span class="string">"Reset retro snaphot count to zero"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Do special configure for advanced capture modes.</span></span><br><span class="line">    rc = configureAdvancedCapture();</span><br><span class="line">    <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">        LOGE(<span class="string">"Unsupported capture call"</span>);</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAdvancedCaptureConfigured) &#123;</span><br><span class="line">        numSnapshots = mParameters.getBurstCountForAdvancedCapture();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mActiveCameras == MM_CAMERA_DUAL_CAM &amp;&amp; mBundledSnapshot) &#123;</span><br><span class="line">        <span class="keyword">char</span> prop[PROPERTY_VALUE_MAX];</span><br><span class="line">        <span class="built_in">memset</span>(prop, <span class="number">0</span>, <span class="keyword">sizeof</span>(prop));</span><br><span class="line">        property_get(<span class="string">"persist.camera.dualfov.jpegnum"</span>, prop, <span class="string">"1"</span>);</span><br><span class="line">        <span class="keyword">int</span> dualfov_snap_num = atoi(prop);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(prop, <span class="number">0</span>, <span class="keyword">sizeof</span>(prop));</span><br><span class="line">        property_get(<span class="string">"persist.camera.halpp"</span>, prop, <span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">int</span> halpp_enabled = atoi(prop);</span><br><span class="line">        <span class="keyword">if</span>(halpp_enabled == <span class="number">0</span>) &#123;</span><br><span class="line">            dualfov_snap_num = MM_CAMERA_MAX_CAM_CNT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dualfov_snap_num = (dualfov_snap_num == <span class="number">0</span>) ? <span class="number">1</span> : dualfov_snap_num;</span><br><span class="line">        LOGD(<span class="string">"dualfov_snap_num:%d"</span>, dualfov_snap_num);</span><br><span class="line">        numSnapshots /= dualfov_snap_num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGI(<span class="string">"snap count = %d zsl = %d advanced = %d, active camera:%d"</span>,</span><br><span class="line">            numSnapshots, mParameters.isZSLMode(), mAdvancedCaptureConfigured, mActiveCameras);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParameters.isZSLMode()) &#123;</span><br><span class="line">        QCameraChannel *pChannel = m_channels[QCAMERA_CH_TYPE_ZSL];</span><br><span class="line">        QCameraPicChannel *pPicChannel = (QCameraPicChannel *)pChannel;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pPicChannel) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mParameters.getofflineRAW()) &#123;</span><br><span class="line">                startRAWChannel(pPicChannel);</span><br><span class="line">                pPicChannel = (QCameraPicChannel *)m_channels[QCAMERA_CH_TYPE_RAW];</span><br><span class="line">                <span class="keyword">if</span> (pPicChannel == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    LOGE(<span class="string">"RAW Channel is NULL in Manual capture mode"</span>);</span><br><span class="line">                    stopRAWChannel();</span><br><span class="line">                    <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rc = configureOnlineRotation(*pPicChannel);</span><br><span class="line">            <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                LOGE(<span class="string">"online rotation failed"</span>);</span><br><span class="line">                <span class="keyword">return</span> rc;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// start postprocessor</span></span><br><span class="line">            DeferWorkArgs args;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;args, <span class="number">0</span>, <span class="keyword">sizeof</span>(DeferWorkArgs));</span><br><span class="line"></span><br><span class="line">            args.pprocArgs = pPicChannel;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// No need to wait for mInitPProcJob here, because it was</span></span><br><span class="line">            <span class="comment">// queued in startPreview, and will definitely be processed before</span></span><br><span class="line">            <span class="comment">// mReprocJob can begin.</span></span><br><span class="line">            mReprocJob = queueDeferredWork(CMD_DEF_PPROC_START,</span><br><span class="line">                    args);</span><br><span class="line">            <span class="keyword">if</span> (mReprocJob == <span class="number">0</span>) &#123;</span><br><span class="line">                LOGE(<span class="string">"Failure: Unable to start pproc"</span>);</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if all preview buffers are mapped before creating</span></span><br><span class="line">            <span class="comment">// a jpeg session as preview stream buffers are queried during the same</span></span><br><span class="line">            <span class="keyword">uint8_t</span> numStreams = pChannel-&gt;getNumOfStreams();</span><br><span class="line">            QCameraStream *pStream = <span class="literal">NULL</span>;</span><br><span class="line">            QCameraStream *pPreviewStream = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">uint8_t</span> i = <span class="number">0</span> ; i &lt; numStreams ; i++ ) &#123;</span><br><span class="line">                pStream = pChannel-&gt;getStreamByIndex(i);</span><br><span class="line">                <span class="keyword">if</span> (!pStream)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (CAM_STREAM_TYPE_PREVIEW == pStream-&gt;getMyType()) &#123;</span><br><span class="line">                    pPreviewStream = pStream;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pPreviewStream != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mMapLock)</span></span>;</span><br><span class="line">                QCameraMemory *pMemory = pStream-&gt;getStreamBufs();</span><br><span class="line">                <span class="keyword">if</span> (!pMemory) &#123;</span><br><span class="line">                    LOGE(<span class="string">"Error!! pMemory is NULL"</span>);</span><br><span class="line">                    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">uint8_t</span> waitCnt = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (!pMemory-&gt;checkIfAllBuffersMapped() &amp;&amp; (waitCnt &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">                    LOGL(<span class="string">" Waiting for preview buffers to be mapped"</span>);</span><br><span class="line">                    mMapCond.waitRelative(</span><br><span class="line">                            mMapLock, CAMERA_DEFERRED_MAP_BUF_TIMEOUT);</span><br><span class="line">                    LOGL(<span class="string">"Wait completed!!"</span>);</span><br><span class="line">                    waitCnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// If all buffers are not mapped after retries, assert</span></span><br><span class="line">                assert(pMemory-&gt;checkIfAllBuffersMapped());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                assert(pPreviewStream);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create JPEG session</span></span><br><span class="line">            mJpegJob = queueDeferredWork(CMD_DEF_CREATE_JPEG_SESSION,</span><br><span class="line">                    args);</span><br><span class="line">            <span class="keyword">if</span> (mJpegJob == <span class="number">0</span>) &#123;</span><br><span class="line">                LOGE(<span class="string">"Failed to queue CREATE_JPEG_SESSION"</span>);</span><br><span class="line">                <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mReprocJob)) &#123;</span><br><span class="line">                        LOGE(<span class="string">"Reprocess Deferred work was failed"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                m_postprocessor.stop();</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mAdvancedCaptureConfigured) &#123;</span><br><span class="line">                rc = startAdvancedCapture(pPicChannel);</span><br><span class="line">                <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                    LOGE(<span class="string">"cannot start zsl advanced capture"</span>);</span><br><span class="line">                    <span class="keyword">return</span> rc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mLongshotEnabled &amp;&amp; mPrepSnapRun) &#123;</span><br><span class="line">                mCameraHandle-&gt;ops-&gt;start_zsl_snapshot(</span><br><span class="line">                        mCameraHandle-&gt;camera_handle,</span><br><span class="line">                        pPicChannel-&gt;getMyHandle());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If frame sync is ON and it is a SECONDARY camera,</span></span><br><span class="line">            <span class="comment">// we do not need to send the take picture command to interface</span></span><br><span class="line">            <span class="comment">// It will be handled along with PRIMARY camera takePicture request</span></span><br><span class="line">            <span class="keyword">mm_camera_req_buf_t</span> buf;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;buf, <span class="number">0x0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span> ((!mParameters.isAdvCamFeaturesEnabled() &amp;&amp;</span><br><span class="line">                    !mFlashNeeded &amp;&amp;</span><br><span class="line">                    !isLongshotEnabled() &amp;&amp;</span><br><span class="line">                    isFrameSyncEnabled()) &amp;&amp;</span><br><span class="line">                    (getRelatedCamSyncInfo()-&gt;sync_control ==</span><br><span class="line">                    CAM_SYNC_RELATED_SENSORS_ON)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getRelatedCamSyncInfo()-&gt;mode == CAM_MODE_PRIMARY) &#123;</span><br><span class="line">                    buf.type = MM_CAMERA_REQ_FRAME_SYNC_BUF;</span><br><span class="line">                    buf.num_buf_requested = numSnapshots;</span><br><span class="line">                    rc = pPicChannel-&gt;takePicture(&amp;buf);</span><br><span class="line">                    <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                        LOGE(<span class="string">"FS_DBG cannot take ZSL picture, stop pproc"</span>);</span><br><span class="line">                        <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mReprocJob)) &#123;</span><br><span class="line">                            LOGE(<span class="string">"Reprocess Deferred work failed"</span>);</span><br><span class="line">                            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mJpegJob)) &#123;</span><br><span class="line">                            LOGE(<span class="string">"Jpeg Deferred work failed"</span>);</span><br><span class="line">                            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        m_postprocessor.stop();</span><br><span class="line">                        <span class="keyword">return</span> rc;</span><br><span class="line">                    &#125;</span><br><span class="line">                    LOGI(<span class="string">"PRIMARY camera: send frame sync takePicture!!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buf.type = MM_CAMERA_REQ_SUPER_BUF;</span><br><span class="line">                buf.num_buf_requested = numSnapshots;</span><br><span class="line">                buf.num_retro_buf_requested = numRetroSnapshots;</span><br><span class="line">                rc = pPicChannel-&gt;takePicture(&amp;buf);</span><br><span class="line">                <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                    LOGE(<span class="string">"cannot take ZSL picture, stop pproc"</span>);</span><br><span class="line">                        <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mReprocJob)) &#123;</span><br><span class="line">                            LOGE(<span class="string">"Reprocess Deferred work failed"</span>);</span><br><span class="line">                            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mJpegJob)) &#123;</span><br><span class="line">                            LOGE(<span class="string">"Jpeg Deferred work failed"</span>);</span><br><span class="line">                            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                        &#125;</span><br><span class="line">                    m_postprocessor.stop();</span><br><span class="line">                    <span class="keyword">return</span> rc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOGE(<span class="string">"ZSL channel is NULL"</span>);</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// start snapshot</span></span><br><span class="line">        <span class="keyword">if</span> (mParameters.isJpegPictureFormat() ||</span><br><span class="line">                mParameters.isNV16PictureFormat() ||</span><br><span class="line">                mParameters.isNV21PictureFormat()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//STOP Preview for Non ZSL use case</span></span><br><span class="line">            stopPreview();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Config CAPTURE channels</span></span><br><span class="line">            rc = declareSnapshotStreams();</span><br><span class="line">            <span class="keyword">if</span> (NO_ERROR != rc) &#123;</span><br><span class="line">                <span class="keyword">return</span> rc;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rc = addCaptureChannel();</span><br><span class="line">            <span class="keyword">if</span> ((rc == NO_ERROR) &amp;&amp;</span><br><span class="line">                    (<span class="literal">NULL</span> != m_channels[QCAMERA_CH_TYPE_CAPTURE])) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!mParameters.getofflineRAW()) &#123;</span><br><span class="line">                    rc = configureOnlineRotation(</span><br><span class="line">                        *m_channels[QCAMERA_CH_TYPE_CAPTURE]);</span><br><span class="line">                    <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                        LOGE(<span class="string">"online rotation failed"</span>);</span><br><span class="line">                        delChannel(QCAMERA_CH_TYPE_CAPTURE);</span><br><span class="line">                        <span class="keyword">return</span> rc;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                DeferWorkArgs args;</span><br><span class="line">                <span class="built_in">memset</span>(&amp;args, <span class="number">0</span>, <span class="keyword">sizeof</span>(DeferWorkArgs));</span><br><span class="line"></span><br><span class="line">                args.pprocArgs = m_channels[QCAMERA_CH_TYPE_CAPTURE];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// No need to wait for mInitPProcJob here, because it was</span></span><br><span class="line">                <span class="comment">// queued in startPreview, and will definitely be processed before</span></span><br><span class="line">                <span class="comment">// mReprocJob can begin.</span></span><br><span class="line">                mReprocJob = queueDeferredWork(CMD_DEF_PPROC_START,</span><br><span class="line">                        args);</span><br><span class="line">                <span class="keyword">if</span> (mReprocJob == <span class="number">0</span>) &#123;</span><br><span class="line">                    LOGE(<span class="string">"Failure: Unable to start pproc"</span>);</span><br><span class="line">                    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Create JPEG session</span></span><br><span class="line">                mJpegJob = queueDeferredWork(CMD_DEF_CREATE_JPEG_SESSION,</span><br><span class="line">                        args);</span><br><span class="line">                <span class="keyword">if</span> (mJpegJob == <span class="number">0</span>) &#123;</span><br><span class="line">                    LOGE(<span class="string">"Failed to queue CREATE_JPEG_SESSION"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mReprocJob)) &#123;</span><br><span class="line">                        LOGE(<span class="string">"Reprocess Deferred work was failed"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    m_postprocessor.stop();</span><br><span class="line">                    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// start catpure channel</span></span><br><span class="line">                rc =  m_channels[QCAMERA_CH_TYPE_CAPTURE]-&gt;start();</span><br><span class="line">                <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                    LOGE(<span class="string">"cannot start capture channel"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mReprocJob)) &#123;</span><br><span class="line">                        LOGE(<span class="string">"Reprocess Deferred work failed"</span>);</span><br><span class="line">                        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mJpegJob)) &#123;</span><br><span class="line">                        LOGE(<span class="string">"Jpeg Deferred work failed"</span>);</span><br><span class="line">                        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                    &#125;</span><br><span class="line">                    delChannel(QCAMERA_CH_TYPE_CAPTURE);</span><br><span class="line">                    <span class="keyword">return</span> rc;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                QCameraPicChannel *pCapChannel =</span><br><span class="line">                    (QCameraPicChannel *)m_channels[QCAMERA_CH_TYPE_CAPTURE];</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != pCapChannel) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mParameters.isUbiFocusEnabled() ||</span><br><span class="line">                            mParameters.isUbiRefocus() ||</span><br><span class="line">                            mParameters.isChromaFlashEnabled()) &#123;</span><br><span class="line">                        rc = startAdvancedCapture(pCapChannel);</span><br><span class="line">                        <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                            LOGE(<span class="string">"cannot start advanced capture"</span>);</span><br><span class="line">                            <span class="keyword">return</span> rc;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( mLongshotEnabled ) &#123;</span><br><span class="line">                    rc = longShot();</span><br><span class="line">                    <span class="keyword">if</span> (NO_ERROR != rc) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mReprocJob)) &#123;</span><br><span class="line">                            LOGE(<span class="string">"Reprocess Deferred work failed"</span>);</span><br><span class="line">                            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mJpegJob)) &#123;</span><br><span class="line">                            LOGE(<span class="string">"Jpeg Deferred work failed"</span>);</span><br><span class="line">                            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                        &#125;</span><br><span class="line">                        delChannel(QCAMERA_CH_TYPE_CAPTURE);</span><br><span class="line">                        <span class="keyword">return</span> rc;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOGE(<span class="string">"cannot add capture channel"</span>);</span><br><span class="line">                delChannel(QCAMERA_CH_TYPE_CAPTURE);</span><br><span class="line">                <span class="keyword">return</span> rc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Stop Preview before taking NZSL snapshot</span></span><br><span class="line">            stopPreview();</span><br><span class="line"></span><br><span class="line">            rc = mParameters.updateRAW(gCamCapability[mCameraId]-&gt;raw_dim[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (NO_ERROR != rc) &#123;</span><br><span class="line">                LOGE(<span class="string">"Raw dimension update failed %d"</span>, rc);</span><br><span class="line">                <span class="keyword">return</span> rc;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rc = declareSnapshotStreams();</span><br><span class="line">            <span class="keyword">if</span> (NO_ERROR != rc) &#123;</span><br><span class="line">                LOGE(<span class="string">"RAW stream info configuration failed %d"</span>, rc);</span><br><span class="line">                <span class="keyword">return</span> rc;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rc = addChannel(QCAMERA_CH_TYPE_RAW);</span><br><span class="line">            <span class="keyword">if</span> (rc == NO_ERROR) &#123;</span><br><span class="line">                <span class="comment">// start postprocessor</span></span><br><span class="line">                <span class="keyword">if</span> (NO_ERROR != waitDeferredWork(mInitPProcJob)) &#123;</span><br><span class="line">                    LOGE(<span class="string">"Reprocess Deferred work failed"</span>);</span><br><span class="line">                    <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rc = m_postprocessor.start(m_channels[QCAMERA_CH_TYPE_RAW]);</span><br><span class="line">                <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                    LOGE(<span class="string">"cannot start postprocessor"</span>);</span><br><span class="line">                    delChannel(QCAMERA_CH_TYPE_RAW);</span><br><span class="line">                    <span class="keyword">return</span> rc;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rc = startChannel(QCAMERA_CH_TYPE_RAW);</span><br><span class="line">                <span class="keyword">if</span> (rc != NO_ERROR) &#123;</span><br><span class="line">                    LOGE(<span class="string">"cannot start raw channel"</span>);</span><br><span class="line">                    m_postprocessor.stop();</span><br><span class="line">                    delChannel(QCAMERA_CH_TYPE_RAW);</span><br><span class="line">                    <span class="keyword">return</span> rc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOGE(<span class="string">"cannot add raw channel"</span>);</span><br><span class="line">                <span class="keyword">return</span> rc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//When take picture, stop sending preview callbacks to APP</span></span><br><span class="line">    m_stateMachine.setPreviewCallbackNeeded(<span class="literal">false</span>);</span><br><span class="line">    LOGI(<span class="string">"X rc = %d"</span>, rc);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了一个QCameraChannel,调用其takePicture方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : takePicture</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: send request for queued snapshot frames</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @buf : request buf info</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : int32_t type of status</span></span><br><span class="line"><span class="comment"> *              NO_ERROR  -- success</span></span><br><span class="line"><span class="comment"> *              none-zero failure code</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">int32_t</span> QCameraPicChannel::takePicture (<span class="keyword">mm_camera_req_buf_t</span> *buf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> snapshotHandle = getSnapshotHandle();</span><br><span class="line">    LOGD(<span class="string">"mSnapshotHandle = 0x%x"</span>, snapshotHandle);</span><br><span class="line">    <span class="keyword">int32_t</span> rc = m_camOps-&gt;request_super_buf(m_camHandle, snapshotHandle, buf);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的调用就又进入了mm-camera-interface了,通过mm_camera_channel获取到super_buf,里面不再深入了.<br>QCamera2HardwareInterface的takePicture方法首先是创建一个QCameraChannel,开始一个无压缩的RAW管道,调用takePicture方法获取到buffer,最后等待延迟任务mJpegJob创建Jpeg.</p>
<h3 id="结果同步"><a href="#结果同步" class="headerlink" title="结果同步"></a>结果同步</h3><p>拍照方法基本完成了,再看一下回调.QCameraStateMachine调用QCamera2HardwareInterface的takePicture后又调用了signalAPIResult方法发送结果:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> QCamera2HardwareInterface::signalAPIResult(<span class="keyword">qcamera_api_result_t</span> *result)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;m_lock);</span><br><span class="line">    api_result_list *apiResult = (api_result_list *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(api_result_list));</span><br><span class="line">    <span class="keyword">if</span> (apiResult == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"ERROR: malloc for api result failed, Result will not be sent"</span>);</span><br><span class="line">        <span class="keyword">goto</span> malloc_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    apiResult-&gt;result = *result;</span><br><span class="line">    apiResult-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_apiResultList == <span class="literal">NULL</span>) m_apiResultList = apiResult;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        api_result_list *apiResultList = m_apiResultList;</span><br><span class="line">        <span class="keyword">while</span>(apiResultList-&gt;next != <span class="literal">NULL</span>) apiResultList = apiResultList-&gt;next;</span><br><span class="line">        apiResultList-&gt;next = apiResult;</span><br><span class="line">    &#125;</span><br><span class="line">malloc_failed:</span><br><span class="line">    pthread_cond_broadcast(&amp;m_cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;m_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把result给m_apiResultList的末尾.</p>
<p>回到初始QCamera2HardwareInterface的take_picture方法,其最后用waitAPIResult等待结果返回.看这个方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : waitAPIResult</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: wait for API result coming back. This is a blocking call, it will</span></span><br><span class="line"><span class="comment"> *              return only cerntain API event type arrives</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @api_evt : API event type</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : none</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br><span class="line"><span class="keyword">void</span> QCamera2HardwareInterface::waitAPIResult(<span class="keyword">qcamera_sm_evt_enum_t</span> api_evt,</span><br><span class="line">        <span class="keyword">qcamera_api_result_t</span> *apiResult)</span><br><span class="line">&#123;</span><br><span class="line">    LOGD(<span class="string">"wait for API result of evt (%d)"</span>, api_evt);</span><br><span class="line">    <span class="keyword">int</span> resultReceived = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>  (!resultReceived) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;m_cond, &amp;m_lock);</span><br><span class="line">        <span class="keyword">if</span> (m_apiResultList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            api_result_list *apiResultList = m_apiResultList;</span><br><span class="line">            api_result_list *apiResultListPrevious = m_apiResultList;</span><br><span class="line">            <span class="keyword">while</span> (apiResultList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (apiResultList-&gt;result.request_api == api_evt) &#123;</span><br><span class="line">                    resultReceived = <span class="number">1</span>;</span><br><span class="line">                    *apiResult = apiResultList-&gt;result;</span><br><span class="line">                    apiResultListPrevious-&gt;next = apiResultList-&gt;next;</span><br><span class="line">                    <span class="keyword">if</span> (apiResultList == m_apiResultList) &#123;</span><br><span class="line">                        m_apiResultList = apiResultList-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">free</span>(apiResultList);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    apiResultListPrevious = apiResultList;</span><br><span class="line">                    apiResultList = apiResultList-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGD(<span class="string">"return (%d) from API result wait for evt (%d)"</span>,</span><br><span class="line">           apiResult-&gt;status, api_evt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方发是阻塞的,直到有对应消息返回,通过signalAPIResult方法拍照完成的消息传递过去了,这时候我们就能通过waitAPIResult获取到结果了.</p>
<h3 id="流程总结-1"><a href="#流程总结-1" class="headerlink" title="流程总结"></a>流程总结</h3><p>hal层拍照流程:</p>
<ol>
<li>QCamera2HardwareInterface调用take_picture方法,调用processAPI发出QCAMERA_SM_EVT_TAKE_PICTURE请求,使用waitAPIResult等待结果</li>
<li>processAPI调用QCameraStateMachine的proAPI,proAPI给QCameraQueue添加一个qcamera_sm_cmd_t,然后用信号量同步</li>
<li>QCameraStateMachine周期方法smEvtProcRoutine根据信号量从QCameraQueue中取出命令,交给stateMachine方法执行</li>
<li>stateMachine根据对应状态执行方法,如果在preview状态,则设置为拍照进行状态,调用QCamera2HardwareInterface的takePicture方法完成后调用signalAPIResult同步结果</li>
<li>takePicture方法内部过程是创建一个QCameraChannel,使用无压缩的管道,调用QCameraChannel的takePicture方法获取buffer,等待创建Jpeg的任务完成</li>
<li>waitAPIResult收到对应请求的结果,take_picture方法完成,返回请求结果.</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/Camera/" rel="tag"># Camera</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/13/2018-6-13-相机源码深入解析(五)/" rel="next" title="Android8.0相机源码深入解析(五)">
                <i class="fa fa-chevron-left"></i> Android8.0相机源码深入解析(五)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/07/2019-1-7-Ubuntu下编译FFmpeg到Android使用/" rel="prev" title="Ubuntu下编译FFmpeg到Android使用">
                Ubuntu下编译FFmpeg到Android使用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/img/avatar.jpg" alt="AnddyMao">
            
              <p class="site-author-name" itemprop="name">AnddyMao</p>
              <p class="site-description motion-element" itemprop="description">Yesterday you said tomorrow</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:andymao1991@gmail.com" target="_blank" title="Email">
                      
                        <i class="fa fa-fw fa-globe"></i>Email</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.weibo.com/anddymao" target="_blank" title="新浪微博">
                      
                        <i class="fa fa-fw fa-globe"></i>新浪微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.github.com/myandy" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#正文"><span class="nav-number">1.</span> <span class="nav-text">正文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#hal代码结构分析"><span class="nav-number">1.1.</span> <span class="nav-text">hal代码结构分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#接口部分"><span class="nav-number">1.1.1.</span> <span class="nav-text">接口部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hal代码结构"><span class="nav-number">1.1.2.</span> <span class="nav-text">hal代码结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hal打开设备流程"><span class="nav-number">1.2.</span> <span class="nav-text">hal打开设备流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模块注册"><span class="nav-number">1.2.1.</span> <span class="nav-text">模块注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QCamera2Factory"><span class="nav-number">1.2.2.</span> <span class="nav-text">QCamera2Factory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QCamera2HardwareInterface"><span class="nav-number">1.2.3.</span> <span class="nav-text">QCamera2HardwareInterface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mm-camera-interface"><span class="nav-number">1.2.4.</span> <span class="nav-text">mm-camera-interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流程总结"><span class="nav-number">1.2.5.</span> <span class="nav-text">流程总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hal拍照流程"><span class="nav-number">1.3.</span> <span class="nav-text">hal拍照流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发起请求"><span class="nav-number">1.3.1.</span> <span class="nav-text">发起请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态机处理"><span class="nav-number">1.3.2.</span> <span class="nav-text">状态机处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拍照实现"><span class="nav-number">1.3.3.</span> <span class="nav-text">拍照实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结果同步"><span class="nav-number">1.3.4.</span> <span class="nav-text">结果同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流程总结-1"><span class="nav-number">1.3.5.</span> <span class="nav-text">流程总结</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AnddyMao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

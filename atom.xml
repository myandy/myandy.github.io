<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AnddyMao&#39;s Bolg</title>
  
  <subtitle>Yesterday you said tomorrow</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://anddymao.com/"/>
  <updated>2023-02-04T06:32:25.914Z</updated>
  <id>http://anddymao.com/</id>
  
  <author>
    <name>AnddyMao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android所见即所得的视频录制方法</title>
    <link href="http://anddymao.com/2023/01/04/2023-1-4-%20%E5%8D%B3%E6%97%B6%E5%BD%95%E5%88%B6surface/"/>
    <id>http://anddymao.com/2023/01/04/2023-1-4- 即时录制surface/</id>
    <published>2023-01-04T06:00:00.000Z</published>
    <updated>2023-02-04T06:32:25.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>视频解码出来播放后,如果想同时录制,一般有两种办法,一种是录制未解码的流,即直接合成原视频,另一种是实时录制播放的流,第二中方法可以对视频进行后期处理,更加灵活,且所见即所得.这里我们介绍一下即时录制是如何做的.</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><a href="https://myandy.github.io/2017/03/27/2017-3-27-Android%E8%A7%86%E9%A2%91%E6%BB%A4%E9%95%9C" target="_blank" rel="noopener">Android视频滤镜</a><br>5年多前这篇文章介绍了视频加滤镜并合成音视频,采用的也是OpenGL进行绘制,参考的是grafika的实现.这篇其实是采用了照片电影的技术,设计了一套渲染器结构,支持更多特效处理.<br>源码在:<a href="https://github.com/myandy/VideoFilter" target="_blank" rel="noopener">https://github.com/myandy/VideoFilter</a> ,本篇会引用一些这里的代码.</p><p>这篇采用播放器的方法去做录制,同时可以支持后期处理.两者其实原理是一致的,都是一个EGL环境,一个可见surface用于播放显示,一个离屏surface用于录制,这样一个纹理绘制两遍就可以同时完成播放和录制.</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们原有流程:视频播放采用ijkPlayer+GlSurfaceView,做了简单的滤镜处理.<br>目标:支持即时录制,播放时同时进行视频录制.<br>方案:改造GlSurfaceView支持EGL环境,同时播放和录制,编码使用MediaCodec.</p><h2 id="EGL环境"><a href="#EGL环境" class="headerlink" title="EGL环境"></a>EGL环境</h2><p>GlSurfaceView使用的是java的EGL10,android使用的都是EGL14,为了录制流程调用,需要使用EGL14SurfaceView<br>从网上找了一些实现: <a href="https://github.com/331019943/GLSurfaceViewEGL14" target="_blank" rel="noopener">https://github.com/331019943/GLSurfaceViewEGL14</a><br>可以用于替换GlSurfaceView,我稍微改了下,留了几个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//用于切换当前Surface</span><br><span class="line">public void makeCurrent() &#123;</span><br><span class="line">    if (mGLThread != null) &#123;</span><br><span class="line">        mGLThread.mEglHelper.makeCurrent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用于获取EGL环境</span><br><span class="line">public EglCore getEglCore() &#123;</span><br><span class="line">    if (mGLThread != null) &#123;</span><br><span class="line">        return mGLThread.mEglHelper.mEglCore;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="音视频编码"><a href="#音视频编码" class="headerlink" title="音视频编码"></a>音视频编码</h2><p>编码采用VideoFilter流程,MediaMuxer合成音视频,MediaCodec进行编码,MediaCodeC调用createInputSurface,我们需要往这里绘制后才进行编码,逐帧操作.</p><p>视频编码参考:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line">package com.myth.videofilter.encoder;</span><br><span class="line"></span><br><span class="line">import android.media.MediaCodec;</span><br><span class="line">import android.media.MediaCodecInfo;</span><br><span class="line">import android.media.MediaFormat;</span><br><span class="line">import android.media.MediaMuxer;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.view.Surface;</span><br><span class="line"></span><br><span class="line">import com.myth.videofilter.utils.ConfigUtils;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * This class wraps up the core components used for surface-input video encoding.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Once created, frames are fed to the input surface.  Remember to provide the presentation</span><br><span class="line"> * time stamp, and always call drainEncoder() before swapBuffers() to ensure that the</span><br><span class="line"> * producer side doesn&apos;t get backed up.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * This class is not thread-safe, with one exception: it is valid to use the input surface</span><br><span class="line"> * on one thread, and drain the output on a different thread.</span><br><span class="line"> */</span><br><span class="line">public class VideoEncoderCore &#123;</span><br><span class="line">    private static final String TAG = VideoEncoderCore.class.getSimpleName();</span><br><span class="line">    private static final boolean VERBOSE = true;</span><br><span class="line"></span><br><span class="line">    // TODO: these ought to be configurable as well</span><br><span class="line">    private static final String MIME_TYPE = &quot;video/avc&quot;;    // H.264 Advanced Video Coding</span><br><span class="line">    private static final int FRAME_RATE = 30;               // 30fps</span><br><span class="line">    private static final int IFRAME_INTERVAL = 5;           // 5 seconds between I-frames</span><br><span class="line"></span><br><span class="line">    private Surface mInputSurface;</span><br><span class="line">    private MediaMuxer mMuxer;</span><br><span class="line">    private MediaCodec mEncoder;</span><br><span class="line">    private MediaCodec.BufferInfo mBufferInfo;</span><br><span class="line">    private int mTrackIndex;</span><br><span class="line">    private boolean mMuxerStarted;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Configures encoder and muxer state, and prepares the input Surface.</span><br><span class="line">     */</span><br><span class="line">    public VideoEncoderCore(int width, int height, int bitRate, File outputFile)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">        mBufferInfo = new MediaCodec.BufferInfo();</span><br><span class="line"></span><br><span class="line">        MediaFormat format = MediaFormat.createVideoFormat(MIME_TYPE, width, height);</span><br><span class="line"></span><br><span class="line">        // Set some properties.  Failing to specify some of these can cause the MediaCodec</span><br><span class="line">        // configure() call to throw an unhelpful exception.</span><br><span class="line">        format.setInteger(MediaFormat.KEY_COLOR_FORMAT,</span><br><span class="line">                MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);</span><br><span class="line">        format.setInteger(MediaFormat.KEY_BIT_RATE, bitRate);</span><br><span class="line">        format.setInteger(MediaFormat.KEY_FRAME_RATE, FRAME_RATE);</span><br><span class="line">        format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, IFRAME_INTERVAL);</span><br><span class="line">        if (VERBOSE) Log.d(TAG, &quot;format: &quot; + format);</span><br><span class="line"></span><br><span class="line">        // Create a MediaCodec encoder, and configure it with our format.  Get a Surface</span><br><span class="line">        // we can use for input and wrap it with a class that handles the EGL work.</span><br><span class="line">        mEncoder = MediaCodec.createEncoderByType(MIME_TYPE);</span><br><span class="line">        mEncoder.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);</span><br><span class="line">        mInputSurface = mEncoder.createInputSurface();</span><br><span class="line">        mEncoder.start();</span><br><span class="line"></span><br><span class="line">        // Create a MediaMuxer.  We can&apos;t add the video track and resume() the muxer here,</span><br><span class="line">        // because our MediaFormat doesn&apos;t have the Magic Goodies.  These can only be</span><br><span class="line">        // obtained from the encoder after it has started processing data.</span><br><span class="line">        //</span><br><span class="line">        // We&apos;re not actually interested in multiplexing audio.  We just want to convert</span><br><span class="line">        // the raw H.264 elementary stream we get from MediaCodec into a .mp4 file.</span><br><span class="line">        mMuxer = new MediaMuxer(outputFile.toString(),</span><br><span class="line">                MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);</span><br><span class="line"></span><br><span class="line">        mTrackIndex = -1;</span><br><span class="line">        mMuxerStarted = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the encoder&apos;s input surface.</span><br><span class="line">     */</span><br><span class="line">    public Surface getInputSurface() &#123;</span><br><span class="line">        return mInputSurface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Releases encoder resources.</span><br><span class="line">     */</span><br><span class="line">    public void release() &#123;</span><br><span class="line">        if (VERBOSE) Log.d(TAG, &quot;releasing encoder objects&quot;);</span><br><span class="line">        if (mEncoder != null) &#123;</span><br><span class="line"></span><br><span class="line">            mEncoder.release();</span><br><span class="line">            mEncoder = null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mMuxer != null) &#123;</span><br><span class="line">            // TODO: stop() throws an exception if you haven&apos;t fed it any data.  Keep track</span><br><span class="line">            //       of frames submitted, and don&apos;t call stop() if we haven&apos;t written anything.</span><br><span class="line"></span><br><span class="line">            mMuxer.release();</span><br><span class="line">            mMuxer = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long lastTime = 0;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Extracts all pending data from the encoder and forwards it to the muxer.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * If endOfStream is not set, this returns when there is no more data to drain.  If it</span><br><span class="line">     * is set, we send EOS to the encoder, and then iterate until we see EOS on the output.</span><br><span class="line">     * Calling this with endOfStream set should be done once, right before stopping the muxer.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * We&apos;re just using the muxer to get a .mp4 file (instead of a raw H.264 stream).  We&apos;re</span><br><span class="line">     * not recording audio.</span><br><span class="line">     */</span><br><span class="line">    public void drainEncoder(boolean endOfStream) &#123;</span><br><span class="line">        final int TIMEOUT_USEC = 10000;</span><br><span class="line">        if (VERBOSE) Log.d(TAG, &quot;drainEncoder(&quot; + endOfStream + &quot;)&quot;);</span><br><span class="line"></span><br><span class="line">        if (endOfStream) &#123;</span><br><span class="line">            if (VERBOSE) Log.d(TAG, &quot;sending EOS to encoder&quot;);</span><br><span class="line">            mEncoder.signalEndOfInputStream();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteBuffer[] encoderOutputBuffers = mEncoder.getOutputBuffers();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            int encoderStatus = mEncoder.dequeueOutputBuffer(mBufferInfo, TIMEOUT_USEC);</span><br><span class="line">            if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) &#123;</span><br><span class="line">                // no output available yet</span><br><span class="line">                if (!endOfStream) &#123;</span><br><span class="line">                    break;      // out of while</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (VERBOSE) Log.d(TAG, &quot;no output available, spinning to await EOS&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">                // not expected for an encoder</span><br><span class="line">                encoderOutputBuffers = mEncoder.getOutputBuffers();</span><br><span class="line">            &#125; else if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">                // should happen before receiving buffers, and should only happen once</span><br><span class="line">                if (mMuxerStarted) &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;format changed twice&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                MediaFormat newFormat = mEncoder.getOutputFormat();</span><br><span class="line">                Log.d(TAG, &quot;encoder output format changed: &quot; + newFormat);</span><br><span class="line"></span><br><span class="line">                // now that we have the Magic Goodies, resume the muxer</span><br><span class="line">                mTrackIndex = mMuxer.addTrack(newFormat);</span><br><span class="line">                mMuxer.start();</span><br><span class="line">                mMuxerStarted = true;</span><br><span class="line">            &#125; else if (encoderStatus &lt; 0) &#123;</span><br><span class="line">                Log.w(TAG, &quot;unexpected result from encoder.dequeueOutputBuffer: &quot; +</span><br><span class="line">                        encoderStatus);</span><br><span class="line">                // let&apos;s ignore it</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ByteBuffer encodedData = encoderOutputBuffers[encoderStatus];</span><br><span class="line">                if (encodedData == null) &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;encoderOutputBuffer &quot; + encoderStatus +</span><br><span class="line">                            &quot; was null&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if ((mBufferInfo.flags &amp; MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) &#123;</span><br><span class="line">                    // The codec config data was pulled out and fed to the muxer when we got</span><br><span class="line">                    // the INFO_OUTPUT_FORMAT_CHANGED status.  Ignore it.</span><br><span class="line">                    if (VERBOSE) Log.d(TAG, &quot;ignoring BUFFER_FLAG_CODEC_CONFIG&quot;);</span><br><span class="line">                    mBufferInfo.size = 0;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (mBufferInfo.size != 0) &#123;</span><br><span class="line">                    if (!mMuxerStarted) &#123;</span><br><span class="line">                        throw new RuntimeException(&quot;muxer hasn&apos;t started&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // adjust the ByteBuffer values to match BufferInfo (not needed?)</span><br><span class="line">                    encodedData.position(mBufferInfo.offset);</span><br><span class="line">                    encodedData.limit(mBufferInfo.offset + mBufferInfo.size);</span><br><span class="line"></span><br><span class="line">                    if (lastTime == 0) &#123;</span><br><span class="line">                        lastTime = mBufferInfo.presentationTimeUs;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mBufferInfo.presentationTimeUs = lastTime + ConfigUtils.getInstance().getFrameInterval() * 1000;</span><br><span class="line">                        lastTime += ConfigUtils.getInstance().getFrameInterval() * 1000;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    mMuxer.writeSampleData(mTrackIndex, encodedData, mBufferInfo);</span><br><span class="line">                    if (VERBOSE) &#123;</span><br><span class="line">                        Log.d(TAG, &quot;sent &quot; + mBufferInfo.size + &quot; bytes to muxer, ts=&quot; +</span><br><span class="line">                                (mBufferInfo.presentationTimeUs - lastTime) / 1000000f);</span><br><span class="line">//                        lastTime = mBufferInfo.presentationTimeUs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mEncoder.releaseOutputBuffer(encoderStatus, false);</span><br><span class="line"></span><br><span class="line">                if ((mBufferInfo.flags &amp; MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) &#123;</span><br><span class="line">                    if (!endOfStream) &#123;</span><br><span class="line">                        Log.w(TAG, &quot;reached end of stream unexpectedly&quot;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (VERBOSE) Log.d(TAG, &quot;end of stream reached&quot;);</span><br><span class="line">                        mMuxer.stop();</span><br><span class="line">                        mEncoder.stop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;      // out of while</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>VideoFilter采用的最后合成音频的方案,实时写音频更省时一点,这里加上实时编码合成音频的流程.需要注意的是必须音视频编码都回调MediaCodec.INFO_OUTPUT_FORMAT_CHANGED后MediaMuxer才能start.<br>实时写入音频:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public void writeAudio(PcmAudioFrame audioFrame) &#123;</span><br><span class="line">     if (mAudioEncoder == null &amp;&amp; mHasAudio) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             int sampleRate = audioFrame.sampleRate;</span><br><span class="line">             int dataByte = audioFrame.dataBytes;</span><br><span class="line">             int channel = audioFrame.channel;</span><br><span class="line">             mAudioFormat = MediaFormat.createAudioFormat(MediaFormat.MIMETYPE_AUDIO_AAC, sampleRate, channel);</span><br><span class="line">             mAudioFormat.setString(MediaFormat.KEY_MIME, MIMETYPE_AUDIO_AAC);</span><br><span class="line">             mAudioFormat.setInteger(MediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectLC);</span><br><span class="line">             mAudioFormat.setInteger(MediaFormat.KEY_BIT_RATE, sampleRate * dataByte);</span><br><span class="line">             mAudioFormat.setInteger(MediaFormat.KEY_SAMPLE_RATE, sampleRate);</span><br><span class="line"></span><br><span class="line">             mAudioEncoder = MediaCodec.createEncoderByType(MIMETYPE_AUDIO_AAC);</span><br><span class="line">             mAudioEncoder.configure(mAudioFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);</span><br><span class="line">             mAudioEncoder.start();</span><br><span class="line">             mAudioInputBuffers = mAudioEncoder.getInputBuffers();</span><br><span class="line">             mAudioOutBuffer = mAudioEncoder.getOutputBuffers();</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line">             AVLog.d(TAG, e.toString());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     if (mAudioEncoder == null || !mHasAudio) &#123;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line">     try &#123;</span><br><span class="line">         if (mVideoTrackIndex == -1) &#123;</span><br><span class="line">             AVLog.d(TAG, &quot;just waiting video ready&quot;);</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">         int inputBufferIndex = mAudioEncoder.dequeueInputBuffer(-1);</span><br><span class="line">         if (inputBufferIndex &gt;= 0) &#123;</span><br><span class="line">             ByteBuffer inputBuffer = mAudioInputBuffers[inputBufferIndex];</span><br><span class="line">             inputBuffer.clear();</span><br><span class="line">             inputBuffer.put(audioFrame.data);</span><br><span class="line">             mAudioEncoder.queueInputBuffer(inputBufferIndex, 0, audioFrame.data.length, mAudioPts, 0);</span><br><span class="line">             mAudioPts += (getAudioTimeMs(audioFrame) * 1000L);</span><br><span class="line">             if (mRecordTimeListener != null) &#123;</span><br><span class="line">                 mRecordTime = (int) (mAudioPts / 1000);</span><br><span class="line">                 mRecordTimeListener.upDateTime(mRecordTime);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         int outputBufferIndex = mAudioEncoder.dequeueOutputBuffer(mAudioBufferInfo, 1000);</span><br><span class="line">         if (outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">             mAudioTrackIndex = mMuxer.addTrack(mAudioEncoder.getOutputFormat());</span><br><span class="line">             if (mVideoTrackIndex != -1) &#123;</span><br><span class="line">                 mMuxerStarted = true;</span><br><span class="line">                 mMuxer.start();</span><br><span class="line">                 AVLog.d(TAG, &quot;start in audio&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         while (outputBufferIndex &gt;= 0) &#123;</span><br><span class="line">             if (mMuxerStarted) &#123;</span><br><span class="line">                 mMuxer.writeSampleData(mAudioTrackIndex, mAudioOutBuffer[outputBufferIndex], mAudioBufferInfo);</span><br><span class="line">             &#125;</span><br><span class="line">             AVLog.d(TAG, &quot;muxerStart:&quot; + mMuxerStarted + &quot; sent audio &quot; + mAudioBufferInfo.size + &quot; bytes to muxer, ts=&quot; +</span><br><span class="line">                     (mAudioBufferInfo.presentationTimeUs) / 1000000f);</span><br><span class="line">             mAudioEncoder.releaseOutputBuffer(outputBufferIndex, false);</span><br><span class="line">             outputBufferIndex = mAudioEncoder.dequeueOutputBuffer(mAudioBufferInfo, 0);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">         AVLog.e(TAG, &quot;encode Exception:&quot; + e.getLocalizedMessage());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><p>在GLSurfaceView的onDrawFrame里,我们需要做什么呢.</p><ol><li>使用filter绘制到播放surface上</li><li>如果准备开始录制,则让录制线程初始化,并传入录制宽高和EGLCore</li><li>如果开始录制了,切换到录制的surface,使用filter再次绘制,发送消息让录制线程准备编码,再切回播放surface</li></ol><p>参考代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mFilter.draw(photo);</span><br><span class="line">if (surfaceRecordInjection != null) &#123;</span><br><span class="line">    if (surfaceRecordInjection.isRecordingVideo() || surfaceRecordInjection.isStartRecord() &amp;&amp; surfaceRecordInjection.prepared(photo.width(), photo.height(), getEglCore())) &#123;</span><br><span class="line">        surfaceRecordInjection.makeCurrent();</span><br><span class="line">        mFilter.draw(photo);</span><br><span class="line">        surfaceRecordInjection.frameAvailableSoon();</span><br><span class="line">        makeCurrent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="编码能力判断"><a href="#编码能力判断" class="headerlink" title="编码能力判断"></a>编码能力判断</h2><p>因为使用的是MediaCodec硬编码,需要判断编码器是否支持.我们采用h264编码,即MIMETYPE_VIDEO_AVC.2K以下一般机型都能支持,2k会有一些机型不能支持,不支持时可以降低分辨率</p><p>参考代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static boolean checkSupportEncoder(int width, int height) &#123;</span><br><span class="line">    String mimeType = MediaFormat.MIMETYPE_VIDEO_AVC;</span><br><span class="line">    try &#123;</span><br><span class="line">        MediaCodecInfo[] mediaCodecInfos = new MediaCodecList(MediaCodecList.REGULAR_CODECS).getCodecInfos();</span><br><span class="line">        for (MediaCodecInfo encoder : mediaCodecInfos) &#123;</span><br><span class="line">            String[] types = encoder.getSupportedTypes();</span><br><span class="line">            for (String type : types) &#123;</span><br><span class="line">                if (encoder.isEncoder() &amp;&amp; type.equalsIgnoreCase(mimeType)) &#123;</span><br><span class="line">                    MediaCodecInfo.VideoCapabilities capabilities = encoder.getCapabilitiesForType(mimeType).getVideoCapabilities();</span><br><span class="line">                    if (capabilities.isSizeSupported(width, height)) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        AVLog.e(TAG, e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对android音视频了解的话这里面的技术流程还是比较简单的.即时录制是基于现有流程改造,对整体接口设计,代码可用性要求会高很多.<br>本方案可用性还是比较强,比如视频播放有弹幕有特效,需要都录制进去的话可以采用此方案.</p>]]></content>
    
    <summary type="html">
    
      使用OpenGL和mediacodec进行即时录制
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="OpenGL" scheme="http://anddymao.com/tags/OpenGL/"/>
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>ijkPlayer深入探究(四)</title>
    <link href="http://anddymao.com/2022/01/19/2022-1-19-ijkPlayer%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6(%E5%9B%9B)/"/>
    <id>http://anddymao.com/2022/01/19/2022-1-19-ijkPlayer深入探究(四)/</id>
    <published>2022-01-19T06:00:00.000Z</published>
    <updated>2022-01-20T07:41:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>ffmpeg支持的格式很多,一般只需要配置即可.但如果有自定义格式,就需要自定义解码器了,然后要在ijkplayer中编译支持.这篇从实际使用介绍如何在ijkplayer使用自定义解码器。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>前面介绍过自定义解封装器,ijkplayer又提供一套的protocol和demuxer的注册方式，可以不编译ffmpeg的情况下直接在ijkplayer里面添加.<br>但是decoder无法注册,原因是ijkplayer没有提供注册解码器的方法,ffmpeg是可以支持的.这个应该是功能划分问题,ijkplayer作为播放器可以直接解析格式,解码器这层更加独立,不必要耦合到ijkplayer中.</p><p>那我们就在ffmpeg中添加解码器.</p><h1 id="ffmpeg添加解码器"><a href="#ffmpeg添加解码器" class="headerlink" title="ffmpeg添加解码器"></a>ffmpeg添加解码器</h1><h2 id="实现decoder"><a href="#实现decoder" class="headerlink" title="实现decoder"></a>实现decoder</h2><p>ffmpeg中有很多解码器,我仿照写了一个测试的音频解码器.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libavcodec/avcodec.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test_codec.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"internal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *outDataBuffer;</span><br><span class="line">    <span class="keyword">test_dec_handle_t</span>* dec_handle;</span><br><span class="line"></span><br><span class="line">&#125; TestContext;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test_decode_packet</span><span class="params">(AVCodecContext *avctx, <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> *got_frame_ptr, AVPacket *avpkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TestContext *c      = avctx-&gt;priv_data;</span><br><span class="line">    AVFrame *frame      = data;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buf  = avpkt-&gt;data;</span><br><span class="line">    <span class="keyword">int</span> buf_size        = avpkt-&gt;size;</span><br><span class="line">    <span class="keyword">int</span> coded_samples   = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> decoded_samples = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> delayed_samples = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i, ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length = test_decode_single_frame(c-&gt;dec_handle-&gt;p_dec_handle, buf, buf_size, c-&gt;outDataBuffer, <span class="number">2048</span>);</span><br><span class="line">    <span class="keyword">if</span>(length &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">         <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    frame-&gt;nb_samples = length / <span class="number">2</span>;</span><br><span class="line">    frame-&gt;sample_rate = avctx-&gt;sample_rate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = ff_get_buffer(avctx, frame, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(frame-&gt;extended_data[<span class="number">0</span>], c-&gt;outDataBuffer, length);</span><br><span class="line"></span><br><span class="line">    *got_frame_ptr = <span class="number">1</span>;</span><br><span class="line">    ret = avpkt-&gt;size;</span><br><span class="line"></span><br><span class="line">    end:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> av_cold <span class="keyword">int</span> <span class="title">test_decode_close</span><span class="params">(AVCodecContext *avctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TestContext *c = avctx-&gt;priv_data;</span><br><span class="line"></span><br><span class="line">    test_decoder_exit(c-&gt;dec_handle);</span><br><span class="line">    <span class="keyword">if</span>(c-&gt;outDataBuffer)&#123;</span><br><span class="line">        av_freep(&amp;c-&gt;outDataBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    av_log(avctx, AV_LOG_DEBUG,<span class="string">"test_decode_close\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> av_cold <span class="keyword">int</span> <span class="title">test_decode_init</span><span class="params">(AVCodecContext *avctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    av_log(avctx, AV_LOG_DEBUG,<span class="string">"test_decode_init %d,%d,%d\n"</span>,avctx-&gt;sample_rate,avctx-&gt;channels,avctx-&gt;bits_per_raw_sample);</span><br><span class="line">    TestContext *c = avctx-&gt;priv_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">test_decode_attr_t</span> test_dec_param;</span><br><span class="line">    test_dec_param.samplerate = avctx-&gt;sample_rate;</span><br><span class="line">    test_dec_param.samplebit = avctx-&gt;bits_per_raw_sample==<span class="number">1</span>?<span class="number">8</span>:<span class="number">16</span>;</span><br><span class="line">    c-&gt;dec_handle = (<span class="keyword">test_dec_handle_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">test_dec_handle_t</span>));</span><br><span class="line">    c-&gt;dec_handle-&gt;p_dec_handle = (<span class="keyword">test_dec_handle_t</span> *)test_decode_init(&amp;test_dec_param);</span><br><span class="line">    c-&gt;outDataBuffer = av_malloc(<span class="number">2048</span>);</span><br><span class="line">    <span class="keyword">if</span> (!c-&gt;outDataBuffer)&#123;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">    test_decode_close(avctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AVCodec ff_test_decoder = &#123;</span><br><span class="line">    .name            = <span class="string">"test"</span>,</span><br><span class="line">    .long_name       = NULL_IF_CONFIG_SMALL(<span class="string">"TEST"</span>),</span><br><span class="line">    .type            = AVMEDIA_TYPE_AUDIO,</span><br><span class="line">    .id              = AV_CODEC_ID_TEST,</span><br><span class="line">    .priv_data_size  = <span class="keyword">sizeof</span>(TestContext),</span><br><span class="line">    .init            = test_decode_init,</span><br><span class="line">    .close           = test_decode_close,</span><br><span class="line">    .decode          = test_decode_packet,</span><br><span class="line">    .capabilities    = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关键定义都在AVCodec结构体中，名称对应上就能注册进，然后实现对应方法。</p><p>这里定义了一个AV_CODEC_ID_TEST,我们需要注册到ffmpeg中.</p><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><ol><li>首先在avcodec.h中添加这个test ID.在AVCodecID中直接添加.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum AVCodecID &#123;</span><br><span class="line">      AV_CODEC_ID_TEST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在allcodecs.c中加上进行注册</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REGISTER_DECODER(TEST,             test);</span><br></pre></td></tr></table></figure><ol start="3"><li>在Makefile中添加编译</li></ol><p>OBJS中添加 test.o</p><p>在external codec libraries中添加对应关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># external codec libraries</span><br><span class="line">OBJS-$(CONFIG_TEST_DECODER)            += libtest.o</span><br></pre></td></tr></table></figure></p><h1 id="ijkplayer中编译使用"><a href="#ijkplayer中编译使用" class="headerlink" title="ijkplayer中编译使用"></a>ijkplayer中编译使用</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>编译使用ijk中的的compile-ffmpeg.sh,所以之前需要完成相关配置.</p><ol><li><p>首先在module.sh中添加解码器支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-decoder=test&quot;</span><br></pre></td></tr></table></figure></li><li><p>编译头文件及so依赖</p></li></ol><p>如果解码器中依赖了第三方方法,这时候需要引入头文件和so.在do-compile-ffmpeg.sh中可以添加.</p><p>FF_CFLAGS添加头文件路径,FF_DEP_LIBS添加so库路径</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>执行compile-ffmpeg.sh编译ffmpeg,命令行中可以看到解码器的配置,如果包含test又编译成功了,那就没问题了.</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>之前讲过自定义解封装器,这时候就可以在里面加了.</p><p>设置音频格式与参数,然后就会使用对应解码器进行解析了,也可以从解码器AVCodecContext中读到各种参数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AVStream *audioST = avformat_new_stream(ic, NULL);</span><br><span class="line">audioST-&gt;codecpar-&gt;codec_type = AVMEDIA_TYPE_AUDIO;</span><br><span class="line">audioST-&gt;codecpar-&gt;channels = channel;</span><br><span class="line">audioST-&gt;codecpar-&gt;sample_rate = sampleRate;</span><br><span class="line">audioST-&gt;codecpar-&gt;format = AV_SAMPLE_FMT_S16;</span><br><span class="line">audioST-&gt;codecpar-&gt;bits_per_raw_sample = dataBits;</span><br><span class="line">audioST-&gt;codecpar-&gt;codec_id = AV_CODEC_ID_TEST;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇记录了完整的ffmpeg自定义解码器并在ijkplayer中使用的方法,整套流程完整可用,熟悉音视频流程的话还是挺简单的,就是要注意各种配置和编译.</p>]]></content>
    
    <summary type="html">
    
      ijkplayer使用自定义解码器
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="C" scheme="http://anddymao.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>用动态帧率进行视频合成</title>
    <link href="http://anddymao.com/2021/12/10/2021-12-10-%20%E7%94%A8%E5%8A%A8%E6%80%81%E5%B8%A7%E7%8E%87%E8%BF%9B%E8%A1%8C%E8%A7%86%E9%A2%91%E5%90%88%E6%88%90/"/>
    <id>http://anddymao.com/2021/12/10/2021-12-10- 用动态帧率进行视频合成/</id>
    <published>2021-12-10T06:00:00.000Z</published>
    <updated>2021-12-15T11:40:33.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前面介绍过一点音视频参数,也讲到时基.没有看的可以再回看一下.<br>我们现在的问题是有视频流和音频流,但流不是很稳定,如何生成一个稳定的视频.<br>由于生成视频前我们并不知道帧率多少,所以只能用动态帧率,如何去做合成呢?</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们目前已经有了编码好的流,所以只需要封装即可,推荐用ffmpeg进行封装,适配性强.</p><h2 id="ffmpeg封装方法"><a href="#ffmpeg封装方法" class="headerlink" title="ffmpeg封装方法"></a>ffmpeg封装方法</h2><p>一般用得多的是封装mp4,需要这几个步骤：</p><ol><li>首先需要创建ffmpeg相关数据结构</li><li>创建文件写入流</li><li>写入头</li><li>逐帧写入数据</li><li>关闭流</li></ol><h3 id="创建ffmpeg数据结构"><a href="#创建ffmpeg数据结构" class="headerlink" title="创建ffmpeg数据结构"></a>创建ffmpeg数据结构</h3><p>这一步创建主要是创建format参数和音视频数据流的参数,具体参数需要按功能需求自己设置.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">handle-&gt;_format_context = avformat_alloc_context();</span><br><span class="line">if (handle-&gt;_format_context == NULL) &#123;</span><br><span class="line">    LOGE(&quot;create_file avformat_alloc_context error&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">handle-&gt;_fps = vfps;</span><br><span class="line">handle-&gt;_videoCode = videoCode;</span><br><span class="line">handle-&gt;_format_context-&gt;oformat = av_guess_format(&quot;mp4&quot;, path, NULL);</span><br><span class="line">if (handle-&gt;_format_context-&gt;oformat == NULL) &#123;</span><br><span class="line">    LOGE(&quot;create_file av_guess_format error path = %s&quot;, path);</span><br><span class="line">    goto error;</span><br><span class="line">&#125;</span><br><span class="line">if (videoCode == video_codec_id_h264) &#123;</span><br><span class="line">    handle-&gt;_format_context-&gt;oformat-&gt;video_codec = AV_CODEC_ID_H264;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    handle-&gt;_format_context-&gt;oformat-&gt;video_codec = AV_CODEC_ID_H265;</span><br><span class="line">&#125;</span><br><span class="line">handle-&gt;_format_context-&gt;oformat-&gt;audio_codec = AV_CODEC_ID_AAC;</span><br><span class="line">memcpy(handle-&gt;_format_context-&gt;filename, path, strlen(path));</span><br><span class="line">handle-&gt;_video_stream = avformat_new_stream(handle-&gt;_format_context, NULL);</span><br><span class="line">if (handle-&gt;_video_stream == NULL) &#123;</span><br><span class="line">    LOGE(&quot;create_file avformat_new_stream video error&quot;);</span><br><span class="line">    goto error;</span><br><span class="line">&#125;</span><br><span class="line">handle-&gt;_video_stream-&gt;id = handle-&gt;_format_context-&gt;nb_streams - 1;</span><br><span class="line">handle-&gt;_video_stream-&gt;codec-&gt;codec_type = AVMEDIA_TYPE_VIDEO;</span><br><span class="line">if (videoCode == video_codec_id_h264) &#123;</span><br><span class="line">    handle-&gt;_video_stream-&gt;codec-&gt;codec_id = AV_CODEC_ID_H264;</span><br><span class="line">    handle-&gt;_video_stream-&gt;codec-&gt;level = 0x7F;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    handle-&gt;_video_stream-&gt;codec-&gt;codec_id = AV_CODEC_ID_H265;</span><br><span class="line">&#125;</span><br><span class="line">handle-&gt;_video_stream-&gt;codec-&gt;width = vwidth;</span><br><span class="line">handle-&gt;_video_stream-&gt;codec-&gt;height = vheight;</span><br><span class="line">handle-&gt;_video_stream-&gt;time_base.num = 1;</span><br><span class="line">handle-&gt;_video_stream-&gt;time_base.den = 90000;</span><br><span class="line">handle-&gt;_audio_stream = avformat_new_stream(handle-&gt;_format_context, NULL);</span><br><span class="line">if (handle-&gt;_audio_stream == NULL) &#123;</span><br><span class="line">    LOGE(&quot;create_file avformat_new_stream audio error&quot;);</span><br><span class="line">    goto error;</span><br><span class="line">&#125;</span><br><span class="line">handle-&gt;_audio_stream-&gt;id = handle-&gt;_format_context-&gt;nb_streams - 1;</span><br><span class="line">handle-&gt;_audio_stream-&gt;codec-&gt;codec_type = AVMEDIA_TYPE_AUDIO;</span><br><span class="line">handle-&gt;_audio_stream-&gt;codec-&gt;codec_id = AV_CODEC_ID_AAC;</span><br><span class="line">handle-&gt;_audio_stream-&gt;codec-&gt;sample_rate = asamplerate;</span><br></pre></td></tr></table></figure></p><h3 id="创建文件写入流"><a href="#创建文件写入流" class="headerlink" title="创建文件写入流"></a>创建文件写入流</h3><p>这一步用avio_open打开文件开启write,会创建新文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = avio_open(&amp;handle-&gt;_format_context-&gt;pb, path, AVIO_FLAG_WRITE);</span><br><span class="line">if (ret &lt; 0) &#123;</span><br><span class="line">  LOGE(&quot;reate_file avio_open error = %d&quot;, ret);</span><br><span class="line">  goto error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="写入头"><a href="#写入头" class="headerlink" title="写入头"></a>写入头</h3><p>写入头信息,这一步有时候会在首帧之后做,因为h264的首帧会带sps和pps信息在_video_extradata中,需要在首帧中解析出_video_extradata写入_format_context中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handle-&gt;_video_stream-&gt;codec-&gt;extradata = handle-&gt;_video_extradata;</span><br><span class="line">handle-&gt;_video_stream-&gt;codec-&gt;extradata_size = handle-&gt;_video_extradata_size;</span><br><span class="line">ret = avformat_write_header(handle-&gt;_format_context, NULL);</span><br><span class="line">ret = avformat_write_header(handle-&gt;_format_context, NULL);</span><br></pre></td></tr></table></figure></p><h3 id="逐帧写入数据"><a href="#逐帧写入数据" class="headerlink" title="逐帧写入数据"></a>逐帧写入数据</h3><p>这一步就是写入AVPacket数据,要掌握这个数据结构,写入flags,pts,dts,stream_index几个参数就可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">av_interleaved_write_frame(handle-&gt;_format_context, &amp;pkt);</span><br></pre></td></tr></table></figure></p><h3 id="关闭流"><a href="#关闭流" class="headerlink" title="关闭流"></a>关闭流</h3><p>调用av_write_trailer关闭mp4写入,再清空数据结构即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">av_write_trailer(handle-&gt;_format_context);</span><br><span class="line">avformat_free_context(handle-&gt;_format_context);</span><br></pre></td></tr></table></figure></p><h2 id="动态帧率"><a href="#动态帧率" class="headerlink" title="动态帧率"></a>动态帧率</h2><p>实现动态帧率的话很简单,关键是AVPacket的pts参数,帧的间隔可以大可以小,最后整个视频会计算出一个正确的帧率.<br>注意的是音频不能做动态,因为音频是连续的,每一帧是固定时长的,很多播放器并不会读取音频的时间戳而是去根据每帧长度去得到当前的帧的时间.<br>所以音视频对齐都是视频对齐音频.</p><p>如果是固定帧率的话就不需要写入pts参数,但要写入sample_rate参数.这样就帧间隔一致了.</p>]]></content>
    
    <summary type="html">
    
      如何实现用动态帧率进行编码MP4
    
    </summary>
    
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>超大像素的OpenGL处理</title>
    <link href="http://anddymao.com/2021/12/06/2021-12-6-%E8%B6%85%E5%A4%A7%E5%83%8F%E7%B4%A0%E7%9A%84OpenGL%E5%A4%84%E7%90%86/"/>
    <id>http://anddymao.com/2021/12/06/2021-12-6-超大像素的OpenGL处理/</id>
    <published>2021-12-06T06:00:00.000Z</published>
    <updated>2021-12-15T11:41:40.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>OpenGL各个机型上有最大分辨率限制,因为屏幕大小一般也就1k或者2k.这个限制比较老的手机是2048,新的有4096,8192甚至16384的.<br>如果只是做屏幕渲染不会有超出这个大小的情况,但如果要做离屏渲染就有可能超过这个大小了.<br>比如我们的目标是处理一亿像素的原图,比如小米10相机拍的108M照片,其分辨率是12032*9024,那很多手机上OpenGL已经无法处理了,这时候怎么办呢?</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>这时候直接全图加载进OpenGL已经不可能，那是不是可以部分加载，部分处理再合成呢？<br>输入是图片，加载出来是bitmap，在java层做的话需要分割出多个小的bitmap，处理完成后合成一个大的bitmap，理论上可行，但这里的分块和合成太消耗资源了，这里可以放到c层做，<br> 利用指针的特性节省掉分块和合成的时间.</p><h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><h3 id="获取OpenGL最大处理长度"><a href="#获取OpenGL最大处理长度" class="headerlink" title="获取OpenGL最大处理长度"></a>获取OpenGL最大处理长度</h3><p>这个问题从stackoverflow上可以获取到答案,有两种方法,第一种直接获取GL_MAX_TEXTURE_SIZE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] maxTextureSize = new int[1];</span><br><span class="line">GLES20.glGetIntegerv(GLES20.GL_MAX_TEXTURE_SIZE, maxTextureSize, 0);</span><br></pre></td></tr></table></figure><p>第二种是通过EGL的配置来获取EGL_MAX_PBUFFER_WIDTH,默认值为2048.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxTextureSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> IMAGE_MAX_BITMAP_DIMENSION = <span class="number">2048</span>;</span><br><span class="line">     EGL10 egl = (EGL10) EGLContext.getEGL();</span><br><span class="line">     EGLDisplay display = egl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);</span><br><span class="line">     <span class="keyword">int</span>[] version = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">     egl.eglInitialize(display, version);</span><br><span class="line">     <span class="keyword">int</span>[] totalConfigurations = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">     egl.eglGetConfigs(display, <span class="keyword">null</span>, <span class="number">0</span>, totalConfigurations);</span><br><span class="line">     EGLConfig[] configurationsList = <span class="keyword">new</span> EGLConfig[totalConfigurations[<span class="number">0</span>]];</span><br><span class="line">     egl.eglGetConfigs(display, configurationsList, totalConfigurations[<span class="number">0</span>], totalConfigurations);</span><br><span class="line">     <span class="keyword">int</span>[] textureSize = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">     <span class="keyword">int</span> maximumTextureSize = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalConfigurations[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">         egl.eglGetConfigAttrib(display, configurationsList[i], EGL10.EGL_MAX_PBUFFER_WIDTH, textureSize);</span><br><span class="line">         <span class="keyword">if</span> (maximumTextureSize &lt; textureSize[<span class="number">0</span>])</span><br><span class="line">             maximumTextureSize = textureSize[<span class="number">0</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     egl.eglTerminate(display);</span><br><span class="line">     <span class="keyword">return</span> Math.max(maximumTextureSize, IMAGE_MAX_BITMAP_DIMENSION);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>第一种方法获取到的最大大小可能与最大纹理无关,所以应该用第二种.</p><h3 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h3><p>读取到bitmap后,可以根据宽高进行分块,分成width/maxTextureSize向上取整块,比如12032就可以分成2048*5+1795.<br>这里不用实际切割bitmap,保留每块的位置待用即可.</p><h3 id="读取bitmap指针"><a href="#读取bitmap指针" class="headerlink" title="读取bitmap指针"></a>读取bitmap指针</h3><p>通过AndroidBitmap_lockPixels就可以获取bitmap对应的指针pixels</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((ret = AndroidBitmap_lockPixels(env, bitmap, (<span class="keyword">void</span> **) &amp;pixelscolor)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//锁定AndroidBitmap_lockPixels</span></span><br><span class="line">    <span class="comment">//锁定之后，pixelscolor指向图片的首地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">pixels = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) pixelscolor;</span><br></pre></td></tr></table></figure><h3 id="读取纹理"><a href="#读取纹理" class="headerlink" title="读取纹理"></a>读取纹理</h3><p>java层读取纹理只能读取整个bitmap的,c层可以根据指针更加灵活,只需要更改宽度的对齐就可以.<br>stride是原始图片的宽度,按照这个大小进行对其.w,h的想要读取分块的宽高,<br>offset是当前分块的首像素相对原始图像的偏移,记得要看图像格式,如果是RGBA,就是位置偏移再乘以4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_anddymao_block_BlockSdkUtils_updateTextureWidthStride(JNIEnv *env,</span><br><span class="line">                                                                             jclass type,</span><br><span class="line">                                                                             jint tex, jint w,</span><br><span class="line">                                                                             jint h,</span><br><span class="line">                                                                             jint stride,</span><br><span class="line">                                                                             jint offset) &#123;</span><br><span class="line"></span><br><span class="line">    byte *buffer = pixels;</span><br><span class="line">    <span class="keyword">if</span> (stride != w) &#123;</span><br><span class="line">        glPixelStorei(GL_UNPACK_ROW_LENGTH, stride);</span><br><span class="line">    &#125;</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, tex);</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, w, h, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, buffer + offset);</span><br><span class="line">    <span class="keyword">if</span> (stride != w) &#123;</span><br><span class="line">        glPixelStorei(GL_UNPACK_ROW_LENGTH, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取到纹理后就可以对这块纹理进行滤镜操作了,操作完再写入原始图片数据中.</p><h3 id="读OpenGL数据并写入"><a href="#读OpenGL数据并写入" class="headerlink" title="读OpenGL数据并写入"></a>读OpenGL数据并写入</h3><p>在java层执行完滤镜操作读取得到数据再传入native层更新是可以的,但这样效率会低一点.<br>我们直接在C层readPixel.同样需要指定宽度的对齐,也是原始图片的宽度.然后找到指针对应位置,执行glReadPixels,数据就自动更新到对应位置了.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_anddymao_block_BlockSdkUtils_readPixelsAndMerge(JNIEnv *env, jclass type,</span><br><span class="line">                                                                       jint x, jint y,</span><br><span class="line">                                                                       jint w, jint h, jint stride,</span><br><span class="line">                                                                       jint offset) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stride != w) &#123;</span><br><span class="line">        glPixelStorei(GL_PACK_ROW_LENGTH, stride);</span><br><span class="line">    &#125;</span><br><span class="line">    byte *buffer = pixels + offset;</span><br><span class="line">    glPixelStorei(GL_PACK_ALIGNMENT, <span class="number">1</span>);</span><br><span class="line">    glReadPixels(x, y, w, h, GL_RGBA, GL_UNSIGNED_BYTE, buffer);</span><br><span class="line">    <span class="keyword">if</span> (stride != w) &#123;</span><br><span class="line">        glPixelStorei(GL_PACK_ROW_LENGTH, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解锁bitmap"><a href="#解锁bitmap" class="headerlink" title="解锁bitmap"></a>解锁bitmap</h3><p>用AndroidBitmap_unlockPixels(env, bitmap)解锁bitmap,指针就会废弃掉,bitmap就能可用了,这个bitmap就是最后的输出bitmap.</p><h2 id="执行效率总结"><a href="#执行效率总结" class="headerlink" title="执行效率总结"></a>执行效率总结</h2><p>即使OpengGL能够负担大size的处理,分块处理也会比直接处理快很多,通过这种办法可以进行加速处理.从始至终只需要一个bitmap,内存的消耗也是最低的.</p><h2 id="特殊的处理问题"><a href="#特殊的处理问题" class="headerlink" title="特殊的处理问题"></a>特殊的处理问题</h2><h3 id="位置相关问题"><a href="#位置相关问题" class="headerlink" title="位置相关问题"></a>位置相关问题</h3><p>如果OpenGL处理只和颜色相关,就可以用这种方案直接处理.如果和位置相关,分开后再处理片段着色器位置已改变,就处理不了了,或者自己根据位置的改变传入对应的参数,这样就是麻烦很多.<br>我们在这种情况下也做了支持.</p><h3 id="周边色块相关问题"><a href="#周边色块相关问题" class="headerlink" title="周边色块相关问题"></a>周边色块相关问题</h3><p>如果片段着色器的处理和周边色块相关,比如高斯模糊,马赛克,这种可以每块读取时都往周边扩展一点,最后写入还是按照原始大小.<br>这种情况下做了支持,效果也是没问题的.</p><p>如果不是强烈需要原始超大图,编辑后用一般大小的图片就可以,但系统应用的支持却是没办法,必须做支持.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分享了一下之前做这个需求的思路,欢迎共同探讨.</p>]]></content>
    
    <summary type="html">
    
      OpenGL如何突破设备限制对超大bitmap处理
    
    </summary>
    
    
      <category term="OpenGL" scheme="http://anddymao.com/tags/OpenGL/"/>
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>一种万能hls协议解析方法</title>
    <link href="http://anddymao.com/2021/08/03/2021-08-03-%E4%B8%80%E7%A7%8D%E4%B8%87%E8%83%BDhls%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E6%96%B9%E6%B3%95/"/>
    <id>http://anddymao.com/2021/08/03/2021-08-03-一种万能hls协议解析方法/</id>
    <published>2021-08-03T06:00:00.000Z</published>
    <updated>2021-08-04T12:52:37.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HLS介绍"><a href="#HLS介绍" class="headerlink" title="HLS介绍"></a>HLS介绍</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>HLS，全称 HTTP Live Streaming，是苹果公司实现的基于 HTTP 的流媒体传输协议。HLS 的基本原理非常简单，它是将多媒体文件或直接流进行切片，形成一堆的 ts 文件和 m3u8 索引文件。</p><p>播放器首先需要解析的是m3u8索引文件，一个m3u8文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-VERSION:3         // 版本信息</span><br><span class="line">#EXT-X-TARGETDURATION:3 // 每个分片的目标时长</span><br><span class="line">#EXT-X-MEDIA-SEQUENCE:0  // 分片起始编号</span><br><span class="line">#EXTINF:3.0,       // 分片时长</span><br><span class="line">test000.ts               // 分片路径</span><br><span class="line">#EXT-X-DISCONTINUITY   //非连续标记</span><br><span class="line">#EXTINF:3.0,        // 分片时长</span><br><span class="line">test001.ts               // 分片路径</span><br></pre></td></tr></table></figure><h2 id="fMP4"><a href="#fMP4" class="headerlink" title="fMP4"></a>fMP4</h2><p>在EXT-X-VERSION 7支持了fmp4.<br>fMP4 是基于 MPEG-4 Part 12 的流媒体格式,与 mp4 很相似，但也有一些区别,fMP4更好的适应流式播的需求.<br>fmp4可以支持h.265,能够大大节省带宽，已经慢慢变成现在的视频主流，尤其是视频监控领域。</p><h2 id="DASH"><a href="#DASH" class="headerlink" title="DASH"></a>DASH</h2><p>DASH是可以自适应比特率的服务端，客户端流媒体解决方案。可以根据自由选择需要播放的媒体分片，可以实现adaptive bitrate streaming技术，不同画质内容无缝切换，提供更好的播放体验。<br>exoplayer基础library就支持了DASH.</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>hls格式是一种协议标准，服务端可能提供不同的视频，客户端的解析能力也不一样。ios11后对fmp4的支持就比较好，android8以后部分机型支持，但兼容性不够好，时间戳等有问题就会出现不能播放，但android上exoplayer支持兼容性很好。</p><p>hls视频有些问题就会导致支持变差，尤其是视频源不可控的情况下，典型的会有时间戳不连续，视频大小变化，音视频编码格式变化等等。<br>有些情况ios也可能无法支持，ios和android两端的体验也不一致。现在就需要一种办法统一播放，能够自定义解析hls格式支持，兼容特殊格式。</p><h1 id="方案与实现"><a href="#方案与实现" class="headerlink" title="方案与实现"></a>方案与实现</h1><h2 id="寻找方案"><a href="#寻找方案" class="headerlink" title="寻找方案"></a>寻找方案</h2><p>视频格式解析最佳还是ffmpeg，播放器可以基于ijkplayer改造。<br>ffmpeg原生的hls格式解析器兼容性很差，时间戳有问题就无法播放，更无法播放fmp4.<br>hls实际就是个m3u8的索引文件，就是多个视频片段的组合，这个和concat协议很类似，那是不是可以用concat协议支持hls呢。<br>concat是多个文件的拼接，天然支持DASH，对多个文件的不同性适配很好。那就尝试用这个方案了。</p><h2 id="concat支持本地m3u8"><a href="#concat支持本地m3u8" class="headerlink" title="concat支持本地m3u8"></a>concat支持本地m3u8</h2><p>concat协议实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ffconcat version 1.0</span><br><span class="line"># my first filename</span><br><span class="line">file /mnt/share/file-1.mp4</span><br><span class="line">duration 20.0</span><br><span class="line"># my second filename</span><br><span class="line">file &apos;/mnt/share/file 2.mp4&apos;</span><br></pre></td></tr></table></figure></p><p>可以看到concat协议很简单，就包含文件长度和地址，这个和m3u8的完全一样。<br>如果是m3u8的本地视频，那就可以直接完美支持，测试也很简单的通过了。</p><h2 id="加密支持"><a href="#加密支持" class="headerlink" title="加密支持"></a>加密支持</h2><p>我需要解析的hls包括#EXT-X-KEY:METHOD=AES-128<br>这就需要增加AES-128的方法，这个从hls.c找相关代码，改写过来，还算轻松搞定了。</p><h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><ol><li><p>fmp4+hevc视频大小变化花屏<br>这个是必须加上hevc_mp4toannexb，原始协议只支持h264_mp4toannexb<br>H.264/5码流分Annex-B和AVCC两种格式,<br>AVCC以长度信息分割NALU，在mp4和flv等封装格式中使用。<br>Annex-B以start code(0x000001或0x00000001)分割NALU，在mpegts流媒体文件中使用<br>加上hevc_mp4toannexb后每一帧都能解析出视频宽高，这样不会有切换花屏问题。</p></li><li><p>ts视频没有声音<br>这样发现是因为probesize和analyzeduration设置过小，导致信息没有读取出现，这两个参数直接不设置即可，m3u8单片的数据量本来就小。</p></li><li><p>在线fmp4视频无法播放<br>这个发现是http协议不支持range，支持range又会请求多次，这个解决方案在前一篇介绍了</p></li></ol><h2 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h2><ol><li><p>多线程打开视频优化加载速度<br>m3u8文件很长时，读取head的时间非常耗时，正常流程是读取完成后再打开第一个视频，可以优化成添加第一个视频时就去多线程读取，最后使用pthread_join去等待读取完成</p></li><li><p>首次打开视频时seek的速度优化<br>concat协议默认会打开第一个视频，起播seek后又会打开新的视频，https的视频打开本来就很慢，这样起播就非常慢。<br>解决方案是起播时就把start_seek_time传入，根据start_seek_time决定第一个打开的文件</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个任务去年做了一段时间然后放弃，今年鼓起勇气终于完成了，碰到了很多奇怪的问题，一个是缺乏经验，一个是没有资料，一切都得从源码分析解决。<br>解决一个问题最难的是确定原因，其实是寻找方案，编码解决问题是最简单的。这里分享方案思路，代码就不重要了。</p>]]></content>
    
    <summary type="html">
    
      扩展concat协议解析hls视频
    
    </summary>
    
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>从http协议解决在线Mp4多次请求问题</title>
    <link href="http://anddymao.com/2021/07/28/2021-07-28-%E4%BB%8Ehttp%E5%8D%8F%E8%AE%AE%E8%A7%A3%E5%86%B3%E5%9C%A8%E7%BA%BFMp4%E5%A4%9A%E6%AC%A1%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/"/>
    <id>http://anddymao.com/2021/07/28/2021-07-28-从http协议解决在线Mp4多次请求问题/</id>
    <published>2021-07-28T06:00:00.000Z</published>
    <updated>2021-08-04T12:50:11.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近弄hls+fmp4的播放支持。发现一个mp4会请求三次，数据量会达到单个视频数据量的两倍多。</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>直接原因很简单，mp4需要获取到MOOV BOX信息，读取头后需要seek到Moov位置，第三次需要seek到视频位置<br>解决办法也很简单，一个ffmpeg命令即可解决：<br>ffmpeg -i input.mp4 -movflags faststart -acodec copy -vcodec copy out.mp4<br>参考了这里<a href="https://www.zhangxinxu.com/wordpress/2018/12/video-moov-box/" target="_blank" rel="noopener">https://www.zhangxinxu.com/wordpress/2018/12/video-moov-box/</a></p><p>那如果视频我们没法改或者不想改的话怎么办呢？</p><h1 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h1><p>MOOV后置视频三次请求后两次都是带range的，如果视频地址不支持range，那这个请求就直接请求不了，支持range呢又会有多次请求，不支持range还会无法seek。<br>其实这些都是http和tcp协议的问题，如果用file协议的视频就没有问题。</p><p>视频不能动，那是不是可以对http协议做些什么。</p><h1 id="http-hook方案"><a href="#http-hook方案" class="headerlink" title="http hook方案"></a>http hook方案</h1><h2 id="确定方案"><a href="#确定方案" class="headerlink" title="确定方案"></a>确定方案</h2><p>分析出mp4协议调用seek会导致http进行重新请求，那我们不调用seek不就可以了吗。<br>因为http协议没有把全部数据保存下来，只有buffer保存当前获取的数据。<br>所以可以hook住http协议，直接把全部数据保存到内存，seek时做一个假操作，read时给对应数据就可以。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现使用ijkplayer扩展协议方式，参考ijkhttphook,写了一个ijkhttpseekhook的协议。</p><p>定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">URLProtocol ijkimp_ff_ijkhttpseekhook_protocol = &#123;</span><br><span class="line">        .name                = &quot;ijkhttpseekhook&quot;,</span><br><span class="line">        .url_open2           = ijkhttpseekhook_open,</span><br><span class="line">        .url_read            = ijkhttpseekhook_read,</span><br><span class="line">        .url_seek            = ijkhttpseekhook_seek,</span><br><span class="line">        .url_close           = ijkurlhook_close,</span><br><span class="line">        .priv_data_size      = sizeof(Context),</span><br><span class="line">        .priv_data_class     = &amp;ijkhttpseekhook_context_class,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>打开时进行协议替换，增加了一个crypto的加密协议，这个是hls中用到的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static int ijkhttpseekhook_open(URLContext *h, const char *arg, int flags, AVDictionary **options) &#123;</span><br><span class="line">    Context *c = h-&gt;priv_data;</span><br><span class="line">    int ret = 0;</span><br><span class="line"></span><br><span class="line">    c-&gt;app_ctx = (AVApplicationContext *) (intptr_t) c-&gt;app_ctx_intptr;</span><br><span class="line">    c-&gt;scheme = &quot;ijkhttpseekhook:&quot;;</span><br><span class="line">    if (av_stristart(arg, &quot;ijkhttpseekhook:crypto+&quot;, NULL))</span><br><span class="line">        c-&gt;inner_scheme = &quot;crypto&quot;;</span><br><span class="line">    else if (av_stristart(arg, &quot;ijkhttpseekhook:https:&quot;, NULL))</span><br><span class="line">        c-&gt;inner_scheme = &quot;https:&quot;;</span><br><span class="line">    else</span><br><span class="line">        c-&gt;inner_scheme = &quot;http:&quot;;</span><br><span class="line"></span><br><span class="line">    ret = ijkurlhook_init(h, arg, flags, options);</span><br><span class="line">    if (ret)</span><br><span class="line">        goto fail;</span><br><span class="line"></span><br><span class="line">    ret = ijkurlhook_call_inject(h);</span><br><span class="line">    if (ret)</span><br><span class="line">        goto fail;</span><br><span class="line"></span><br><span class="line">    ret = ijkurlhook_reconnect(h, NULL);</span><br><span class="line"></span><br><span class="line">    fail:</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接时的方法，先请求内部协议，然后获取数据长度，初始化data，再用ffurl_read读取数据。因为http有chunksize，一次不能全部获取，多次请求到全部数据。这里的read_total可能会小于logical_size，不知道是什么原因。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static int ijkurlhook_reconnect(URLContext *h, AVDictionary *extra) &#123;</span><br><span class="line">    Context *c = h-&gt;priv_data;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    URLContext *new_url = NULL;</span><br><span class="line">    AVDictionary *inner_options = NULL;</span><br><span class="line"></span><br><span class="line">    assert(c-&gt;inner_options);</span><br><span class="line">    av_dict_copy(&amp;inner_options, c-&gt;inner_options, 0);</span><br><span class="line">    if (extra)</span><br><span class="line">        av_dict_copy(&amp;inner_options, extra, 0);</span><br><span class="line"></span><br><span class="line">    ret = ffurl_open_whitelist(&amp;new_url,</span><br><span class="line">                               c-&gt;app_io_ctrl.url,</span><br><span class="line">                               c-&gt;inner_flags,</span><br><span class="line">                               &amp;h-&gt;interrupt_callback,</span><br><span class="line">                               &amp;inner_options,</span><br><span class="line">                               h-&gt;protocol_whitelist,</span><br><span class="line">                               h-&gt;protocol_blacklist,</span><br><span class="line">                               h);</span><br><span class="line">    if (ret)</span><br><span class="line">        goto fail;</span><br><span class="line"></span><br><span class="line">    ffurl_closep(&amp;c-&gt;inner);</span><br><span class="line"></span><br><span class="line">    c-&gt;inner = new_url;</span><br><span class="line">    h-&gt;is_streamed = c-&gt;inner-&gt;is_streamed;</span><br><span class="line">    c-&gt;logical_pos = ffurl_seek(c-&gt;inner, 0, SEEK_CUR);</span><br><span class="line">    if (c-&gt;inner-&gt;is_streamed)</span><br><span class="line">        c-&gt;logical_size = -1;</span><br><span class="line">    else</span><br><span class="line">        c-&gt;logical_size = ffurl_seek(c-&gt;inner, 0, AVSEEK_SIZE);</span><br><span class="line"></span><br><span class="line">    c-&gt;data = av_malloc(c-&gt;logical_size);</span><br><span class="line">    int read;</span><br><span class="line">    int read_total = 0;</span><br><span class="line">    while (read = ffurl_read(c-&gt;inner, c-&gt;data + read_total, c-&gt;logical_size) &gt; 0) &#123;</span><br><span class="line">        read_total += read;</span><br><span class="line">    &#125;</span><br><span class="line">    if (read &lt; 0) &#123;</span><br><span class="line">        goto fail;</span><br><span class="line">    &#125;</span><br><span class="line">    c-&gt;io_error = 0;</span><br><span class="line">    fail:</span><br><span class="line">    av_dict_free(&amp;inner_options);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>seek代码很简单，需要seek时把logical_pos设置为pos就可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static int64_t ijkhttpseekhook_seek(URLContext *h, int64_t pos, int whence) &#123;</span><br><span class="line">    Context *c = h-&gt;priv_data;</span><br><span class="line">    int ret;</span><br><span class="line">    if (whence == AVSEEK_SIZE)</span><br><span class="line">        return c-&gt;logical_size;</span><br><span class="line">    else if ((whence == SEEK_CUR &amp;&amp; pos == 0) ||</span><br><span class="line">             (whence == SEEK_SET &amp;&amp; pos == c-&gt;logical_pos))</span><br><span class="line">        return c-&gt;logical_pos;</span><br><span class="line">    else if ((c-&gt;logical_size &lt; 0 &amp;&amp; whence == SEEK_END) || h-&gt;is_streamed)</span><br><span class="line">        return AVERROR(ENOSYS);</span><br><span class="line"></span><br><span class="line">    if (pos &lt;= c-&gt;logical_size) &#123;</span><br><span class="line">        c-&gt;logical_pos = pos;</span><br><span class="line">        ret = pos;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ret = AVERROR_EXIT;</span><br><span class="line">        goto fail;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">    fail:</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read就变成了从data直接读取数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static int ijkhttpseekhook_read(URLContext *h, unsigned char *buf, int size) &#123;</span><br><span class="line">    Context *c = h-&gt;priv_data;</span><br><span class="line">    int ret = size;</span><br><span class="line">    int remain = c-&gt;logical_size - c-&gt;logical_pos;</span><br><span class="line">    if (size &gt; remain) &#123;</span><br><span class="line">        ret = remain;</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(buf, c-&gt;data + c-&gt;logical_pos, ret);</span><br><span class="line">    c-&gt;logical_pos += ret;</span><br><span class="line">    fail:</span><br><span class="line">    if (ret &lt;= 0) &#123;</span><br><span class="line">        c-&gt;io_error = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="协议注册"><a href="#协议注册" class="headerlink" title="协议注册"></a>协议注册</h2><p>我使用IJK_REGISTER_PROTOCOL(ijkhttpseekhook);<br>却发现一直编译不通过，后面才知道这这种方法被ffmpeg禁止了，只能注册DEMUXER。之前弄过注册解码器，也是只能在ffmpeg里面注册。</p><p>使用ijkffmpeg的版本，在ijkutils.c和protocols.c添加好协议占位，然后就能跑通了。</p><h2 id="支持流动数据"><a href="#支持流动数据" class="headerlink" title="支持流动数据"></a>支持流动数据</h2><p>如果http协议是is_streamed，即为流动的，就不支持seek，获取到的logical_size为-1，用前面的代码就有问题。<br>其实用这种方案也可以改成支持seek版本，关键是初始化时数据大小动态增长就可以，我最新版本已经支持了is_streamed的seek，这里就不具体介绍了。</p><h2 id="方案总结"><a href="#方案总结" class="headerlink" title="方案总结"></a>方案总结</h2><p>ijkhttpseekhook实际就是http的内存缓存，适合于小请求，防止需要seek导致的多次请求问题。</p><h1 id="心路历程总结"><a href="#心路历程总结" class="headerlink" title="心路历程总结"></a>心路历程总结</h1><p>这次介绍整体很简单，实际上却是碰了很多次壁找到了办法，也不知道这种方案会不会有什么坑，我也是第一次弄ffmpeg协议相关的东西。<br>最开始我想到的办法实际是使用ijkplayer的iocache,但发现有两个问题，一个是缓存路径必须一一对应，如果同一个视频网络地址名称一直在变化，那就用不了了，另一个是当前这次请求如果没有缓存文件，那这次还是会请求多次。<br>然后就只能去看http协议流程，看了很久代码才看懂流程，其调用走的内部tcp协议，而且都是小块缓存读取数据。然后结合ijkplayer hook协议的流程确定了方案，剩下的实现就半天搞定了。</p>]]></content>
    
    <summary type="html">
    
      hook http协议进行内存缓存
    
    </summary>
    
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="ffmpeg" scheme="http://anddymao.com/tags/ffmpeg/"/>
    
      <category term="ijkplayer" scheme="http://anddymao.com/tags/ijkplayer/"/>
    
  </entry>
  
  <entry>
    <title>NDK MediaCodec解码采坑记录</title>
    <link href="http://anddymao.com/2020/12/21/2020-12-21-NDK%20MediaCodec%E8%A7%A3%E7%A0%81%E9%87%87%E5%9D%91/"/>
    <id>http://anddymao.com/2020/12/21/2020-12-21-NDK MediaCodec解码采坑/</id>
    <published>2020-12-21T06:00:00.000Z</published>
    <updated>2021-05-09T03:17:24.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Android硬件解码器坑是比较多的，看使用场景，我分享一些我遇到的坑，遇到基本很难直接找到解决方案，经过艰难的分析和寻找方案才找对解决办法。<br>这里作为记录和分享，遇到问题需要较真。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="获取视频宽高"><a href="#获取视频宽高" class="headerlink" title="获取视频宽高"></a>获取视频宽高</h2><p>获取视频大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AMediaFormat_getInt32(format, AMEDIAFORMAT_KEY_WIDTH, &amp;width);</span><br><span class="line">AMediaFormat_getInt32(format, AMEDIAFORMAT_KEY_HEIGHT, &amp;height);</span><br></pre></td></tr></table></figure><p>用这个值是视频原始大小，如果需要获取crop大小,即视频真正显示的大小，需要这样去获取。<br>java层：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (outformat.containsKey(<span class="string">"crop-left"</span>) &amp;&amp; outformat.containsKey(<span class="string">"crop-right"</span>)) &#123;</span><br><span class="line">    mVideoWidth = outformat.getInteger(<span class="string">"crop-right"</span>) + <span class="number">1</span> - outformat.getInteger(<span class="string">"crop-left"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (outformat.containsKey(<span class="string">"crop-top"</span>) &amp;&amp; outformat.containsKey(<span class="string">"crop-bottom"</span>)) &#123;</span><br><span class="line">    mVideoHeight = outformat.getInteger(<span class="string">"crop-bottom"</span>) + <span class="number">1</span> - outformat.getInteger(<span class="string">"crop-top"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>native：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AMediaFormat *format = AMediaCodec_getOutputFormat(decodeData-&gt;mCodec);</span><br><span class="line">const char *s = AMediaFormat_toString(format);</span><br><span class="line">std::string strFormat = s;</span><br><span class="line">int cropbegin = strFormat.find(&quot;crop&quot;);</span><br></pre></td></tr></table></figure></p><p>通过对应格式去获取crop大小，native下没有标准api可以直接获取，只能通过format去解析，麻烦很多。</p><h2 id="延时设置"><a href="#延时设置" class="headerlink" title="延时设置"></a>延时设置</h2><p>解码失败的问题。<br>AMediaCodec_dequeueInputBuffer和AMediaCodec_dequeueOutputBuffer需要等待缓冲队列，不设置延迟很容易失败，所以需要给一个timeout时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define AMC_INPUT_TIMEOUT_US  (100 * 1000)</span><br><span class="line">#define AMC_OUTPUT_TIMEOUT_US (100 * 1000)</span><br><span class="line"></span><br><span class="line">#define AMC_SYNC_INPUT_TIMEOUT_US  (30 * 1000)</span><br><span class="line">#define AMC_SYNC_OUTPUT_TIMEOUT_US (30 * 1000)</span><br></pre></td></tr></table></figure><p>这个是ijkplayer设置的异步和同步的timeout时间，分别是100ms和30ms，尽量保证能成功，这个可以根据实际情况进行调整。</p><p>如果数据不足会等待数据，我所用的场景新数据没到会等待一个timeout时间，感觉太慢，就在解码成功后把timeout时间设置一个较小的值。</p><h2 id="硬解失败自动切换软解"><a href="#硬解失败自动切换软解" class="headerlink" title="硬解失败自动切换软解"></a>硬解失败自动切换软解</h2><p>Android硬解对不同机型不同格式不能完全保证适配，就需要一个判断。我们先判断机型是否支持硬解，再选择解码器进行解码。<br>但这种情况下还是有可能硬解失败，就需要增加解码失败自动切换软解机制。</p><p>实现是在AMediaCodec_dequeueOutputBuffer返回值判断，如果返回错误，立马初始化软解解码器，后面的帧就直接切换软解进行解码。</p><h2 id="时间戳设置"><a href="#时间戳设置" class="headerlink" title="时间戳设置"></a>时间戳设置</h2><p>硬解的时间戳也不能随意设置，各个系统实现不一样，比如vivo就给我反馈通过时间戳计算动态帧率，给出的时间戳不对会导致帧率计算错误，错误太大甚至会导致程序卡死。</p><p>之前介绍过音视频参数，包括系统时基。和pts，dts等，这次自己就遇到这个坑了。</p><p>我遇到的问题，pts给的毫秒时间戳，时基是90000，我直接传pts会导致部分机型有问题。<br>正确的pts = 毫秒时间戳 / 1000 × 90000<br>pts = 时间 × 时基，必须经过这个换算才对。</p><p>另外pts不可小于0，部分手机会直接解码失败，ijkplayer对这个也有设置防范，pts小于0直接返回0。</p>]]></content>
    
    <summary type="html">
    
      使用NDK MediaCodec解码遇到的问题和解决方案
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>ijkPlayer深入探究(三)</title>
    <link href="http://anddymao.com/2020/10/19/2020-12-19-ijkPlayer%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6(%E4%B8%89)/"/>
    <id>http://anddymao.com/2020/10/19/2020-12-19-ijkPlayer深入探究(三)/</id>
    <published>2020-10-19T06:00:00.000Z</published>
    <updated>2021-05-09T02:50:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前面介绍了ijkplayer播放解码的流程还有音视频的参数，这篇从实际使用介绍如何自定义demuxer。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>ffmpeg有很多支持的protocol和demuxer，且支持自定义配置。ijkplayer又提供一套的protocol和demuxer的注册方式，可以不编译ffmpeg的情况下直接在ijkplayer里面添加。</p><p>看allformats.c，ijkav_register_all注册方法就能直接把所有自定义的protocol和demuxer注册进ffmpeg</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ijkav_register_all</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> initialized;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialized)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* protocols */</span></span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"===== custom modules begin =====\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ANDROID__</span></span><br><span class="line">    IJK_REGISTER_PROTOCOL(ijkmediadatasource);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    IJK_REGISTER_PROTOCOL(ijkio);</span><br><span class="line">    IJK_REGISTER_PROTOCOL(async);</span><br><span class="line">    IJK_REGISTER_PROTOCOL(ijklongurl);</span><br><span class="line">    IJK_REGISTER_PROTOCOL(ijktcphook);</span><br><span class="line">    IJK_REGISTER_PROTOCOL(ijkhttphook);</span><br><span class="line">    IJK_REGISTER_PROTOCOL(ijksegment);</span><br><span class="line">    <span class="comment">/* demuxers */</span></span><br><span class="line">    IJK_REGISTER_DEMUXER(ijklivehook);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"===== custom modules end =====\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现demuxer"><a href="#实现demuxer" class="headerlink" title="实现demuxer"></a>实现demuxer</h1><p>我们仿照ijkiourlhoock实现基本方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libavformat/avformat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libavformat/url.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libavutil/avstring.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libavutil/opt.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ijkplayer/ijkavutil/opt.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ijkavformat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libavutil/application.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    AVClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> app_ctx_intptr;</span><br><span class="line"></span><br><span class="line">    AVDictionary *opts;</span><br><span class="line">&#125; Context;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回0-AVPROBE_SCORE_MAX 之间，AVPROBE_SCORE_MAX表示最匹配就会使用此demuxer</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rtmj_probe</span><span class="params">(AVProbeData *probe)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (av_strstart(probe-&gt;filename, <span class="string">"customer:"</span>, <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> AVPROBE_SCORE_MAX;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rtmj_read_close</span><span class="params">(AVFormatContext *avf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> install libavformat/internal.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ff_alloc_extradata</span><span class="params">(AVCodecParameters *par, <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rtmj_read_header</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span> </span>&#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_INFO, <span class="string">"rtmj read head"</span>);</span><br><span class="line">    Context *s = ic-&gt;priv_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *param = ic-&gt;filename;</span><br><span class="line">   <span class="comment">//读取url</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//视频</span></span><br><span class="line">    AVStream *st;</span><br><span class="line">    st = avformat_new_stream(ic, <span class="literal">NULL</span>);</span><br><span class="line">    st-&gt;codecpar-&gt;codec_type = AVMEDIA_TYPE_VIDEO;</span><br><span class="line">    st-&gt;codecpar-&gt;codec_id = AV_CODEC_ID_H265;</span><br><span class="line">    st-&gt;codecpar-&gt;format = AV_PIX_FMT_YUV420P;</span><br><span class="line">    st-&gt;codecpar-&gt;profile = FF_PROFILE_H264_HIGH;</span><br><span class="line">    <span class="comment">//设置帧率</span></span><br><span class="line">    st-&gt;r_frame_rate.num = <span class="number">30</span>;</span><br><span class="line">    st-&gt;r_frame_rate.den = <span class="number">1</span>;</span><br><span class="line">    st-&gt;codecpar-&gt;width = <span class="number">640</span>;</span><br><span class="line">    st-&gt;codecpar-&gt;height = <span class="number">360</span>;</span><br><span class="line">    st-&gt;start_time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//音频</span></span><br><span class="line">      AVStream *audioST = avformat_new_stream(ic, <span class="literal">NULL</span>);</span><br><span class="line">      audioST-&gt;codecpar-&gt;codec_type = AVMEDIA_TYPE_AUDIO;</span><br><span class="line">      audioST-&gt;codecpar-&gt;codec_id = AV_CODEC_ID_PCM_ALAW;</span><br><span class="line">      audioST-&gt;codecpar-&gt;channels = channel;</span><br><span class="line">      audioST-&gt;codecpar-&gt;sample_rate = sampleRate;</span><br><span class="line">      audioST-&gt;codecpar-&gt;format = AV_SAMPLE_FMT_S16;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rtmj_read_packet</span><span class="params">(AVFormatContext *ic, AVPacket *pkt)</span> </span>&#123;</span><br><span class="line">    Context *s = ic-&gt;priv_data;</span><br><span class="line">    <span class="comment">//自定义获取数据方法 int ret = read_data(pkt);</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET(x) offsetof(Context, x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D AV_OPT_FLAG_DECODING_PARAM</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AVOption options[] = &#123;</span><br><span class="line">        &#123;<span class="string">"ijkapplication"</span>, <span class="string">"AVApplicationContext"</span>, OFFSET(app_ctx_intptr), AV_OPT_TYPE_INT64, &#123;.i64 = <span class="number">0</span>&#125;, INT64_MIN, INT64_MAX, .flags = D&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> D</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> OFFSET</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AVClass rtmj_class = &#123;</span><br><span class="line">        .class_name = <span class="string">"RTMJ demuxer"</span>,</span><br><span class="line">        .item_name  = av_default_item_name,</span><br><span class="line">        .option     = options,</span><br><span class="line">        .version    = LIBAVUTIL_VERSION_INT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AVInputFormat ijkff_rtmj_demuxer = &#123;</span><br><span class="line">        .name           = <span class="string">"rtmj"</span>,</span><br><span class="line">        .long_name      = <span class="string">"RTMJ Controller"</span>,</span><br><span class="line">        .flags          = AVFMT_NOFILE | AVFMT_TS_DISCONT,</span><br><span class="line">        .priv_data_size = <span class="keyword">sizeof</span>(Context),</span><br><span class="line">        .read_probe     = rtmj_probe,</span><br><span class="line">        .read_header2   = rtmj_read_header,</span><br><span class="line">        .read_packet    = rtmj_read_packet,</span><br><span class="line">        .read_close     = rtmj_read_close,</span><br><span class="line">        .priv_class     = &amp;rtmj_class,</span><br><span class="line">        .extensions     = <span class="string">"rtmj"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关键定义都在AVInputFormat结构体中，名称对应上就能注册进，然后实现对应方法即可。</p>]]></content>
    
    <summary type="html">
    
      ijkPlayer自定义demuxer（解封装器）
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="C" scheme="http://anddymao.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>zxing二维码扫描性能体验完全优化攻略</title>
    <link href="http://anddymao.com/2020/09/30/2020-9-30-zxing%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E6%8F%8F%E6%80%A7%E8%83%BD%E4%BD%93%E9%AA%8C%E5%AE%8C%E5%85%A8%E4%BC%98%E5%8C%96%E6%94%BB%E7%95%A5/"/>
    <id>http://anddymao.com/2020/09/30/2020-9-30-zxing二维码扫描性能体验完全优化攻略/</id>
    <published>2020-09-30T05:00:00.000Z</published>
    <updated>2020-09-30T08:23:02.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>zxing是使用最广泛二维码扫描库，提升体验是非常必要的，最近做了下优化，在实际使用发现了很多，给大家分享下</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="基础优化"><a href="#基础优化" class="headerlink" title="基础优化"></a>基础优化</h2><p>首先参照网上一些优化方法，主要是：<br><a href="https://toutiao.io/posts/d5buuo/preview" target="_blank" rel="noopener">https://toutiao.io/posts/d5buuo/preview</a><br><a href="https://www.jianshu.com/p/d10e147a2709" target="_blank" rel="noopener">https://www.jianshu.com/p/d10e147a2709</a></p><p>必须加的</p><ol><li>去除额外格式</li><li>减少解码数据 裁减无用区域</li><li>选择合适的相机preview size</li></ol><p>需要改造，作用比较小的</p><ol><li>将处理相机帧从串行改为并行</li></ol><p>有坑的：</p><ol><li>自动放大<br>检测到结果后再放大,那再进行的放大没有意义，除非自己增加判断二维码存在的算法</li><li>解码算法优化<br>原文：”使用GlobalHistogramBinarizer算法的效果要稍微比HybridBinarizer好一些，识别的速度更快。”<br>实际官方推荐的是HybridBinarizer，识别效果更好，解码处理的时间基本都是非常快的，瓶颈不在这里，</li></ol><p>必须项在项目中已经支持，然后尝试了其它，最后加上了处理并行发现实际优化极小。</p><h2 id="进一步探索"><a href="#进一步探索" class="headerlink" title="进一步探索"></a>进一步探索</h2><p>定位各个步骤所需时间,发现最大的耗时是相机的时间,解码的时间低端手机也只有几十毫秒,高端手机不到10ms。</p><p>二维码扫描体验做得最好的微信和支付宝，界面响应速度非常快，进入后过一瞬才会相机显示出来。而普通的二维码加载进行页面慢，然后会加动画。</p><p>所以这里我们可以做</p><ol><li>去除acitivty动画。<br>现在很多activity进入有个左移动画，对于二维码扫描页没有必要，参考微信支付宝都是直接加载的。</li><li>相机异步加载<br>相机可以异步先加载，然后进行显示，这样能加快一点打开时间</li></ol><p>这时从打开页面到扫描成功速度能从1200ms提升至1100ms左右</p><h2 id="深入改造"><a href="#深入改造" class="headerlink" title="深入改造"></a>深入改造</h2><p>加上异步打开相机后，相机打开后会有一次重新对焦的过程，经过调研发现是相机API1机制问题！<br>相机显示与解码对应了两路流，设置了两次回调setPreviewDisplay和setPreviewCallback。不加异步没问题是相机设置成功后再显示，这样就慢了。</p><p>想到解决方案有两种：</p><ol><li>使用API1，setPreviewCallback回调的yuv数据同时用于显示和解码,这样就需要自己做yuv数据处理和渲染，使用opengl可以解决</li><li>使用API2，相机底层机制解决了这些问题，但对于APP需要兼容5.0以下使用API1</li></ol><p>不能被过去束缚，要拥抱新的东西，也为了整体逻辑更轻松，为来更易维护，最终决定使用方法2，整体重写zxing的相机逻辑。<br>增加相机接口，做API1和AP2的两套实现，保留解码部分逻辑，具体就不介绍了。</p><p>做了开关控制API1切换，最终的效果还挺好,整体时间提升至700-800ms范围，没有再次对焦的问题。</p><h2 id="结果数据"><a href="#结果数据" class="headerlink" title="结果数据"></a>结果数据</h2><p>打印了快如闪点demo里面的时间作为对比,从onCreate到扫描成功，在1100-1200的范围内<br>2020-08-31 18:45:02.250 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: onCreate<br>2020-08-31 18:45:03.290 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: scanResult time:1067<br>2020-08-31 18:45:03.860 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: onCreate<br>2020-08-31 18:45:05.070 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: scanResult time:1226<br>2020-08-31 18:45:05.710 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: onCreate<br>2020-08-31 18:45:06.883 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: scanResult time:1189<br>2020-08-31 18:45:07.421 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: onCreate<br>2020-08-31 18:45:08.599 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: scanResult time:1192<br>2020-08-31 18:45:09.009 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: onCreate<br>2020-08-31 18:45:10.213 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: scanResult time:1220<br>2020-08-31 18:45:10.774 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: onCreate<br>2020-08-31 18:45:11.937 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: scanResult time:1179<br>2020-08-31 18:45:12.494 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: onCreate<br>2020-08-31 18:45:13.616 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: scanResult time:1137<br>2020-08-31 18:45:14.182 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: onCreate<br>2020-08-31 18:45:15.329 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: scanResult time:1161<br>2020-08-31 18:45:15.913 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: onCreate<br>2020-08-31 18:45:17.065 4350-4350/com.zhouk.qrzxingscan D/QRScanActivity1: scanResult time:1165</p><p>我优化后自测小米10 pro时间：</p><p>使用API1：<br>2020-08-25 14:31:57.803 13916-13916/com.xiaomi.smarthome D/ScanBarcodeActivity: decode time from create:1190<br>2020-08-25 14:31:59.868 13916-13916/com.xiaomi.smarthome D/ScanBarcodeActivity: decode time from create:1200<br>2020-08-25 14:32:01.964 13916-13916/com.xiaomi.smarthome D/ScanBarcodeActivity: decode time from create:1218<br>2020-08-25 14:32:03.828 13916-13916/com.xiaomi.smarthome D/ScanBarcodeActivity: decode time from create:1118<br>2020-08-25 14:32:05.769 13916-13916/com.xiaomi.smarthome D/ScanBarcodeActivity: decode time from create:1184<br>2020-08-25 14:32:08.025 13916-13916/com.xiaomi.smarthome D/ScanBarcodeActivity: decode time from create:1187<br>2020-08-25 14:32:09.915 13916-13916/com.xiaomi.smarthome D/ScanBarcodeActivity: decode time from create:1180<br>2020-08-25 14:32:11.791 13916-13916/com.xiaomi.smarthome D/ScanBarcodeActivity: decode time from create:1194</p><p>使用API2：<br>2020-08-25 14:32:28.475 13916-13916/com.xiaomi.smarthome D/ScanBarcodeActivity: decode time from create:809<br>2020-08-25 14:32:31.822 13916-13916/com.xiaomi.smarthome D/ScanBarcodeActivity: decode time from create:702<br>2020-08-25 14:32:33.890 13916-13916/com.xiaomi.smarthome D/ScanBarcodeActivity: decode time from create:682<br>2020-08-25 14:32:35.372 13916-13916/com.xiaomi.smarthome D/ScanBarcodeActivity: decode time from create:777<br>2020-08-25 14:32:36.702 13916-13916/com.xiaomi.smarthome D/ScanBarcodeActivity: decode time from create:752<br>2020-08-25 14:32:37.954 13916-13916/com.xiaomi.smarthome D/ScanBarcodeActivity: decode time from create:693<br>2020-08-25 14:32:39.354 13916-13916/com.xiaomi.smarthome D/ScanBarcodeActivity: decode time from create:793<br>2020-08-25 14:32:40.688 13916-13916/com.xiaomi.smarthome D/ScanBarcodeActivity: decode time from create:793</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整体优化测试手机是小米10Pro，特点是四摄相机较重，处理速度快，不同手机上会有些差别。<br>具体解决问题不难，难在分析和找问题，再次对焦的问题就找了两天。然后要看实际结果数据分析，根据实际情况选用方案。具体编码都是次要的了。</p>]]></content>
    
    <summary type="html">
    
      使用相机API2达到最快的二维码扫描速度
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="Camera" scheme="http://anddymao.com/tags/Camera/"/>
    
  </entry>
  
  <entry>
    <title>音视频参数介绍与ffmpeg中的使用</title>
    <link href="http://anddymao.com/2020/06/26/2020-6-26-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D%E4%B8%8Effmpeg%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://anddymao.com/2020/06/26/2020-6-26-音视频参数介绍与ffmpeg中的使用/</id>
    <published>2020-06-26T06:00:00.000Z</published>
    <updated>2020-08-17T13:23:17.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="格式介绍"><a href="#格式介绍" class="headerlink" title="格式介绍"></a>格式介绍</h2><p>一个音视频文件整体在一个封装包里，比如我们熟悉的MP4，AVI,rmvb等等。<br>封装的音视频文件下面会包含多个轨道，每个轨道对应一个流，这些音视频流都由原始数据编码而成，下面介绍下音视频编码的参数。</p><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><ol><li><p>编码格式<br>目前的主流是h.264和h.265(hevc)，h264基本android硬解都支持，h265需分机型判断。判断是否支持也需要带宽高大小，不同机型的支持度不一样。android硬解从开始的非常不稳定到现在的主流，<br>但支持度相对于软解还是差些，所以很多播放器都提供手动或者自动的切换软解和硬解。</p></li><li><p>帧率（frame_rate）<br>测量单位为每秒显示帧数(Frames per Second，简称：FPS），android手机刷新帧率为60，现在也有手机出到90帧甚至120帧。更高的帧率等于更高的流畅度,<br>但对硬件的要求也就越高，越高的帧率人眼的感知差别就越不明显了。</p></li><li><p>DTS和PTS<br>DTS(Decoding Time Stamp) : 即解码时间戳，是解码器进行解码时相对于SCR(系统参考时间)的时间戳。它主要标识读入内存的bit流在什么时候开始送入解码器中进行解码。<br>PTS(Presentation Time Stamp) : 即显示时间戳<br>如果没有B帧的话DTS和PTS是一致的，B帧解码依赖前后的帧。</p></li><li><p>系统时基（time_base）<br>多少数字表示1S。视频的时间戳是基于系统时间的，所以需要一个时基。比如time_base为90000。通过时基转换可以得到真正时间。<br>时间戳（毫秒） =  PTS / time_base * 1000 。<br>视频长度time(秒) = st-&gt;duration / time_base 。</p></li><li><p>码率<br>每秒传输的数据量。这个和编码格式，帧率还有视频宽高相关。还和原始视频相关，信息量小的视频和信息量大的视频差异大，就比如公开课这种变化小的视频码率就比较小，动作电影码率就比较大。在手机端做视频录制需要根据视频宽高设置一个推荐值。</p></li></ol><h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><ol><li><p>采样率（sample_rate）<br>每秒采集数据的次数,例如8K即一秒有8000次采样。音频时间戳直接以采样率为时基</p></li><li><p>采样精度 dataBits<br>每次采集数据的位数，例如PCM_16，即一次采样用16位比特位(bit)存储</p></li><li><p>通道数 channel<br>存在几路音频，例如单通道，双通道等</p></li><li><p>比特率 bitrate<br>针对编码格式，表示压缩编码后每秒的音频数据量大小。<br>对于未压缩的音频格式，比特率就等于采样率值×采样精度值×声道数</p></li></ol><h2 id="FFmpeg中音视频流参数定义与使用"><a href="#FFmpeg中音视频流参数定义与使用" class="headerlink" title="FFmpeg中音视频流参数定义与使用"></a>FFmpeg中音视频流参数定义与使用</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>音视频流参数设置在AVCodecParameters结构体中，各种信息都在其中，且有详细解释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This struct describes the properties of an encoded stream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sizeof(AVCodecParameters) is not a part of the public ABI, this struct must</span></span><br><span class="line"><span class="comment"> * be allocated with avcodec_parameters_alloc() and freed with</span></span><br><span class="line"><span class="comment"> * avcodec_parameters_free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVCodecParameters</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * General type of the encoded data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> AVMediaType codec_type;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Specific type of the encoded data (the codec used).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID   codec_id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Additional information about the codec (corresponds to the AVI FOURCC).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>         codec_tag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Extra binary data needed for initializing the decoder, codec-dependent.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Must be allocated with av_malloc() and will be freed by</span></span><br><span class="line"><span class="comment">     * avcodec_parameters_free(). The allocated size of extradata must be at</span></span><br><span class="line"><span class="comment">     * least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding</span></span><br><span class="line"><span class="comment">     * bytes zeroed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *extradata;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Size of the extradata content in bytes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>      extradata_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * - video: the pixel format, the value corresponds to enum AVPixelFormat.</span></span><br><span class="line"><span class="comment">     * - audio: the sample format, the value corresponds to enum AVSampleFormat.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> format;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The average bitrate of the encoded data (in bits per second).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> bit_rate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of bits per sample in the codedwords.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This is basically the bitrate per sample. It is mandatory for a bunch of</span></span><br><span class="line"><span class="comment">     * formats to actually decode them. It's the number of bits for one sample in</span></span><br><span class="line"><span class="comment">     * the actual coded bitstream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This could be for example 4 for ADPCM</span></span><br><span class="line"><span class="comment">     * For PCM formats this matches bits_per_raw_sample</span></span><br><span class="line"><span class="comment">     * Can be 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> bits_per_coded_sample;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is the number of valid bits in each output sample. If the</span></span><br><span class="line"><span class="comment">     * sample format has more bits, the least significant bits are additional</span></span><br><span class="line"><span class="comment">     * padding bits, which are always 0. Use right shifts to reduce the sample</span></span><br><span class="line"><span class="comment">     * to its actual size. For example, audio formats with 24 bit samples will</span></span><br><span class="line"><span class="comment">     * have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.</span></span><br><span class="line"><span class="comment">     * To get the original sample use "(int32_t)sample &gt;&gt; 8"."</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For ADPCM this might be 12 or 16 or similar</span></span><br><span class="line"><span class="comment">     * Can be 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> bits_per_raw_sample;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Codec-specific bitstream restrictions that the stream conforms to.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> profile;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Video only. The dimensions of the video frame in pixels.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Video only. The aspect ratio (width / height) which a single pixel</span></span><br><span class="line"><span class="comment">     * should have when displayed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When the aspect ratio is unknown / undefined, the numerator should be</span></span><br><span class="line"><span class="comment">     * set to 0 (the denominator may have any value).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVRational sample_aspect_ratio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Video only. The order of the fields in interlaced video.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> AVFieldOrder                  field_order;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Video only. Additional colorspace characteristics.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> AVColorRange                  color_range;</span><br><span class="line">    <span class="keyword">enum</span> AVColorPrimaries              color_primaries;</span><br><span class="line">    <span class="keyword">enum</span> AVColorTransferCharacteristic color_trc;</span><br><span class="line">    <span class="keyword">enum</span> AVColorSpace                  color_space;</span><br><span class="line">    <span class="keyword">enum</span> AVChromaLocation              chroma_location;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Video only. Number of delayed frames.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> video_delay;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Audio only. The channel layout bitmask. May be 0 if the channel layout is</span></span><br><span class="line"><span class="comment">     * unknown or unspecified, otherwise the number of bits set must be equal to</span></span><br><span class="line"><span class="comment">     * the channels field.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> channel_layout;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Audio only. The number of audio channels.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>      channels;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Audio only. The number of audio samples per second.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>      sample_rate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Audio only. The number of bytes per coded audio frame, required by some</span></span><br><span class="line"><span class="comment">     * formats.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Corresponds to nBlockAlign in WAVEFORMATEX.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>      block_align;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Audio only. Audio frame size, if known. Required by some formats to be static.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>      frame_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Audio only. The amount of padding (in samples) inserted by the encoder at</span></span><br><span class="line"><span class="comment">     * the beginning of the audio. I.e. this number of leading decoded samples</span></span><br><span class="line"><span class="comment">     * must be discarded by the caller to get the original audio without leading</span></span><br><span class="line"><span class="comment">     * padding.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> initial_padding;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Audio only. The amount of padding (in samples) appended by the encoder to</span></span><br><span class="line"><span class="comment">     * the end of the audio. I.e. this number of decoded samples must be</span></span><br><span class="line"><span class="comment">     * discarded by the caller from the end of the stream to get the original</span></span><br><span class="line"><span class="comment">     * audio without any trailing padding.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> trailing_padding;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Audio only. Number of samples to skip after a discontinuity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> seek_preroll;</span><br><span class="line">&#125; AVCodecParameters;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>需要新建的话用avformat_new_stream创建一个新的流，然后设置其codecpar参数就可，下面是我自定义格式的设置例子，可以根据实际需要具体设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//视频</span></span><br><span class="line">AVStream *st;</span><br><span class="line">st = avformat_new_stream(ic, <span class="literal">NULL</span>);</span><br><span class="line">st-&gt;codecpar-&gt;codec_type = AVMEDIA_TYPE_VIDEO;</span><br><span class="line">st-&gt;codecpar-&gt;codec_id = AV_CODEC_ID_H264;</span><br><span class="line">st-&gt;codecpar-&gt;format = AV_PIX_FMT_YUV420P;</span><br><span class="line">st-&gt;codecpar-&gt;profile = FF_PROFILE_H264_HIGH;</span><br><span class="line">st-&gt;r_frame_rate.num = <span class="number">0</span>;</span><br><span class="line">st-&gt;r_frame_rate.den = <span class="number">1</span>;</span><br><span class="line">st-&gt;codecpar-&gt;width = <span class="number">640</span>;</span><br><span class="line">st-&gt;codecpar-&gt;height = <span class="number">360</span>;</span><br><span class="line">AVRational fps = &#123;<span class="number">30</span>, <span class="number">1</span>&#125;;</span><br><span class="line">st-&gt;avg_frame_rate = fps;</span><br><span class="line">st-&gt;start_time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//音频</span></span><br><span class="line">AVStream *audioST = avformat_new_stream(ic, <span class="literal">NULL</span>);</span><br><span class="line">audioST-&gt;codecpar-&gt;codec_type = AVMEDIA_TYPE_AUDIO;</span><br><span class="line">audioST-&gt;codecpar-&gt;codec_id = AV_CODEC_ID_PCM_ALAW;</span><br><span class="line">audioST-&gt;codecpar-&gt;channels = channel;</span><br><span class="line">audioST-&gt;codecpar-&gt;sample_rate = sampleRate;</span><br><span class="line">audioST-&gt;codecpar-&gt;format = AV_SAMPLE_FMT_S16;</span><br></pre></td></tr></table></figure><h2 id="时间计算"><a href="#时间计算" class="headerlink" title="时间计算"></a>时间计算</h2><p>视频需要帧率计算时间，比如60fps，那这样每一帧的时间就是1000/60=16ms。</p><p>音频的话就不需要帧的概念，直接根据参数就可以计算了。<br>假设每帧原始数据有1024个采样点，dataBits为8bit即1byte，单通道。<br>那在采样率为8000时，每帧时长（毫秒数） = 1024 / 8000 <em> 1000 = 128ms<br>时间戳就是128的等差连续数列。<br>每帧原始数据大小 =  1024 </em> 1 byte * 1 = 1024 byte。</p>]]></content>
    
    <summary type="html">
    
      ffmpeg中如何创建流
    
    </summary>
    
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>ijkPlayer深入探究(二)</title>
    <link href="http://anddymao.com/2020/06/25/2020-6-25-ijkPlayer%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6(%E4%BA%8C)/"/>
    <id>http://anddymao.com/2020/06/25/2020-6-25-ijkPlayer深入探究(二)/</id>
    <published>2020-06-25T06:00:00.000Z</published>
    <updated>2020-08-17T13:23:17.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇从上到下分析了ijkplayer解码的流程，最后用到SDL。<br>SDL是Simple DirectMedia Layer，提供简单的方式支持跨平台访问输出库，ijksdl思路是和SDL一样的，ijksdl用于音视频渲染输出。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>我们先看IjkMediaPlayer创建的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IjkMediaPlayer *ijkmp_android_create(int(*msg_loop)(void*))</span><br><span class="line">&#123;</span><br><span class="line">    IjkMediaPlayer *mp = ijkmp_create(msg_loop);</span><br><span class="line">    if (!mp)</span><br><span class="line">        goto fail;</span><br><span class="line"></span><br><span class="line">    mp-&gt;ffplayer-&gt;vout = SDL_VoutAndroid_CreateForAndroidSurface();</span><br><span class="line">    if (!mp-&gt;ffplayer-&gt;vout)</span><br><span class="line">        goto fail;</span><br><span class="line"></span><br><span class="line">    mp-&gt;ffplayer-&gt;pipeline = ffpipeline_create_from_android(mp-&gt;ffplayer);</span><br><span class="line">    if (!mp-&gt;ffplayer-&gt;pipeline)</span><br><span class="line">        goto fail;</span><br><span class="line"></span><br><span class="line">    ffpipeline_set_vout(mp-&gt;ffplayer-&gt;pipeline, mp-&gt;ffplayer-&gt;vout);</span><br><span class="line"></span><br><span class="line">    return mp;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    ijkmp_dec_ref_p(&amp;mp);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建IjkMediaPlayer后，又创建了一个vout(视频显示用的结构体)和pipeline(管线， 解码用的结构体)</p><p>这样使用统一接口，便于跨平台扩展。</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>vout是SDL_Vout的结构体，用于显示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SDL_Vout</span> &#123;</span></span><br><span class="line">    SDL_mutex *mutex;</span><br><span class="line"></span><br><span class="line">    SDL_Class       *opaque_class;</span><br><span class="line">    SDL_Vout_Opaque *opaque;</span><br><span class="line">    SDL_VoutOverlay *(*create_overlay)(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> frame_format, SDL_Vout *vout);</span><br><span class="line">    <span class="keyword">void</span> (*free_l)(SDL_Vout *vout);</span><br><span class="line">    <span class="keyword">int</span> (*display_overlay)(SDL_Vout *vout, SDL_VoutOverlay *overlay);</span><br><span class="line"></span><br><span class="line">    Uint32 overlay_format;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>pipeline是IJKFF_Pipeline的结构体:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IJKFF_Pipeline</span> &#123;</span></span><br><span class="line">    SDL_Class             *opaque_class;</span><br><span class="line">    IJKFF_Pipeline_Opaque *opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>            (*func_destroy)             (IJKFF_Pipeline *pipeline);</span><br><span class="line">    IJKFF_Pipenode *(*func_open_video_decoder)  (IJKFF_Pipeline *pipeline, FFPlayer *ffp);</span><br><span class="line">    SDL_Aout       *(*func_open_audio_output)   (IJKFF_Pipeline *pipeline, FFPlayer *ffp);</span><br><span class="line">    IJKFF_Pipenode *(*func_init_video_decoder)  (IJKFF_Pipeline *pipeline, FFPlayer *ffp);</span><br><span class="line">    <span class="keyword">int</span>           (*func_config_video_decoder)  (IJKFF_Pipeline *pipeline, FFPlayer *ffp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>管线中有管道节点IJKFF_Pipenode，即解码器:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IJKFF_Pipenode</span> &#123;</span></span><br><span class="line">    SDL_mutex *mutex;</span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*func_destroy) (IJKFF_Pipenode *node);</span><br><span class="line">    <span class="keyword">int</span>  (*func_run_sync)(IJKFF_Pipenode *node);</span><br><span class="line">    <span class="keyword">int</span>  (*func_flush)   (IJKFF_Pipenode *node); <span class="comment">// optional</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>IJKFF_Pipenode里有黑盒opaque,对应结构体IJKFF_Pipenode_Opaque，具体实现都在这个黑盒里，外面不用关心具体实现，只需要关注输入输出，但我们还是打开具体看看:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct IJKFF_Pipenode_Opaque &#123;</span><br><span class="line">       FFPlayer                 *ffp;</span><br><span class="line">       IJKFF_Pipeline           *pipeline;</span><br><span class="line">       Decoder                  *decoder;</span><br><span class="line">       SDL_Vout                 *weak_vout;</span><br><span class="line"></span><br><span class="line">       ijkmp_mediacodecinfo_context mcc;</span><br><span class="line"></span><br><span class="line">       jobject                   jsurface;</span><br><span class="line">       SDL_AMediaFormat         *input_aformat;</span><br><span class="line">       SDL_AMediaCodec          *acodec;</span><br><span class="line">       SDL_AMediaFormat         *output_aformat;</span><br><span class="line">       char                      acodec_name[128];</span><br><span class="line">       int                       frame_width;</span><br><span class="line">       int                       frame_height;</span><br><span class="line">       int                       frame_rotate_degrees;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">   &#125; IJKFF_Pipenode_Opaque;</span><br></pre></td></tr></table></figure><p>IJKFF_Pipenode_Opaque里对应AMedia对应的SDL封装结构体，SDL_AMediaFormat，SDL_AMediaCodec，SDL_AMediaFormat</p><h3 id="解码流程"><a href="#解码流程" class="headerlink" title="解码流程"></a>解码流程</h3><p>结合上一篇根据结构体调用分析解码流程：</p><ol><li>初始化完成后得到IJKFF_Pipeline和IJKFF_Pipenode，还有输出结构体SDL_Vout</li><li>启动管道节点IJKFF_Pipenode的func_run_sync方法执行解码流程</li><li>黑盒IJKFF_Pipenode_Opaque，调用SDL方法如SDL_AMediaCodec_dequeueInputBuffer(opaque-&gt;acodec)进行解码</li><li>SDL_VoutAndroid_releaseBufferProxyP方法传入SDL_Vout和IJKFF_Pipenode_Opaque进行输出</li></ol><h3 id="SDL方法调用流程"><a href="#SDL方法调用流程" class="headerlink" title="SDL方法调用流程"></a>SDL方法调用流程</h3><p>我们以SDL_AMediaCodec_dequeueInputBuffer看SDL方法调用流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> SDL_AMediaCodec_dequeueInputBuffer(SDL_AMediaCodec* acodec, <span class="keyword">int64_t</span> timeoutUs)</span><br><span class="line">&#123;</span><br><span class="line">    assert(acodec-&gt;func_dequeueInputBuffer);</span><br><span class="line">    <span class="keyword">return</span> acodec-&gt;func_dequeueInputBuffer(acodec, timeoutUs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SDL_AMediaCodec等于是一个抽象接口，看其如何创建的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> SDL_AMediaCodec *<span class="title">create_codec_l</span><span class="params">(JNIEnv *env, IJKFF_Pipenode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IJKFF_Pipenode_Opaque        *opaque   = node-&gt;opaque;</span><br><span class="line">    ijkmp_mediacodecinfo_context *mcc      = &amp;opaque-&gt;mcc;</span><br><span class="line">    SDL_AMediaCodec              *acodec   = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (opaque-&gt;jsurface == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// we don't need real codec if we don't have a surface</span></span><br><span class="line">        acodec = SDL_AMediaCodecDummy_create();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        acodec = SDL_AMediaCodecJava_createByCodecName(env, mcc-&gt;codec_name);</span><br><span class="line">        <span class="keyword">if</span> (acodec) &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(opaque-&gt;acodec_name, mcc-&gt;codec_name, <span class="keyword">sizeof</span>(opaque-&gt;acodec_name) / <span class="keyword">sizeof</span>(*opaque-&gt;acodec_name));</span><br><span class="line">            opaque-&gt;acodec_name[<span class="keyword">sizeof</span>(opaque-&gt;acodec_name) / <span class="keyword">sizeof</span>(*opaque-&gt;acodec_name) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">if</span> (!acodec)</span><br><span class="line">        acodec = SDL_AMediaCodecJava_createDecoderByType(env, mcc-&gt;mime_type);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acodec) &#123;</span><br><span class="line">        <span class="comment">// QUIRK: always recreate MediaCodec for reconfigure</span></span><br><span class="line">        opaque-&gt;quirk_reconfigure_with_new_codec = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">/*-</span></span><br><span class="line"><span class="comment">        if (0 == strncasecmp(mcc-&gt;codec_name, "OMX.TI.DUCATI1.", 15)) &#123;</span></span><br><span class="line"><span class="comment">            opaque-&gt;quirk_reconfigure_with_new_codec = true;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/* delaying output makes it possible to correct frame order, hopefully */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == strncasecmp(mcc-&gt;codec_name, <span class="string">"OMX.TI.DUCATI1."</span>, <span class="number">15</span>)) &#123;</span><br><span class="line">            <span class="comment">/* this is the only acceptable value on Nexus S */</span></span><br><span class="line">            opaque-&gt;n_buf_out = <span class="number">1</span>;</span><br><span class="line">            ALOGD(<span class="string">"using buffered output for %s"</span>, mcc-&gt;codec_name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (opaque-&gt;frame_rotate_degrees == <span class="number">90</span> || opaque-&gt;frame_rotate_degrees == <span class="number">270</span>) &#123;</span><br><span class="line">        opaque-&gt;frame_width  = opaque-&gt;codecpar-&gt;height;</span><br><span class="line">        opaque-&gt;frame_height = opaque-&gt;codecpar-&gt;width;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        opaque-&gt;frame_width  = opaque-&gt;codecpar-&gt;width;</span><br><span class="line">        opaque-&gt;frame_height = opaque-&gt;codecpar-&gt;height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> acodec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两种初始化方法SDL_AMediaCodecDummy_create和SDL_AMediaCodecJava_createByCodecName，SDL_AMediaCodecDummy_create是一个傀儡实现，用于容错的。<br>看SDL_AMediaCodecJava_createByCodecName方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> SDL_AMediaCodec* <span class="title">SDL_AMediaCodecJava_init</span><span class="params">(JNIEnv *env, jobject android_media_codec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SDLTRACE(<span class="string">"%s"</span>, __func__);</span><br><span class="line"></span><br><span class="line">    jobject global_android_media_codec = (*env)-&gt;NewGlobalRef(env, android_media_codec);</span><br><span class="line">    <span class="keyword">if</span> (J4A_ExceptionCheck__catchAll(env) || !global_android_media_codec) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_AMediaCodec *acodec = SDL_AMediaCodec_CreateInternal(<span class="keyword">sizeof</span>(SDL_AMediaCodec_Opaque));</span><br><span class="line">    <span class="keyword">if</span> (!acodec) &#123;</span><br><span class="line">        SDL_JNI_DeleteGlobalRefP(env, &amp;global_android_media_codec);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_AMediaCodec_Opaque *opaque = acodec-&gt;opaque;</span><br><span class="line">    opaque-&gt;android_media_codec         = global_android_media_codec;</span><br><span class="line"></span><br><span class="line">    acodec-&gt;opaque_class                = &amp;g_amediacodec_class;</span><br><span class="line">    acodec-&gt;func_delete                 = SDL_AMediaCodecJava_delete;</span><br><span class="line">    acodec-&gt;func_configure              = <span class="literal">NULL</span>;</span><br><span class="line">    acodec-&gt;func_configure_surface      = SDL_AMediaCodecJava_configure_surface;</span><br><span class="line"></span><br><span class="line">    acodec-&gt;func_start                  = SDL_AMediaCodecJava_start;</span><br><span class="line">    acodec-&gt;func_stop                   = SDL_AMediaCodecJava_stop;</span><br><span class="line">    acodec-&gt;func_flush                  = SDL_AMediaCodecJava_flush;</span><br><span class="line"></span><br><span class="line">    acodec-&gt;func_writeInputData         = SDL_AMediaCodecJava_writeInputData;</span><br><span class="line"></span><br><span class="line">    acodec-&gt;func_dequeueInputBuffer     = SDL_AMediaCodecJava_dequeueInputBuffer;</span><br><span class="line">    acodec-&gt;func_queueInputBuffer       = SDL_AMediaCodecJava_queueInputBuffer;</span><br><span class="line"></span><br><span class="line">    acodec-&gt;func_dequeueOutputBuffer    = SDL_AMediaCodecJava_dequeueOutputBuffer;</span><br><span class="line">    acodec-&gt;func_getOutputFormat        = SDL_AMediaCodecJava_getOutputFormat;</span><br><span class="line">    acodec-&gt;func_releaseOutputBuffer    = SDL_AMediaCodecJava_releaseOutputBuffer;</span><br><span class="line"></span><br><span class="line">    acodec-&gt;func_isInputBuffersValid    = SDL_AMediaCodecJava_isInputBuffersValid;</span><br><span class="line"></span><br><span class="line">    SDL_AMediaCodec_increaseReference(acodec);</span><br><span class="line">    <span class="keyword">return</span> acodec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SDL_AMediaCodec* <span class="title">SDL_AMediaCodecJava_createByCodecName</span><span class="params">(JNIEnv *env, <span class="keyword">const</span> <span class="keyword">char</span> *codec_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SDLTRACE(<span class="string">"%s"</span>, __func__);</span><br><span class="line"></span><br><span class="line">    jobject android_media_codec = J4AC_MediaCodec__createByCodecName__withCString__catchAll(env, codec_name); <span class="comment">//j4a方法创建解码器</span></span><br><span class="line">    <span class="keyword">if</span> (J4A_ExceptionCheck__catchAll(env) || !android_media_codec) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_AMediaCodec* acodec = SDL_AMediaCodecJava_init(env, android_media_codec);</span><br><span class="line">    acodec-&gt;object_serial = SDL_AMediaCodec_create_object_serial();</span><br><span class="line">    SDL_JNI_DeleteLocalRefP(env, &amp;android_media_codec);</span><br><span class="line">    <span class="keyword">return</span> acodec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>J4AC_MediaCodec__createByCodecName__withCString__catchAll用的是jni4android调用，其实就是正常的jni调用java方法，bilibili写了一个插件可以自动生成对应方法，手动写jni调用java太长了<br>想了解可以看项目主页： <a href="https://github.com/bilibili/jni4android" target="_blank" rel="noopener">https://github.com/bilibili/jni4android</a></p><p>创建解码器后，初始化了SDL_AMediaCodec的结构体,赋值了对应方法，继续看SDL_AMediaCodecJava_dequeueInputBuffer方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> SDL_AMediaCodecJava_dequeueInputBuffer(SDL_AMediaCodec* acodec, <span class="keyword">int64_t</span> timeoutUs)</span><br><span class="line">&#123;</span><br><span class="line">    AMCTRACE(<span class="string">"%s(%d)"</span>, __func__, (<span class="keyword">int</span>)timeoutUs);</span><br><span class="line"></span><br><span class="line">    JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (JNI_OK != SDL_JNI_SetupThreadEnv(&amp;env)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: SetupThreadEnv failed"</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_AMediaCodec_Opaque *opaque = (SDL_AMediaCodec_Opaque *)acodec-&gt;opaque;</span><br><span class="line">    <span class="comment">// docs lie, getInputBuffers should be good after</span></span><br><span class="line">    <span class="comment">// m_codec-&gt;start() but the internal refs are not</span></span><br><span class="line">    <span class="comment">// setup until much later on some devices.</span></span><br><span class="line">    <span class="comment">//if (-1 == getInputBuffers(env, acodec)) &#123;</span></span><br><span class="line">    <span class="comment">//    ALOGE("%s: getInputBuffers failed", __func__);</span></span><br><span class="line">    <span class="comment">//    return -1;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    jobject android_media_codec = opaque-&gt;android_media_codec;</span><br><span class="line">    jint idx = J4AC_MediaCodec__dequeueInputBuffer(env, android_media_codec, (jlong)timeoutUs);</span><br><span class="line">    <span class="keyword">if</span> (J4A_ExceptionCheck__catchAll(env)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: dequeueInputBuffer failed"</span>, __func__);</span><br><span class="line">        opaque-&gt;is_input_buffer_valid = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也是调用到j4a方法J4AC_MediaCodec__dequeueInputBuffer，这就是最终解码的实现方法了，通过j4a调用到java的MediaCodec对应方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分析了ijksdk的方法调用过程，通过跨平台接口调用，在android上还是走到了Java层MediaCodec方法中。</p>]]></content>
    
    <summary type="html">
    
      ijkSDL深入解析:Android硬解流程分析
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="C" scheme="http://anddymao.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>ijkPlayer深入探究(一)</title>
    <link href="http://anddymao.com/2020/02/27/2020-2-27-ijkPlayer%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6(%E4%B8%80)/"/>
    <id>http://anddymao.com/2020/02/27/2020-2-27-ijkPlayer深入探究(一)/</id>
    <published>2020-02-27T06:00:00.000Z</published>
    <updated>2020-02-28T01:39:34.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ijkPlayer是开源做得最好的播放器，使用LGPL协议，非常适合播放器使用，也支持二次开发。<br>综合很多方案后，在项目中选用了ijkPlayer。ijkPlayer虽然使用广泛，人气非常高，核心代码解析也有不少，<br>但少有细节清楚的，还是得依靠源码。</p><p>所以接下来我会基于使用，来分享一些ijkPlayer中的知识点。<br>第一篇分析ijkPlayer的Android硬件解码流程。</p><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><p>ijkplayer可以通过option设置做出很多更改，mediacodec解码部分就有以下这些配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, <span class="string">"mediacodec"</span>, <span class="number">1</span>);<span class="comment">//开启硬解码</span></span><br><span class="line">ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, <span class="string">"mediacodec-auto-rotate"</span>, value);</span><br><span class="line">ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, <span class="string">"mediacodec-handle-resolution-change"</span>, value);</span><br><span class="line"></span><br><span class="line">ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, <span class="string">"mediacodec-hevc"</span>, <span class="number">1</span>);</span><br><span class="line">ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, <span class="string">"mediacodec-sync"</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>为1时开启，为0时关闭。这些值默认都是关闭。官方demo里面有前三个。<br>“mediacodec”为是否开启硬解，<br>“mediacodec-auto-rotate”为是否自动旋转，<br>“mediacodec-handle-resolution-change”为是否自动分辨率更改，<br>“mediacodec-hevc”为是否支持h265,这个值要开启才能走h265的硬解，还有其它的格式配置没有列举。如果格式不支持就会硬解初始化不成功，转用软件解码。<br>“mediacodec-sync”为是否同步解码，异步效率更高。</p><p>这里配置名称要非常注意，java中写法都是”-“，而c代码中的配置都是”_”。比如mediacodec-hevc在源码中是mediacodec_hevc。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>分析源码首先是找到调用流程，把握整体脉络，再去细节上体会原理。<br>可以入口开始分析，也可以从出口分析。入口就是整体的启动，出口就是关键节点方法，比如MediaCodec的解码方法，FFmpeg的解码方法。<br>这里为叙述方便从入口分析。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>ijkplayer有一个管道的概念，不同平台走不同的管道方法.看ijkplayer/android下的文件。<br>入口就在ijkplayer_jni.c的IjkMediaPlayer_native_setup这个jni方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">IjkMediaPlayer_native_setup(JNIEnv *env, jobject thiz, jobject weak_this)</span><br><span class="line">&#123;</span><br><span class="line">    MPTRACE(<span class="string">"%s\n"</span>, __func__);</span><br><span class="line">    IjkMediaPlayer *mp = ijkmp_android_create(message_loop); </span><br><span class="line">    JNI_CHECK_GOTO(mp, env, <span class="string">"java/lang/OutOfMemoryError"</span>, <span class="string">"mpjni: native_setup: ijkmp_create() failed"</span>, LABEL_RETURN);</span><br><span class="line"></span><br><span class="line">    jni_set_media_player(env, thiz, mp);</span><br><span class="line">    ijkmp_set_weak_thiz(mp, (*env)-&gt;NewGlobalRef(env, weak_this));</span><br><span class="line">    ijkmp_set_inject_opaque(mp, ijkmp_get_weak_thiz(mp));</span><br><span class="line">    ijkmp_set_ijkio_inject_opaque(mp, ijkmp_get_weak_thiz(mp));</span><br><span class="line">    ijkmp_android_set_mediacodec_select_callback(mp, mediacodec_select_callback, ijkmp_get_weak_thiz(mp));</span><br><span class="line"></span><br><span class="line">LABEL_RETURN:</span><br><span class="line">    ijkmp_dec_ref_p(&amp;mp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>message_loop创建一个死循环，接受消息并再通过handler发送给Android层。<br>这些不细究，继续看ijkmp_android_create做了什么。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IjkMediaPlayer *<span class="title">ijkmp_android_create</span><span class="params">(<span class="keyword">int</span>(*msg_loop)(<span class="keyword">void</span>*))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IjkMediaPlayer *mp = ijkmp_create(msg_loop);</span><br><span class="line">    <span class="keyword">if</span> (!mp)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    mp-&gt;ffplayer-&gt;vout = SDL_VoutAndroid_CreateForAndroidSurface();</span><br><span class="line">    <span class="keyword">if</span> (!mp-&gt;ffplayer-&gt;vout)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    mp-&gt;ffplayer-&gt;pipeline = ffpipeline_create_from_android(mp-&gt;ffplayer);</span><br><span class="line">    <span class="keyword">if</span> (!mp-&gt;ffplayer-&gt;pipeline)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    ffpipeline_set_vout(mp-&gt;ffplayer-&gt;pipeline, mp-&gt;ffplayer-&gt;vout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mp;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    ijkmp_dec_ref_p(&amp;mp);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里设置了两个关键参数vout用于输出，pipeline用于解码，都是平台相关。显示部分就是surface转成nativewindow，再对应ffmpeg和mediacodec的使用。这部分不细究。<br>继续看ffpipeline_create_from_android如何做的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IJKFF_Pipeline *<span class="title">ffpipeline_create_from_android</span><span class="params">(FFPlayer *ffp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALOGD(<span class="string">"ffpipeline_create_from_android()\n"</span>);</span><br><span class="line">    IJKFF_Pipeline *pipeline = ffpipeline_alloc(&amp;g_pipeline_class, <span class="keyword">sizeof</span>(IJKFF_Pipeline_Opaque));</span><br><span class="line">    <span class="keyword">if</span> (!pipeline)</span><br><span class="line">        <span class="keyword">return</span> pipeline;</span><br><span class="line"></span><br><span class="line">    IJKFF_Pipeline_Opaque *opaque = pipeline-&gt;opaque;</span><br><span class="line">    opaque-&gt;ffp                   = ffp;</span><br><span class="line">    opaque-&gt;surface_mutex         = SDL_CreateMutex();</span><br><span class="line">    opaque-&gt;left_volume           = <span class="number">1.0f</span>;</span><br><span class="line">    opaque-&gt;right_volume          = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (!opaque-&gt;surface_mutex) &#123;</span><br><span class="line">        ALOGE(<span class="string">"ffpipeline-android:create SDL_CreateMutex failed\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pipeline-&gt;func_destroy              = func_destroy;</span><br><span class="line">    pipeline-&gt;func_open_video_decoder   = func_open_video_decoder;</span><br><span class="line">    pipeline-&gt;func_open_audio_output    = func_open_audio_output;</span><br><span class="line">    pipeline-&gt;func_init_video_decoder   = func_init_video_decoder;</span><br><span class="line">    pipeline-&gt;func_config_video_decoder = func_config_video_decoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pipeline;</span><br><span class="line">fail:</span><br><span class="line">    ffpipeline_free_p(&amp;pipeline);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有打开视频解码器和init视频解码器的方法，都由管道转发，在ffpipeline_android.c中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IJKFF_Pipenode* <span class="title">ffpipeline_open_video_decoder</span><span class="params">(IJKFF_Pipeline *pipeline, FFPlayer *ffp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline-&gt;func_open_video_decoder(pipeline, ffp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IJKFF_Pipenode* <span class="title">ffpipeline_init_video_decoder</span><span class="params">(IJKFF_Pipeline *pipeline, FFPlayer *ffp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline-&gt;func_init_video_decoder(pipeline, ffp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>func_open_video_decoder和func_init_video_decoder方法里面的实现很多是重复的，都是获取一个IJKFF_Pipenode。<br>我们再具体分析流程，找出原因。找调用发现ffpipeline_init_video_decoder在ffplay中准备阶段就调用了，在stream_open中被调用，而func_open_video_decoder在stream_component_open中被调用，且是node_vdec初始化失败才会调用。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">stream_component_open：</span><br><span class="line">       <span class="keyword">if</span> (ffp-&gt;async_init_decoder) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!is-&gt;initialized_decoder) &#123;</span><br><span class="line">                SDL_Delay(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ffp-&gt;node_vdec) &#123;</span><br><span class="line">                is-&gt;viddec.avctx = avctx;</span><br><span class="line">                ret = ffpipeline_config_video_decoder(ffp-&gt;pipeline, ffp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ret || !ffp-&gt;node_vdec) &#123;</span><br><span class="line">                decoder_init(&amp;is-&gt;viddec, avctx, &amp;is-&gt;videoq, is-&gt;continue_read_thread);</span><br><span class="line">                ffp-&gt;node_vdec = ffpipeline_open_video_decoder(ffp-&gt;pipeline, ffp);</span><br><span class="line">                <span class="keyword">if</span> (!ffp-&gt;node_vdec)</span><br><span class="line">                    <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decoder_init(&amp;is-&gt;viddec, avctx, &amp;is-&gt;videoq, is-&gt;continue_read_thread);</span><br><span class="line">            ffp-&gt;node_vdec = ffpipeline_open_video_decoder(ffp-&gt;pipeline, ffp);</span><br><span class="line">            <span class="keyword">if</span> (!ffp-&gt;node_vdec)</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = decoder_start(&amp;is-&gt;viddec, video_thread, ffp, <span class="string">"ff_video_dec"</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure><p>这里看到更多细节，打开流时先看解码器初始化模式，如果是异步，没有初始化完成就dealy5毫秒。<br>再如果没有初始化完成，就是要ffpipeline_open_video_decoder启动。非异步就直接使用ffpipeline_open_video_decoder打开。结束后再打开video_thread线程，这个留待后面分析。<br>打开解码器方法func_open_video_decoder：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> IJKFF_Pipenode *<span class="title">func_open_video_decoder</span><span class="params">(IJKFF_Pipeline *pipeline, FFPlayer *ffp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IJKFF_Pipeline_Opaque *opaque = pipeline-&gt;opaque;</span><br><span class="line">    IJKFF_Pipenode        *node = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ffp-&gt;mediacodec_all_videos || ffp-&gt;mediacodec_avc || ffp-&gt;mediacodec_hevc || ffp-&gt;mediacodec_mpeg2)</span><br><span class="line">        node = ffpipenode_create_video_decoder_from_android_mediacodec(ffp, pipeline, opaque-&gt;weak_vout);</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        node = ffpipenode_create_video_decoder_from_ffplay(ffp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过格式支持先尝试打开硬件解码，如果node没有成功创建再使用ffplay进行软件解码。<br>再看ffpipenode_create_video_decoder_from_android_mediacodec方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IJKFF_Pipenode *<span class="title">ffpipenode_create_video_decoder_from_android_mediacodec</span><span class="params">(FFPlayer *ffp, IJKFF_Pipeline *pipeline, SDL_Vout *vout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALOGD(<span class="string">"ffpipenode_create_video_decoder_from_android_mediacodec()\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (SDL_Android_GetApiLevel() &lt; IJK_API_16_JELLY_BEAN)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ffp || !ffp-&gt;is)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    IJKFF_Pipenode *node = ffpipenode_alloc(<span class="keyword">sizeof</span>(IJKFF_Pipenode_Opaque));</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    VideoState            *is     = ffp-&gt;is;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque = node-&gt;opaque;</span><br><span class="line">    JNIEnv                *env    = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span>                    ret    = <span class="number">0</span>;</span><br><span class="line">    jobject                jsurface = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    node-&gt;func_destroy  = func_destroy;</span><br><span class="line">    <span class="comment">//设置解码线程</span></span><br><span class="line">    <span class="keyword">if</span> (ffp-&gt;mediacodec_sync) &#123;</span><br><span class="line">        node-&gt;func_run_sync = func_run_sync_loop;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;func_run_sync = func_run_sync;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;func_flush    = func_flush;</span><br><span class="line">    opaque-&gt;pipeline    = pipeline;</span><br><span class="line">    opaque-&gt;ffp         = ffp;</span><br><span class="line">    opaque-&gt;decoder     = &amp;is-&gt;viddec;</span><br><span class="line">    opaque-&gt;weak_vout   = vout;</span><br><span class="line"></span><br><span class="line">    opaque-&gt;codecpar = avcodec_parameters_alloc();</span><br><span class="line">    <span class="keyword">if</span> (!opaque-&gt;codecpar)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取解码器参数</span></span><br><span class="line">    ret = avcodec_parameters_from_context(opaque-&gt;codecpar, opaque-&gt;decoder-&gt;avctx);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opaque-&gt;codecpar-&gt;codec_id) &#123;</span><br><span class="line">    <span class="keyword">case</span> AV_CODEC_ID_H264:</span><br><span class="line">        <span class="keyword">if</span> (!ffp-&gt;mediacodec_avc &amp;&amp; !ffp-&gt;mediacodec_all_videos) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: MediaCodec: AVC/H264 is disabled. codec_id:%d \n"</span>, __func__, opaque-&gt;codecpar-&gt;codec_id);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (opaque-&gt;codecpar-&gt;profile) &#123;</span><br><span class="line">            <span class="keyword">case</span> FF_PROFILE_H264_BASELINE:</span><br><span class="line">                ALOGI(<span class="string">"%s: MediaCodec: H264_BASELINE: enabled\n"</span>, __func__);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FF_PROFILE_H264_CONSTRAINED_BASELINE:</span><br><span class="line">                ALOGI(<span class="string">"%s: MediaCodec: H264_CONSTRAINED_BASELINE: enabled\n"</span>, __func__);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">           ...</span><br><span class="line">    <span class="keyword">case</span> AV_CODEC_ID_HEVC:</span><br><span class="line">        <span class="keyword">if</span> (!ffp-&gt;mediacodec_hevc &amp;&amp; !ffp-&gt;mediacodec_all_videos) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: MediaCodec/HEVC is disabled. codec_id:%d \n"</span>, __func__, opaque-&gt;codecpar-&gt;codec_id);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(opaque-&gt;mcc.mime_type, SDL_AMIME_VIDEO_HEVC);</span><br><span class="line">        opaque-&gt;mcc.profile = opaque-&gt;codecpar-&gt;profile;</span><br><span class="line">        opaque-&gt;mcc.level   = opaque-&gt;codecpar-&gt;level;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">fail:</span><br><span class="line">    ffpipenode_free_p(&amp;node);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里通过mediacodec_sync这个配置设置了解码线程，同步则使用func_run_sync，异步使用func_run_sync。<br>通过codecpar的codec_id和profile的判断是否支持，不支持就会失败，然后回到前面走软解ffplay。</p><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><h4 id="启动解码线程"><a href="#启动解码线程" class="headerlink" title="启动解码线程"></a>启动解码线程</h4><p>通过初始化我们获得了IJKFF_Pipenode的节点管道，即ffp的node_vdec。且给node设置了func_run_sync方法。<br>func_run_sync在ff_ffpipenode.c中被转发：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffpipenode_run_sync</span><span class="params">(IJKFF_Pipenode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;func_run_sync(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如名称，这是一个线程。在ffplay中video_thread中被启动，就是前面stream_component_open中打开解码器后被调用的方法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">video_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFPlayer *ffp = (FFPlayer *)arg;</span><br><span class="line">    <span class="keyword">int</span>       ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ffp-&gt;node_vdec) &#123;</span><br><span class="line">        ret = ffpipenode_run_sync(ffp-&gt;node_vdec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="同步解码"><a href="#同步解码" class="headerlink" title="同步解码"></a>同步解码</h4><p>前面讲到mediacodec_sync设置，同步情况下就启动func_run_sync_loop方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func_run_sync_loop</span><span class="params">(IJKFF_Pipenode *node)</span> </span>&#123;</span><br><span class="line">    JNIEnv                *env           = <span class="literal">NULL</span>;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque        = node-&gt;opaque;</span><br><span class="line">    FFPlayer              *ffp           = opaque-&gt;ffp;</span><br><span class="line">    VideoState            *is            = ffp-&gt;is;</span><br><span class="line">    Decoder               *d             = &amp;is-&gt;viddec;</span><br><span class="line">    PacketQueue           *q             = d-&gt;<span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">int</span>                    ret           = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>                    dequeue_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>                    enqueue_count = <span class="number">0</span>;</span><br><span class="line">    AVFrame               *frame         = <span class="literal">NULL</span>;</span><br><span class="line">    AVRational             frame_rate    = av_guess_frame_rate(is-&gt;ic, is-&gt;video_st, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!opaque-&gt;acodec) &#123;</span><br><span class="line">        <span class="keyword">return</span> ffp_video_thread(ffp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (JNI_OK != SDL_JNI_SetupThreadEnv(&amp;env)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: SetupThreadEnv failed\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame = av_frame_alloc();</span><br><span class="line">    <span class="keyword">if</span> (!frame)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//关键代码</span></span><br><span class="line">    <span class="keyword">while</span> (!q-&gt;abort_request) &#123;</span><br><span class="line">        ret = drain_output_buffer2(env, node, AMC_SYNC_OUTPUT_TIMEOUT_US, &amp;dequeue_count, frame, frame_rate);</span><br><span class="line">        ret = feed_input_buffer2(env, node, AMC_SYNC_INPUT_TIMEOUT_US, &amp;enqueue_count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    av_frame_free(&amp;frame);</span><br><span class="line">    opaque-&gt;<span class="built_in">abort</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (opaque-&gt;n_buf_out) &#123;</span><br><span class="line">        <span class="built_in">free</span>(opaque-&gt;amc_buf_out);</span><br><span class="line">        opaque-&gt;n_buf_out = <span class="number">0</span>;</span><br><span class="line">        opaque-&gt;amc_buf_out = <span class="literal">NULL</span>;</span><br><span class="line">        opaque-&gt;off_buf_out = <span class="number">0</span>;</span><br><span class="line">        opaque-&gt;last_queued_pts = AV_NOPTS_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opaque-&gt;acodec) &#123;</span><br><span class="line">        SDL_VoutAndroid_invalidateAllBuffers(opaque-&gt;weak_vout);</span><br><span class="line">    &#125;</span><br><span class="line">    SDL_AMediaCodec_stop(opaque-&gt;acodec);</span><br><span class="line">    SDL_AMediaCodec_decreaseReferenceP(&amp;opaque-&gt;acodec);</span><br><span class="line">    ALOGI(<span class="string">"MediaCodec: %s: exit: %d"</span>, __func__, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码在while循环中，同步进行获取输出，填充输入。</p><p>看feed_input_buffer2方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">feed_input_buffer2</span><span class="params">(JNIEnv *env, IJKFF_Pipenode *node, <span class="keyword">int64_t</span> timeUs, <span class="keyword">int</span> *enqueue_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque   = node-&gt;opaque;</span><br><span class="line">    FFPlayer              *ffp      = opaque-&gt;ffp;</span><br><span class="line">    IJKFF_Pipeline        *pipeline = opaque-&gt;pipeline;</span><br><span class="line">    VideoState            *is       = ffp-&gt;is;</span><br><span class="line">    Decoder               *d        = &amp;is-&gt;viddec;</span><br><span class="line">    PacketQueue           *q        = d-&gt;<span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">sdl_amedia_status_t</span>    amc_ret  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>                    ret      = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span>  input_buffer_index     = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span>  copy_size              = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int64_t</span>  time_stamp             = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> queue_flags            = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enqueue_count)</span><br><span class="line">        *enqueue_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;abort_request) &#123;</span><br><span class="line">        ret = ACODEC_EXIT;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!d-&gt;packet_pending || d-&gt;<span class="built_in">queue</span>-&gt;serial != d-&gt;pkt_serial) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> AMC_USE_AVBITSTREAM_FILTER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        H264ConvertState convert_state = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">//数据源</span></span><br><span class="line">        AVPacket pkt;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;nb_packets == <span class="number">0</span>)</span><br><span class="line">                SDL_CondSignal(d-&gt;empty_queue_cond);</span><br><span class="line">            <span class="comment">//从队列获取数据</span></span><br><span class="line">            <span class="keyword">if</span> (ffp_packet_queue_get_or_buffering(ffp, d-&gt;<span class="built_in">queue</span>, &amp;pkt, &amp;d-&gt;pkt_serial, &amp;d-&gt;finished) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ret = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ffp_is_flush_packet(&amp;pkt) || opaque-&gt;acodec_flush_request) &#123;</span><br><span class="line">                <span class="comment">// request flush before lock, or never get mutex</span></span><br><span class="line">                opaque-&gt;acodec_flush_request = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (SDL_AMediaCodec_isStarted(opaque-&gt;acodec)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (opaque-&gt;input_packet_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// flush empty queue cause error on OMX.SEC.AVC.Decoder (Nexus S)</span></span><br><span class="line">                        SDL_VoutAndroid_invalidateAllBuffers(opaque-&gt;weak_vout);</span><br><span class="line">                        SDL_AMediaCodec_flush(opaque-&gt;acodec);</span><br><span class="line">                        opaque-&gt;input_packet_count = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// If codec is configured in synchronous mode, codec will resume automatically</span></span><br><span class="line">                    <span class="comment">// SDL_AMediaCodec_start(opaque-&gt;acodec);</span></span><br><span class="line">                &#125;</span><br><span class="line">                opaque-&gt;acodec_flush_request = <span class="literal">false</span>;</span><br><span class="line">                d-&gt;finished = <span class="number">0</span>;</span><br><span class="line">                d-&gt;next_pts = d-&gt;start_pts;</span><br><span class="line">                d-&gt;next_pts_tb = d-&gt;start_pts_tb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (ffp_is_flush_packet(&amp;pkt) || d-&gt;<span class="built_in">queue</span>-&gt;serial != d-&gt;pkt_serial);</span><br><span class="line">        av_packet_split_side_data(&amp;pkt);</span><br><span class="line">        av_packet_unref(&amp;d-&gt;pkt);</span><br><span class="line">        d-&gt;pkt_temp = d-&gt;pkt = pkt;</span><br><span class="line">        d-&gt;packet_pending = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ffp的配置之一，通过ffmpeg，处理大小变化</span></span><br><span class="line">        <span class="keyword">if</span> (opaque-&gt;ffp-&gt;mediacodec_handle_resolution_change &amp;&amp;</span><br><span class="line">            opaque-&gt;codecpar-&gt;codec_id == AV_CODEC_ID_H264) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span>  *size_data      = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">int</span>       size_data_size = <span class="number">0</span>;</span><br><span class="line">            AVPacket *avpkt          = &amp;d-&gt;pkt_temp;</span><br><span class="line">            size_data = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA, &amp;size_data_size);</span><br><span class="line">            <span class="comment">// minimum avcC(sps,pps) = 7</span></span><br><span class="line">            <span class="keyword">if</span> (size_data &amp;&amp; size_data_size &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span>             got_picture = <span class="number">0</span>;</span><br><span class="line">                AVFrame        *frame      = av_frame_alloc();</span><br><span class="line">                AVDictionary   *codec_opts = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">const</span> AVCodec  *codec      = opaque-&gt;decoder-&gt;avctx-&gt;codec;</span><br><span class="line">                AVCodecContext *new_avctx  = avcodec_alloc_context3(codec);</span><br><span class="line">                <span class="keyword">int</span> change_ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!new_avctx)</span><br><span class="line">                    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line"></span><br><span class="line">                avcodec_parameters_to_context(new_avctx, opaque-&gt;codecpar);</span><br><span class="line">                av_freep(&amp;new_avctx-&gt;extradata);</span><br><span class="line">                new_avctx-&gt;extradata = av_mallocz(size_data_size + AV_INPUT_BUFFER_PADDING_SIZE);</span><br><span class="line">                <span class="keyword">if</span> (!new_avctx-&gt;extradata) &#123;</span><br><span class="line">                    avcodec_free_context(&amp;new_avctx);</span><br><span class="line">                    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">memcpy</span>(new_avctx-&gt;extradata, size_data, size_data_size);</span><br><span class="line">                new_avctx-&gt;extradata_size = size_data_size;</span><br><span class="line"></span><br><span class="line">                av_dict_set(&amp;codec_opts, <span class="string">"threads"</span>, <span class="string">"1"</span>, <span class="number">0</span>);</span><br><span class="line">                change_ret = avcodec_open2(new_avctx, codec, &amp;codec_opts);</span><br><span class="line">                av_dict_free(&amp;codec_opts);</span><br><span class="line">                <span class="keyword">if</span> (change_ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    avcodec_free_context(&amp;new_avctx);</span><br><span class="line">                    <span class="keyword">return</span> change_ret;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                change_ret = avcodec_decode_video2(new_avctx, frame, &amp;got_picture, avpkt);</span><br><span class="line">                <span class="keyword">if</span> (change_ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    avcodec_free_context(&amp;new_avctx);</span><br><span class="line">                    <span class="keyword">return</span> change_ret;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (opaque-&gt;codecpar-&gt;width  != new_avctx-&gt;width &amp;&amp;</span><br><span class="line">                        opaque-&gt;codecpar-&gt;height != new_avctx-&gt;height) &#123;</span><br><span class="line">                        ALOGW(<span class="string">"AV_PKT_DATA_NEW_EXTRADATA: %d x %d\n"</span>, new_avctx-&gt;width, new_avctx-&gt;height);</span><br><span class="line">                        avcodec_parameters_from_context(opaque-&gt;codecpar, new_avctx);</span><br><span class="line">                        opaque-&gt;aformat_need_recreate = <span class="literal">true</span>;</span><br><span class="line">                        ffpipeline_set_surface_need_reconfigure_l(pipeline, <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                av_frame_unref(frame);</span><br><span class="line">                avcodec_free_context(&amp;new_avctx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        queue_flags = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取输入缓存队列</span></span><br><span class="line">        input_buffer_index = SDL_AMediaCodec_dequeueInputBuffer(opaque-&gt;acodec, timeUs);</span><br><span class="line">        <span class="keyword">if</span> (input_buffer_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (SDL_AMediaCodec_isInputBuffersValid(opaque-&gt;acodec)) &#123;</span><br><span class="line">                <span class="comment">// timeout</span></span><br><span class="line">                ret = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// enqueue fake frame</span></span><br><span class="line">                queue_flags |= AMEDIACODEC__BUFFER_FLAG_FAKE_FRAME;</span><br><span class="line">                copy_size    = d-&gt;pkt_temp.size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SDL_AMediaCodecFake_flushFakeFrames(opaque-&gt;acodec);</span><br><span class="line">            <span class="comment">//写数据</span></span><br><span class="line">            copy_size = SDL_AMediaCodec_writeInputData(opaque-&gt;acodec, input_buffer_index, d-&gt;pkt_temp.data, d-&gt;pkt_temp.size);</span><br><span class="line">            <span class="keyword">if</span> (!copy_size) &#123;</span><br><span class="line">                ALOGE(<span class="string">"%s: SDL_AMediaCodec_getInputBuffer failed\n"</span>, __func__);</span><br><span class="line">                ret = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        time_stamp = d-&gt;pkt_temp.pts;</span><br><span class="line">        <span class="keyword">if</span> (time_stamp == AV_NOPTS_VALUE &amp;&amp; d-&gt;pkt_temp.dts != AV_NOPTS_VALUE)</span><br><span class="line">            time_stamp = d-&gt;pkt_temp.dts;</span><br><span class="line">        <span class="keyword">if</span> (time_stamp &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            time_stamp = av_rescale_q(time_stamp, is-&gt;video_st-&gt;time_base, AV_TIME_BASE_Q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            time_stamp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ALOGE("queueInputBuffer, %lld\n", time_stamp);</span></span><br><span class="line">        <span class="comment">//buffer入队列</span></span><br><span class="line">        amc_ret = SDL_AMediaCodec_queueInputBuffer(opaque-&gt;acodec, input_buffer_index, <span class="number">0</span>, copy_size, time_stamp, queue_flags);</span><br><span class="line">        <span class="keyword">if</span> (amc_ret != SDL_AMEDIA_OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: SDL_AMediaCodec_getInputBuffer failed\n"</span>, __func__);</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ALOGE("%s: queue %d/%d", __func__, (int)copy_size, (int)input_buffer_size);</span></span><br><span class="line">        opaque-&gt;input_packet_count++;</span><br><span class="line">        <span class="keyword">if</span> (enqueue_count)</span><br><span class="line">            ++*enqueue_count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        d-&gt;packet_pending = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        d-&gt;pkt_temp.dts =</span><br><span class="line">        d-&gt;pkt_temp.pts = AV_NOPTS_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;pkt_temp.data) &#123;</span><br><span class="line">            d-&gt;pkt_temp.data += copy_size;</span><br><span class="line">            d-&gt;pkt_temp.size -= copy_size;</span><br><span class="line">            <span class="keyword">if</span> (d-&gt;pkt_temp.size &lt;= <span class="number">0</span>)</span><br><span class="line">                d-&gt;packet_pending = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">FIXME:</span> detect if decode finished</span></span><br><span class="line">            <span class="comment">// if (!got_frame) &#123;</span></span><br><span class="line">                d-&gt;packet_pending = <span class="number">0</span>;</span><br><span class="line">                d-&gt;finished = d-&gt;pkt_serial;</span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解MeidiaCodec就清楚输入流程了，看几个关键步骤就非常明了。<br>这里数据源是从ffp_packet_queue_get_or_buffering获取的，数据读取还是通过ffmpeg的avformat，没有通过Android的MediaExtractor，只是解码使用了mediacodec。<br>再看输出方法drain_output_buffer2：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drain_output_buffer2</span><span class="params">(JNIEnv *env, IJKFF_Pipenode *node, <span class="keyword">int64_t</span> timeUs, <span class="keyword">int</span> *dequeue_count, AVFrame *frame, AVRational frame_rate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque    = node-&gt;opaque;</span><br><span class="line">    FFPlayer              *ffp       = opaque-&gt;ffp;</span><br><span class="line">    VideoState            *is        = ffp-&gt;is;</span><br><span class="line">    AVRational            tb         = is-&gt;video_st-&gt;time_base;</span><br><span class="line">    <span class="keyword">int</span>                   got_frame  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>                   ret        = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">double</span>                duration;</span><br><span class="line">    <span class="keyword">double</span>                pts;</span><br><span class="line">    <span class="keyword">while</span> (ret) &#123;</span><br><span class="line">        got_frame = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//真正获取数据方法，数据在frame，是否获取是got_frame</span></span><br><span class="line">        ret = drain_output_buffer2_l(env, node, timeUs, dequeue_count, frame, &amp;got_frame);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opaque-&gt;decoder-&gt;<span class="built_in">queue</span>-&gt;abort_request) &#123;</span><br><span class="line">            <span class="keyword">if</span> (got_frame &amp;&amp; frame-&gt;opaque)</span><br><span class="line">                SDL_VoutAndroid_releaseBufferProxyP(opaque-&gt;weak_vout, (SDL_AMediaCodecBufferProxy **)&amp;frame-&gt;opaque, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ACODEC_EXIT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (got_frame &amp;&amp; frame-&gt;opaque)</span><br><span class="line">                SDL_VoutAndroid_releaseBufferProxyP(opaque-&gt;weak_vout, (SDL_AMediaCodecBufferProxy **)&amp;frame-&gt;opaque, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (got_frame) &#123;</span><br><span class="line">        duration = (frame_rate.num &amp;&amp; frame_rate.den ? av_q2d((AVRational)&#123;frame_rate.den, frame_rate.num&#125;) : <span class="number">0</span>);</span><br><span class="line">        pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);</span><br><span class="line">        <span class="keyword">if</span> (ffp-&gt;framedrop &gt; <span class="number">0</span> || (ffp-&gt;framedrop &amp;&amp; ffp_get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &#123;</span><br><span class="line">            ffp-&gt;stat.decode_frame_count++;</span><br><span class="line">            <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">                <span class="keyword">double</span> dpts = pts;</span><br><span class="line">                <span class="keyword">double</span> diff = dpts - ffp_get_master_clock(is);</span><br><span class="line">                <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD &amp;&amp;</span><br><span class="line">                    diff - is-&gt;frame_last_filter_delay &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    is-&gt;viddec.pkt_serial == is-&gt;vidclk.serial &amp;&amp;</span><br><span class="line">                    is-&gt;videoq.nb_packets) &#123;</span><br><span class="line">                    is-&gt;frame_drops_early++;</span><br><span class="line">                    is-&gt;continuous_frame_drops_early++;</span><br><span class="line">                    <span class="keyword">if</span> (is-&gt;continuous_frame_drops_early &gt; ffp-&gt;framedrop) &#123;</span><br><span class="line">                        is-&gt;continuous_frame_drops_early = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ffp-&gt;stat.drop_frame_count++;</span><br><span class="line">                        ffp-&gt;stat.drop_frame_rate = (<span class="keyword">float</span>)(ffp-&gt;stat.drop_frame_count) / (<span class="keyword">float</span>)(ffp-&gt;stat.decode_frame_count);</span><br><span class="line">                        <span class="keyword">if</span> (frame-&gt;opaque) &#123;</span><br><span class="line">                            SDL_VoutAndroid_releaseBufferProxyP(opaque-&gt;weak_vout, (SDL_AMediaCodecBufferProxy **)&amp;frame-&gt;opaque, <span class="literal">false</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        av_frame_unref(frame);</span><br><span class="line">                        <span class="keyword">return</span> ret;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = ffp_queue_picture(ffp, frame, pts, duration, av_frame_get_pkt_pos(frame), is-&gt;viddec.pkt_serial);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">if</span> (frame-&gt;opaque)</span><br><span class="line">                SDL_VoutAndroid_releaseBufferProxyP(opaque-&gt;weak_vout, (SDL_AMediaCodecBufferProxy **)&amp;frame-&gt;opaque, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        av_frame_unref(frame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取到frame后通过ffp_queue_picture去显示，看输出真正逻辑所在drain_output_buffer2_l方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drain_output_buffer2_l</span><span class="params">(JNIEnv *env, IJKFF_Pipenode *node, <span class="keyword">int64_t</span> timeUs, <span class="keyword">int</span> *dequeue_count, AVFrame *frame, <span class="keyword">int</span> *got_frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque         = node-&gt;opaque;</span><br><span class="line">    FFPlayer              *ffp            = opaque-&gt;ffp;</span><br><span class="line">    SDL_AMediaCodecBufferInfo bufferInfo;</span><br><span class="line">    <span class="keyword">ssize_t</span>          output_buffer_index  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dequeue_count)</span><br><span class="line">        *dequeue_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (JNI_OK != SDL_JNI_SetupThreadEnv(&amp;env)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s:create: SetupThreadEnv failed\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> ACODEC_RETRY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取输出buffer索引，然后是熟悉的返回值判断</span></span><br><span class="line">    output_buffer_index = SDL_AMediaCodecFake_dequeueOutputBuffer(opaque-&gt;acodec, &amp;bufferInfo, timeUs);</span><br><span class="line">    <span class="keyword">if</span> (output_buffer_index == AMEDIACODEC__INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">        ALOGD(<span class="string">"AMEDIACODEC__INFO_OUTPUT_BUFFERS_CHANGED\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ACODEC_RETRY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output_buffer_index == AMEDIACODEC__INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">        ALOGD(<span class="string">"AMEDIACODEC__INFO_OUTPUT_FORMAT_CHANGED\n"</span>);</span><br><span class="line">        SDL_AMediaFormat_deleteP(&amp;opaque-&gt;output_aformat);</span><br><span class="line">        opaque-&gt;output_aformat = SDL_AMediaCodec_getOutputFormat(opaque-&gt;acodec);</span><br><span class="line">        <span class="keyword">if</span> (opaque-&gt;output_aformat) &#123;</span><br><span class="line">            <span class="keyword">int</span> width        = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> height       = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> color_format = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> stride       = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> slice_height = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> crop_left    = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> crop_top     = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> crop_right   = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> crop_bottom  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"width"</span>,          &amp;width);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"height"</span>,         &amp;height);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"color-format"</span>,   &amp;color_format);</span><br><span class="line"></span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"stride"</span>,         &amp;stride);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"slice-height"</span>,   &amp;slice_height);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"crop-left"</span>,      &amp;crop_left);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"crop-top"</span>,       &amp;crop_top);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"crop-right"</span>,     &amp;crop_right);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"crop-bottom"</span>,    &amp;crop_bottom);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// TI decoder could crash after reconfigure</span></span><br><span class="line">            <span class="comment">// ffp_notify_msg3(ffp, FFP_MSG_VIDEO_SIZE_CHANGED, width, height);</span></span><br><span class="line">            <span class="comment">// opaque-&gt;frame_width  = width;</span></span><br><span class="line">            <span class="comment">// opaque-&gt;frame_height = height;</span></span><br><span class="line">            ALOGI(</span><br><span class="line">                <span class="string">"AMEDIACODEC__INFO_OUTPUT_FORMAT_CHANGED\n"</span></span><br><span class="line">                <span class="string">"    width-height: (%d x %d)\n"</span></span><br><span class="line">                <span class="string">"    color-format: (%s: 0x%x)\n"</span></span><br><span class="line">                <span class="string">"    stride:       (%d)\n"</span></span><br><span class="line">                <span class="string">"    slice-height: (%d)\n"</span></span><br><span class="line">                <span class="string">"    crop:         (%d, %d, %d, %d)\n"</span></span><br><span class="line">                ,</span><br><span class="line">                width, height,</span><br><span class="line">                SDL_AMediaCodec_getColorFormatName(color_format), color_format,</span><br><span class="line">                stride,</span><br><span class="line">                slice_height,</span><br><span class="line">                crop_left, crop_top, crop_right, crop_bottom);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ACODEC_RETRY;</span><br><span class="line">        <span class="comment">// continue;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output_buffer_index == AMEDIACODEC__INFO_TRY_AGAIN_LATER) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// continue;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output_buffer_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output_buffer_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ffp-&gt;stat.vdps = SDL_SpeedSamplerAdd(&amp;opaque-&gt;sampler, FFP_SHOW_VDPS_MEDIACODEC, <span class="string">"vdps[MediaCodec]"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//成功后计数加1</span></span><br><span class="line">        <span class="keyword">if</span> (dequeue_count)</span><br><span class="line">            ++*dequeue_count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opaque-&gt;n_buf_out) &#123;</span><br><span class="line">            AMC_Buf_Out *buf_out;</span><br><span class="line">            <span class="keyword">if</span> (opaque-&gt;off_buf_out &lt; opaque-&gt;n_buf_out) &#123;</span><br><span class="line">                <span class="comment">// ALOGD("filling buffer... %d", opaque-&gt;off_buf_out);</span></span><br><span class="line">                buf_out = &amp;opaque-&gt;amc_buf_out[opaque-&gt;off_buf_out++];</span><br><span class="line">                buf_out-&gt;acodec_serial = SDL_AMediaCodec_getSerial(opaque-&gt;acodec);</span><br><span class="line">                buf_out-&gt;port = output_buffer_index;</span><br><span class="line">                buf_out-&gt;info = bufferInfo;</span><br><span class="line">                buf_out-&gt;pts = pts_from_buffer_info(node, &amp;bufferInfo);</span><br><span class="line">                sort_amc_buf_out(opaque-&gt;amc_buf_out, opaque-&gt;off_buf_out);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">double</span> pts;</span><br><span class="line"></span><br><span class="line">                pts = pts_from_buffer_info(node, &amp;bufferInfo);</span><br><span class="line">                <span class="keyword">if</span> (opaque-&gt;last_queued_pts != AV_NOPTS_VALUE &amp;&amp;</span><br><span class="line">                    pts &lt; opaque-&gt;last_queued_pts) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">FIXME:</span> drop unordered picture to avoid dither</span></span><br><span class="line">                    <span class="comment">// ALOGE("early picture, drop!");</span></span><br><span class="line">                    <span class="comment">// SDL_AMediaCodec_releaseOutputBuffer(opaque-&gt;acodec, output_buffer_index, false);</span></span><br><span class="line">                    <span class="comment">// goto done;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* already sorted */</span></span><br><span class="line">                buf_out = &amp;opaque-&gt;amc_buf_out[opaque-&gt;off_buf_out - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">/* new picture is the most aged, send now */</span></span><br><span class="line">                <span class="keyword">if</span> (pts &lt; buf_out-&gt;pts) &#123;</span><br><span class="line">                    <span class="comment">//关键填充frame方法，多种条件触发</span></span><br><span class="line">                    amc_fill_frame(node, frame, got_frame, output_buffer_index, SDL_AMediaCodec_getSerial(opaque-&gt;acodec), &amp;bufferInfo);</span><br><span class="line">                    opaque-&gt;last_queued_pts = pts;</span><br><span class="line">                    <span class="comment">// ALOGD("pts = %f", pts);</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* find one to send */</span></span><br><span class="line">                    <span class="keyword">for</span> (i = opaque-&gt;off_buf_out - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        buf_out = &amp;opaque-&gt;amc_buf_out[i];</span><br><span class="line">                        <span class="keyword">if</span> (pts &gt; buf_out-&gt;pts) &#123;</span><br><span class="line">                            amc_fill_frame(node, frame, got_frame, buf_out-&gt;port, buf_out-&gt;acodec_serial, &amp;buf_out-&gt;info);</span><br><span class="line">                            opaque-&gt;last_queued_pts = buf_out-&gt;pts;</span><br><span class="line">                            <span class="comment">// ALOGD("pts = %f", buf_out-&gt;pts);</span></span><br><span class="line">                            <span class="comment">/* replace for sort later */</span></span><br><span class="line">                            buf_out-&gt;acodec_serial = SDL_AMediaCodec_getSerial(opaque-&gt;acodec);</span><br><span class="line">                            buf_out-&gt;port = output_buffer_index;</span><br><span class="line">                            buf_out-&gt;info = bufferInfo;</span><br><span class="line">                            buf_out-&gt;pts = pts_from_buffer_info(node, &amp;bufferInfo);</span><br><span class="line">                            sort_amc_buf_out(opaque-&gt;amc_buf_out, opaque-&gt;n_buf_out);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* need to discard current buffer */</span></span><br><span class="line">                    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// ALOGE("buffer too small, drop picture!");</span></span><br><span class="line">                        <span class="keyword">if</span> (!(bufferInfo.flags &amp; AMEDIACODEC__BUFFER_FLAG_FAKE_FRAME)) &#123;</span><br><span class="line">                            SDL_AMediaCodec_releaseOutputBuffer(opaque-&gt;acodec, output_buffer_index, <span class="literal">false</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            amc_fill_frame(node, frame, got_frame, output_buffer_index, SDL_AMediaCodec_getSerial(opaque-&gt;acodec), &amp;bufferInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到MediaCodec操作input的关键流程，最后通过amc_fill_frame填充frame，把数据交回ffplay进行显示。<br>继续看amc_fill_frame代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">amc_fill_frame</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IJKFF_Pipenode            *node,</span></span></span><br><span class="line"><span class="function"><span class="params">    AVFrame                   *frame,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>                       *got_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>                        output_buffer_index,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>                        acodec_serial,</span></span></span><br><span class="line"><span class="function"><span class="params">    SDL_AMediaCodecBufferInfo *buffer_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque     = node-&gt;opaque;</span><br><span class="line">    FFPlayer              *ffp        = opaque-&gt;ffp;</span><br><span class="line">    VideoState            *is         = ffp-&gt;is;</span><br><span class="line"></span><br><span class="line">    frame-&gt;opaque = SDL_VoutAndroid_obtainBufferProxy(opaque-&gt;weak_vout, acodec_serial, output_buffer_index, buffer_info);</span><br><span class="line">    <span class="keyword">if</span> (!frame-&gt;opaque)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    frame-&gt;width  = opaque-&gt;frame_width;</span><br><span class="line">    frame-&gt;height = opaque-&gt;frame_height;</span><br><span class="line">    frame-&gt;format = IJK_AV_PIX_FMT__ANDROID_MEDIACODEC;</span><br><span class="line">    frame-&gt;sample_aspect_ratio = opaque-&gt;codecpar-&gt;sample_aspect_ratio;</span><br><span class="line">    frame-&gt;pts    = av_rescale_q(buffer_info-&gt;presentationTimeUs, AV_TIME_BASE_Q, is-&gt;video_st-&gt;time_base);</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;pts &lt; <span class="number">0</span>)</span><br><span class="line">        frame-&gt;pts = AV_NOPTS_VALUE;</span><br><span class="line">    <span class="comment">// ALOGE("%s: %f", __func__, (float)frame-&gt;pts);</span></span><br><span class="line"></span><br><span class="line">    *got_frame = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">    *got_frame = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IJKFF_Pipenode_Opaque是解码结构体，用于输出和显示，在前面初始化IJKFF_Pipenode时也被创建。显示部分就不再分析。</p><h4 id="异步解码"><a href="#异步解码" class="headerlink" title="异步解码"></a>异步解码</h4><p>mediacodec_sync设置为0时开启异步解码，也是默认模式。看func_run_sync线程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func_run_sync</span><span class="params">(IJKFF_Pipenode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JNIEnv                *env      = <span class="literal">NULL</span>;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque   = node-&gt;opaque;</span><br><span class="line">    FFPlayer              *ffp      = opaque-&gt;ffp;</span><br><span class="line">    VideoState            *is       = ffp-&gt;is;</span><br><span class="line">    Decoder               *d        = &amp;is-&gt;viddec;</span><br><span class="line">    PacketQueue           *q        = d-&gt;<span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">int</span>                    ret      = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>                    dequeue_count = <span class="number">0</span>;</span><br><span class="line">    AVFrame               *frame    = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span>                    got_frame = <span class="number">0</span>;</span><br><span class="line">    AVRational             tb         = is-&gt;video_st-&gt;time_base;</span><br><span class="line">    AVRational             frame_rate = av_guess_frame_rate(is-&gt;ic, is-&gt;video_st, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">double</span>                 duration;</span><br><span class="line">    <span class="keyword">double</span>                 pts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再次容错切换软解</span></span><br><span class="line">    <span class="keyword">if</span> (!opaque-&gt;acodec) &#123;</span><br><span class="line">        <span class="keyword">return</span> ffp_video_thread(ffp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (JNI_OK != SDL_JNI_SetupThreadEnv(&amp;env)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: SetupThreadEnv failed\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame = av_frame_alloc();</span><br><span class="line">    <span class="keyword">if</span> (!frame)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过opaque开启input队列线程</span></span><br><span class="line">    opaque-&gt;enqueue_thread = SDL_CreateThreadEx(&amp;opaque-&gt;_enqueue_thread, enqueue_thread_func, node, <span class="string">"amediacodec_input_thread"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!opaque-&gt;enqueue_thread) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s: SDL_CreateThreadEx failed\n"</span>, __func__);</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q-&gt;abort_request) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> timeUs = opaque-&gt;acodec_first_dequeue_output_request ? <span class="number">0</span> : AMC_OUTPUT_TIMEOUT_US;</span><br><span class="line">        got_frame = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取输出方法</span></span><br><span class="line">        ret = drain_output_buffer(env, node, timeUs, &amp;dequeue_count, frame, &amp;got_frame);</span><br><span class="line">        <span class="keyword">if</span> (opaque-&gt;acodec_first_dequeue_output_request) &#123;</span><br><span class="line">            SDL_LockMutex(opaque-&gt;acodec_first_dequeue_output_mutex);</span><br><span class="line">            opaque-&gt;acodec_first_dequeue_output_request = <span class="literal">false</span>;</span><br><span class="line">            SDL_CondSignal(opaque-&gt;acodec_first_dequeue_output_cond);</span><br><span class="line">            SDL_UnlockMutex(opaque-&gt;acodec_first_dequeue_output_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (got_frame &amp;&amp; frame-&gt;opaque)</span><br><span class="line">                SDL_VoutAndroid_releaseBufferProxyP(opaque-&gt;weak_vout, (SDL_AMediaCodecBufferProxy **)&amp;frame-&gt;opaque, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取到帧，和同步逻辑一样</span></span><br><span class="line">        <span class="keyword">if</span> (got_frame) &#123;</span><br><span class="line">            duration = (frame_rate.num &amp;&amp; frame_rate.den ? av_q2d((AVRational)&#123;frame_rate.den, frame_rate.num&#125;) : <span class="number">0</span>);</span><br><span class="line">            pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);</span><br><span class="line">            <span class="keyword">if</span> (ffp-&gt;framedrop &gt; <span class="number">0</span> || (ffp-&gt;framedrop &amp;&amp; ffp_get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &#123;</span><br><span class="line">                ffp-&gt;stat.decode_frame_count++;</span><br><span class="line">                <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">double</span> dpts = pts;</span><br><span class="line">                    <span class="keyword">double</span> diff = dpts - ffp_get_master_clock(is);</span><br><span class="line">                    <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD &amp;&amp;</span><br><span class="line">                        diff - is-&gt;frame_last_filter_delay &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        is-&gt;viddec.pkt_serial == is-&gt;vidclk.serial &amp;&amp;</span><br><span class="line">                        is-&gt;videoq.nb_packets) &#123;</span><br><span class="line">                        is-&gt;frame_drops_early++;</span><br><span class="line">                        is-&gt;continuous_frame_drops_early++;</span><br><span class="line">                        <span class="keyword">if</span> (is-&gt;continuous_frame_drops_early &gt; ffp-&gt;framedrop) &#123;</span><br><span class="line">                            is-&gt;continuous_frame_drops_early = <span class="number">0</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ffp-&gt;stat.drop_frame_count++;</span><br><span class="line">                            ffp-&gt;stat.drop_frame_rate = (<span class="keyword">float</span>)(ffp-&gt;stat.drop_frame_count) / (<span class="keyword">float</span>)(ffp-&gt;stat.decode_frame_count);</span><br><span class="line">                            <span class="keyword">if</span> (frame-&gt;opaque) &#123;</span><br><span class="line">                                SDL_VoutAndroid_releaseBufferProxyP(opaque-&gt;weak_vout, (SDL_AMediaCodecBufferProxy **)&amp;frame-&gt;opaque, <span class="literal">false</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            av_frame_unref(frame);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//推送显示</span></span><br><span class="line">            ret = ffp_queue_picture(ffp, frame, pts, duration, av_frame_get_pkt_pos(frame), is-&gt;viddec.pkt_serial);</span><br><span class="line">            <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                <span class="keyword">if</span> (frame-&gt;opaque)</span><br><span class="line">                    SDL_VoutAndroid_releaseBufferProxyP(opaque-&gt;weak_vout, (SDL_AMediaCodecBufferProxy **)&amp;frame-&gt;opaque, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            av_frame_unref(frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    av_frame_free(&amp;frame);</span><br><span class="line">    opaque-&gt;<span class="built_in">abort</span> = <span class="literal">true</span>;</span><br><span class="line">    SDL_WaitThread(opaque-&gt;enqueue_thread, <span class="literal">NULL</span>);</span><br><span class="line">    SDL_AMediaCodecFake_abort(opaque-&gt;acodec);</span><br><span class="line">    <span class="keyword">if</span> (opaque-&gt;n_buf_out) &#123;</span><br><span class="line">        <span class="built_in">free</span>(opaque-&gt;amc_buf_out);</span><br><span class="line">        opaque-&gt;n_buf_out = <span class="number">0</span>;</span><br><span class="line">        opaque-&gt;amc_buf_out = <span class="literal">NULL</span>;</span><br><span class="line">        opaque-&gt;off_buf_out = <span class="number">0</span>;</span><br><span class="line">        opaque-&gt;last_queued_pts = AV_NOPTS_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opaque-&gt;acodec) &#123;</span><br><span class="line">        SDL_VoutAndroid_invalidateAllBuffers(opaque-&gt;weak_vout);</span><br><span class="line">        SDL_LockMutex(opaque-&gt;acodec_mutex);</span><br><span class="line">        SDL_UnlockMutex(opaque-&gt;acodec_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    SDL_AMediaCodec_stop(opaque-&gt;acodec);</span><br><span class="line">    SDL_AMediaCodec_decreaseReferenceP(&amp;opaque-&gt;acodec);</span><br><span class="line">    ALOGI(<span class="string">"MediaCodec: %s: exit: %d"</span>, __func__, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">fallback_to_ffplay:</span><br><span class="line">    ALOGW(<span class="string">"fallback to ffplay decoder\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> ffp_video_thread(opaque-&gt;ffp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>异步解码单独开启了输入的线程，输入输出分离，增加吞吐效率。<br>看输出关键方法drain_output_buffer：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drain_output_buffer</span><span class="params">(JNIEnv *env, IJKFF_Pipenode *node, <span class="keyword">int64_t</span> timeUs, <span class="keyword">int</span> *dequeue_count, AVFrame *frame, <span class="keyword">int</span> *got_frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque = node-&gt;opaque;</span><br><span class="line">    SDL_LockMutex(opaque-&gt;acodec_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (opaque-&gt;acodec_flush_request || opaque-&gt;acodec_reconfigure_request) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> invalid picture here?</span></span><br><span class="line">        <span class="comment">// let feed_input_buffer() get mutex</span></span><br><span class="line">        SDL_CondWaitTimeout(opaque-&gt;acodec_cond, opaque-&gt;acodec_mutex, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = drain_output_buffer_l(env, node, timeUs, dequeue_count, frame, got_frame);</span><br><span class="line">    SDL_UnlockMutex(opaque-&gt;acodec_mutex);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待输出，然后调用核心方法drain_output_buffer_l：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drain_output_buffer_l</span><span class="params">(JNIEnv *env, IJKFF_Pipenode *node, <span class="keyword">int64_t</span> timeUs, <span class="keyword">int</span> *dequeue_count, AVFrame *frame, <span class="keyword">int</span> *got_frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IJKFF_Pipenode_Opaque *opaque   = node-&gt;opaque;</span><br><span class="line">    FFPlayer              *ffp      = opaque-&gt;ffp;</span><br><span class="line">    <span class="keyword">int</span>                    ret      = <span class="number">0</span>;</span><br><span class="line">    SDL_AMediaCodecBufferInfo bufferInfo;</span><br><span class="line">    <span class="keyword">ssize_t</span>                   output_buffer_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dequeue_count)</span><br><span class="line">        *dequeue_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (JNI_OK != SDL_JNI_SetupThreadEnv(&amp;env)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s:create: SetupThreadEnv failed\n"</span>, __func__);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output_buffer_index = SDL_AMediaCodecFake_dequeueOutputBuffer(opaque-&gt;acodec, &amp;bufferInfo, timeUs);</span><br><span class="line">    <span class="keyword">if</span> (output_buffer_index == AMEDIACODEC__INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">        ALOGI(<span class="string">"AMEDIACODEC__INFO_OUTPUT_BUFFERS_CHANGED\n"</span>);</span><br><span class="line">        <span class="comment">// continue;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output_buffer_index == AMEDIACODEC__INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">        ALOGI(<span class="string">"AMEDIACODEC__INFO_OUTPUT_FORMAT_CHANGED\n"</span>);</span><br><span class="line">        SDL_AMediaFormat_deleteP(&amp;opaque-&gt;output_aformat);</span><br><span class="line">        opaque-&gt;output_aformat = SDL_AMediaCodec_getOutputFormat(opaque-&gt;acodec);</span><br><span class="line">        <span class="keyword">if</span> (opaque-&gt;output_aformat) &#123;</span><br><span class="line">            <span class="keyword">int</span> width        = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> height       = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> color_format = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> stride       = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> slice_height = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> crop_left    = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> crop_top     = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> crop_right   = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> crop_bottom  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"width"</span>,          &amp;width);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"height"</span>,         &amp;height);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"color-format"</span>,   &amp;color_format);</span><br><span class="line"></span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"stride"</span>,         &amp;stride);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"slice-height"</span>,   &amp;slice_height);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"crop-left"</span>,      &amp;crop_left);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"crop-top"</span>,       &amp;crop_top);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"crop-right"</span>,     &amp;crop_right);</span><br><span class="line">            SDL_AMediaFormat_getInt32(opaque-&gt;output_aformat, <span class="string">"crop-bottom"</span>,    &amp;crop_bottom);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// TI decoder could crash after reconfigure</span></span><br><span class="line">            <span class="comment">// ffp_notify_msg3(ffp, FFP_MSG_VIDEO_SIZE_CHANGED, width, height);</span></span><br><span class="line">            <span class="comment">// opaque-&gt;frame_width  = width;</span></span><br><span class="line">            <span class="comment">// opaque-&gt;frame_height = height;</span></span><br><span class="line">            ALOGI(</span><br><span class="line">                <span class="string">"AMEDIACODEC__INFO_OUTPUT_FORMAT_CHANGED\n"</span></span><br><span class="line">                <span class="string">"    width-height: (%d x %d)\n"</span></span><br><span class="line">                <span class="string">"    color-format: (%s: 0x%x)\n"</span></span><br><span class="line">                <span class="string">"    stride:       (%d)\n"</span></span><br><span class="line">                <span class="string">"    slice-height: (%d)\n"</span></span><br><span class="line">                <span class="string">"    crop:         (%d, %d, %d, %d)\n"</span></span><br><span class="line">                ,</span><br><span class="line">                width, height,</span><br><span class="line">                SDL_AMediaCodec_getColorFormatName(color_format), color_format,</span><br><span class="line">                stride,</span><br><span class="line">                slice_height,</span><br><span class="line">                crop_left, crop_top, crop_right, crop_bottom);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// continue;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output_buffer_index == AMEDIACODEC__INFO_TRY_AGAIN_LATER) &#123;</span><br><span class="line">        AMCTRACE(<span class="string">"AMEDIACODEC__INFO_TRY_AGAIN_LATER\n"</span>);</span><br><span class="line">        <span class="comment">// continue;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output_buffer_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//没有输出时进行等待输入同步信号</span></span><br><span class="line">        SDL_LockMutex(opaque-&gt;any_input_mutex);</span><br><span class="line">        SDL_CondWaitTimeout(opaque-&gt;any_input_cond, opaque-&gt;any_input_mutex, <span class="number">1000</span>);</span><br><span class="line">        SDL_UnlockMutex(opaque-&gt;any_input_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output_buffer_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ffp-&gt;stat.vdps = SDL_SpeedSamplerAdd(&amp;opaque-&gt;sampler, FFP_SHOW_VDPS_MEDIACODEC, <span class="string">"vdps[MediaCodec]"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dequeue_count)</span><br><span class="line">            ++*dequeue_count;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FFP_SHOW_AMC_VDPS</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (opaque-&gt;benchmark_start_time == <span class="number">0</span>) &#123;</span><br><span class="line">                opaque-&gt;benchmark_start_time   = SDL_GetTickHR();</span><br><span class="line">            &#125;</span><br><span class="line">            opaque-&gt;benchmark_frame_count += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == (opaque-&gt;benchmark_frame_count % <span class="number">240</span>)) &#123;</span><br><span class="line">                Uint64 diff = SDL_GetTickHR() - opaque-&gt;benchmark_start_time;</span><br><span class="line">                <span class="keyword">double</span> per_frame_ms = ((<span class="keyword">double</span>) diff) / opaque-&gt;benchmark_frame_count;</span><br><span class="line">                <span class="keyword">double</span> fps          = ((<span class="keyword">double</span>) opaque-&gt;benchmark_frame_count) * <span class="number">1000</span> / diff;</span><br><span class="line">                ALOGE(<span class="string">"%lf fps, %lf ms/frame, %"</span>PRIu64<span class="string">" frames\n"</span>,</span><br><span class="line">                      fps, per_frame_ms, opaque-&gt;benchmark_frame_count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FFP_AMC_DISABLE_OUTPUT</span></span><br><span class="line">        <span class="keyword">if</span> (!(bufferInfo.flags &amp; AMEDIACODEC__BUFFER_FLAG_FAKE_FRAME)) &#123;</span><br><span class="line">            SDL_AMediaCodec_releaseOutputBuffer(opaque-&gt;acodec, output_buffer_index, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opaque-&gt;n_buf_out) &#123;</span><br><span class="line">            AMC_Buf_Out *buf_out;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (opaque-&gt;off_buf_out &lt; opaque-&gt;n_buf_out) &#123;</span><br><span class="line">                <span class="comment">// ALOGD("filling buffer... %d", opaque-&gt;off_buf_out);</span></span><br><span class="line">                buf_out = &amp;opaque-&gt;amc_buf_out[opaque-&gt;off_buf_out++];</span><br><span class="line">                buf_out-&gt;acodec_serial = SDL_AMediaCodec_getSerial(opaque-&gt;acodec);</span><br><span class="line">                buf_out-&gt;port = output_buffer_index;</span><br><span class="line">                buf_out-&gt;info = bufferInfo;</span><br><span class="line">                buf_out-&gt;pts = pts_from_buffer_info(node, &amp;bufferInfo);</span><br><span class="line">                sort_amc_buf_out(opaque-&gt;amc_buf_out, opaque-&gt;off_buf_out);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">double</span> pts;</span><br><span class="line"></span><br><span class="line">                pts = pts_from_buffer_info(node, &amp;bufferInfo);</span><br><span class="line">                <span class="keyword">if</span> (opaque-&gt;last_queued_pts != AV_NOPTS_VALUE &amp;&amp;</span><br><span class="line">                    pts &lt; opaque-&gt;last_queued_pts) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">FIXME:</span> drop unordered picture to avoid dither</span></span><br><span class="line">                    <span class="comment">// ALOGE("early picture, drop!");</span></span><br><span class="line">                    <span class="comment">// SDL_AMediaCodec_releaseOutputBuffer(opaque-&gt;acodec, output_buffer_index, false);</span></span><br><span class="line">                    <span class="comment">// goto done;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* already sorted */</span></span><br><span class="line">                buf_out = &amp;opaque-&gt;amc_buf_out[opaque-&gt;off_buf_out - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">/* new picture is the most aged, send now */</span></span><br><span class="line">                <span class="keyword">if</span> (pts &lt; buf_out-&gt;pts) &#123;</span><br><span class="line">                    ret = amc_fill_frame(node, frame, got_frame, output_buffer_index, SDL_AMediaCodec_getSerial(opaque-&gt;acodec), &amp;bufferInfo);</span><br><span class="line">                    opaque-&gt;last_queued_pts = pts;</span><br><span class="line">                    <span class="comment">// ALOGD("pts = %f", pts);</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* find one to send */</span></span><br><span class="line">                    <span class="keyword">for</span> (i = opaque-&gt;off_buf_out - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        buf_out = &amp;opaque-&gt;amc_buf_out[i];</span><br><span class="line">                        <span class="keyword">if</span> (pts &gt; buf_out-&gt;pts) &#123;</span><br><span class="line">                            ret = amc_fill_frame(node, frame, got_frame, buf_out-&gt;port, buf_out-&gt;acodec_serial, &amp;buf_out-&gt;info);</span><br><span class="line">                            opaque-&gt;last_queued_pts = buf_out-&gt;pts;</span><br><span class="line">                            <span class="comment">// ALOGD("pts = %f", buf_out-&gt;pts);</span></span><br><span class="line">                            <span class="comment">/* replace for sort later */</span></span><br><span class="line">                            buf_out-&gt;acodec_serial = SDL_AMediaCodec_getSerial(opaque-&gt;acodec);</span><br><span class="line">                            buf_out-&gt;port = output_buffer_index;</span><br><span class="line">                            buf_out-&gt;info = bufferInfo;</span><br><span class="line">                            buf_out-&gt;pts = pts_from_buffer_info(node, &amp;bufferInfo);</span><br><span class="line">                            sort_amc_buf_out(opaque-&gt;amc_buf_out, opaque-&gt;n_buf_out);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* need to discard current buffer */</span></span><br><span class="line">                    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// ALOGE("buffer too small, drop picture!");</span></span><br><span class="line">                        <span class="keyword">if</span> (!(bufferInfo.flags &amp; AMEDIACODEC__BUFFER_FLAG_FAKE_FRAME)) &#123;</span><br><span class="line">                            SDL_AMediaCodec_releaseOutputBuffer(opaque-&gt;acodec, output_buffer_index, <span class="literal">false</span>);</span><br><span class="line">                            <span class="keyword">goto</span> done;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret = amc_fill_frame(node, frame, got_frame, output_buffer_index, SDL_AMediaCodec_getSerial(opaque-&gt;acodec), &amp;bufferInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">if</span> (opaque-&gt;decoder-&gt;<span class="built_in">queue</span>-&gt;abort_request)</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>drain_output_buffer_l流程和drain_output_buffer2_l和差不多一样。<br>异步请求drain_output_buffer_l失败时会等待输入，<br>同步请求drain_output_buffer2_l失败时直接返回ACODEC_RETRY，直接失败。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前面已经把解码流程分析完毕，从option设置，到ffmPlayer初始化,再到解码器初始化，再分析到同步和异步解码。整体解码流程和管道使用都熟悉了。SDL的AMediaCodec方法如何调用到java的AMediaCodec还没有分析，这个留待下篇再分析。</p>]]></content>
    
    <summary type="html">
    
      Android硬解设置和解码流程深入解析
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="C" scheme="http://anddymao.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2019年终总结：拓展新边界</title>
    <link href="http://anddymao.com/2020/01/18/2020-1-18-2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://anddymao.com/2020/01/18/2020-1-18-2019年终总结/</id>
    <published>2020-01-18T06:00:00.000Z</published>
    <updated>2020-01-22T05:45:33.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>今天是年前最后的一个周末假期了，在家里已经收拾好行李，再上几天班就可以回家，然后就告别这个城市了。<br>我每年都会在公众号写一篇年终总结，进行总结反思。写文章可能比写代码更难，不想动笔，就先写下工作与技术方面的总结，这个更实在一点。以后每年都在博客更新一篇总结，作为一名程序员，分享一点自己的心得与反思，给看到的人，也给未来的自己。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="19年回首"><a href="#19年回首" class="headerlink" title="19年回首"></a>19年回首</h3><p>19年是毕业的第五个年头了，在互联网行业也进入资深级别了，不管实力有没有达到，别人对你的要求就会如此了。14年毕业后，其实从12年开始就接触android，一直是一名android开发工程师。移动端越来越成熟，竞争越来越激烈，对程序员的要求也越来也高，这一行也变得越来越难。所以对自己的定位也得变，专注的方向是Android和移动端，或者也可以叫大前端和终端，因为任何方向都需要资深工程师，不必要非要转算法或者后端等其它方向。技术上一专多通，以技术去带动提升业务。</p><p>今年工作方面最重要的成功是做了一个音视频特效sdk：xmstreaming。突破了自己技术的边界，直接用C和C++做音视频开发，开始很艰难，中间很艰难，上线更艰难，但结果很完美，收获了很多，也拓展了自己的技术栈。</p><p>面试招人，带了一个实习生，社招两个，校招发出多个offer，需要招进来的是队友，未来坐在自己身边的人，非常慎重的考察，也要照顾面试者的体验。作为一名技术者需要的是专业范，不能有傲慢。</p><p>技术分享上，博客写了11篇，一些经验总结，平时事情太多，很多东西没有去深入研究。在公司做了两三次技术分享。总结能有更多的沉淀。github没有新项目，工作太忙碌，放假根本不想再做。</p><p>技术学习上。今年技术书籍阅读比较少，粗略看了几本c++的书。技术书籍我分三类，一类是思想类，一类是基础，一类是工具类。可以阅读前两种，第三种买下来一般也是放着，真正需要用的时候google搜索更好用，有更新的信息。学习的方式主要是博客和github，尤其音视频方向资料比较少，主要看老工程的源码去学习。</p><h3 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h3><p>自己去年自己的期望就是还能改变，还能相信未来。这年度最大的变化就是trans到了武汉，虽然还在执行中。我的规划是未来回武汉，因为工作和家庭都重要。所以有朋友推荐武汉的岗位，就找到部门聊了聊，十一前聊的，当天就确定了想让我过去，拖到十一月申请，十二月多才开始在新部门干活，年后二月份再到武汉工作。周期很长，因为决定需要慎重，年龄越大，未来的可能性越少，一个选择的代价就是要放弃其它所有的可能选择。北京有更多的互联网企业和机会，想看一看自己的选择有多少，能力如何。选了两家强度适中的大中厂试了试，都面试都到hr面，最后是一个需求和匹配度问题，拿到其中一个offer，涨薪幅度也非常给力，其它方面也都挺好的。但最终考虑下来还是放弃了，回武汉新部门也很不错，有很多适合我做的，也有很多需要我的地方，未来也有机会，但更多的是选择了未来的生活方式，生活压力小一些，离家人更近。</p><h3 id="20年展望"><a href="#20年展望" class="headerlink" title="20年展望"></a>20年展望</h3><p>一直以来工作上都是一个高效的执行者，20年的目标是尝试突破这个层次，能以更高的视角去看待事物。<br>技术上把握思想，有心得有总结。从做一个需求到做一个业务，提升自己的认知，多思考与总结。<br>工作上完成技术上的优化整合，创造价值，进行团队培养，提升影响力。<br>博客上增加文章产出，进行更多的分享。<br>技术上持续学习。多读一点思想上的书。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>19年年景不好，马爸爸却说是未来10年最好的一年。满满的焦虑感，互联网行业又是焦虑最多的地方，35岁被裁员被优化被输送社会，我不相信我们行业的未来是这样的，我觉得只是以后暴富的机会少了而已，进入一个行业成熟稳定期，而资深的工程师与技术人员总是被需要的，企业也是一直会抱怨招不到人的，只是看你是不是那个被需要的人。提升自己，多思考，这篇说得有点多了，就这样了。</p>]]></content>
    
    <summary type="html">
    
      年前最后一个周末了，再坚持几天，新年快乐！
    
    </summary>
    
    
      <category term="生活" scheme="http://anddymao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Flutter与Android端的通信流程浅析</title>
    <link href="http://anddymao.com/2019/11/10/2019-11-10-Flutter%E4%B8%8EAndroid%E7%AB%AF%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%B5%85%E6%9E%90/"/>
    <id>http://anddymao.com/2019/11/10/2019-11-10-Flutter与Android端的通信流程浅析/</id>
    <published>2019-11-10T06:00:00.000Z</published>
    <updated>2020-01-19T02:36:48.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Flutter 官方提供了一种 Platform Channel 的方案，用于 Dart 和平台之间相互通信。</p><p>我们主要分析下Flutter和Android的通信过程，只分析到java层代码。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Platform Channel提供了三种封装的调用方式，用于不同情景下的使用：</p><p>1.MethodChannel 用于Flutter主动调用Native的方法，并获取相应的返回值<br>2.EventChannel  用于Flutter监听Native的消息，无法回复消息<br>3.BasicMessageChannel 用于Flutter与native双向字符串和半结构化的数据传递</p><h3 id="MethodChannel"><a href="#MethodChannel" class="headerlink" title="MethodChannel"></a>MethodChannel</h3><h4 id="android端"><a href="#android端" class="headerlink" title="android端"></a>android端</h4><p>在Java代码里面添加一个MethodChannel.MethodCallHandler用于处理方法回调，dart端调用方法会调用到这里的onMethodCall，然后根据方法名和参数做对应处理即可。<br>把MethodCallHandler要设置到一个MethodChannel里，对应一个独一的限定名。flutterView实际是一个BinaryMessenger。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodChannel</span> <span class="keyword">implements</span> <span class="title">MethodChannel</span>.<span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Activity activity;</span><br><span class="line">    <span class="keyword">private</span> MethodChannel channel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyMethodChannel <span class="title">registerWith</span><span class="params">(FlutterView flutterView)</span> </span>&#123;</span><br><span class="line">        MethodChannel channel = <span class="keyword">new</span> MethodChannel(flutterView, <span class="string">"MyMethodChannel"</span>);</span><br><span class="line">        MyMethodChannel methodChannelPlugin = <span class="keyword">new</span> MyMethodChannel((Activity) flutterView.getContext(), channel);</span><br><span class="line">        channel.setMethodCallHandler(methodChannelPlugin);</span><br><span class="line">        <span class="keyword">return</span> methodChannelPlugin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyMethodChannel</span><span class="params">(Activity activity, MethodChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall methodCall, MethodChannel.Result result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (methodCall.method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"send"</span>:</span><br><span class="line">                result.success(<span class="string">"android端收到方法："</span> + methodCall.arguments);</span><br><span class="line">                Toast.makeText(activity, methodCall.arguments + <span class="string">""</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                result.notImplemented();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在FlutterActivity创建时调用registerWith就可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">FlutterActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        GeneratedPluginRegistrant.registerWith(<span class="keyword">this</span>);</span><br><span class="line">        MyMethodChannel.registerWith(getFlutterView());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Flutter端"><a href="#Flutter端" class="headerlink" title="Flutter端"></a>Flutter端</h4><p>dart根据MethodChannel的限定名创建MethodChannel，然后调用异步方法，使用future获取回调，即java的Result。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  MethodChannel _methodChannel = MethodChannel(<span class="string">"MyMethodChannel"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _sendToNative() &#123;</span><br><span class="line">    Future&lt;<span class="built_in">String</span>&gt; future =</span><br><span class="line">    _methodChannel.invokeMethod(<span class="string">"send"</span>, _counter);</span><br><span class="line">    future.then((message) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        _counter = <span class="string">"返回值："</span> + message;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="EventChannel"><a href="#EventChannel" class="headerlink" title="EventChannel"></a>EventChannel</h3><h4 id="android端-1"><a href="#android端-1" class="headerlink" title="android端"></a>android端</h4><p>dart端注册后java的onListen被调用，拿到EventSink，用于发送消息到dart，有success，error，endOfStream三个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventChannel</span> <span class="keyword">implements</span> <span class="title">EventChannel</span>.<span class="title">StreamHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Activity activity;</span><br><span class="line">    <span class="keyword">private</span> EventChannel channel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyEventChannel <span class="title">registerWith</span><span class="params">(FlutterView flutterView)</span> </span>&#123;</span><br><span class="line">        EventChannel channel = <span class="keyword">new</span> EventChannel(flutterView, <span class="string">"MyEventChannel"</span>);</span><br><span class="line">        MyEventChannel eventChannel = <span class="keyword">new</span> MyEventChannel((Activity) flutterView.getContext(), channel);</span><br><span class="line">        channel.setStreamHandler(eventChannel);</span><br><span class="line">        <span class="keyword">return</span> eventChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyEventChannel</span><span class="params">(Activity activity, EventChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onListen</span><span class="params">(Object o, EventChannel.EventSink eventSink)</span> </span>&#123;</span><br><span class="line">        activity.getWindow().getDecorView().postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                eventSink.success(<span class="string">"success"</span>);</span><br><span class="line">                eventSink.error(<span class="string">"failed1"</span>,<span class="string">"failed2"</span>,-<span class="number">1</span>);</span><br><span class="line">                eventSink.endOfStream();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCancel</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Flutter端-1"><a href="#Flutter端-1" class="headerlink" title="Flutter端"></a>Flutter端</h4><p>使用eventChannel注册监听，监听三个方法onEvent，onError,onDone，和java的三个方法对应。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _onEvent(<span class="built_in">Object</span> event) &#123;</span><br><span class="line">  _counter = event.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _onError(<span class="built_in">Object</span> error) &#123;</span><br><span class="line">  _counter = error.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _onDone() &#123;</span><br><span class="line">  _counter =<span class="string">"done"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">  <span class="keyword">super</span>.initState();</span><br><span class="line">  _counter = <span class="string">"init"</span>;</span><br><span class="line">  EventChannel eventChannel =  EventChannel(<span class="string">'MyEventChannel'</span>);</span><br><span class="line">  eventChannel.receiveBroadcastStream().listen(_onEvent,onError:_onError,onDone: _onDone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="BasicMessageChannel"><a href="#BasicMessageChannel" class="headerlink" title="BasicMessageChannel"></a>BasicMessageChannel</h3><h4 id="Android端"><a href="#Android端" class="headerlink" title="Android端"></a>Android端</h4><p>创建了一个MessageHandler用于接受消息，用BasicMessageChannel可以发送消息，发送消息可以等待回答，接受消息可以回答，得到回答后一次消息就结束了。是Android端和flutter的双向单次通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageChannel</span> <span class="keyword">implements</span> <span class="title">BasicMessageChannel</span>.<span class="title">MessageHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Activity activity;</span><br><span class="line">    <span class="keyword">private</span> BasicMessageChannel channel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyMessageChannel <span class="title">registerWith</span><span class="params">(FlutterView flutterView)</span> </span>&#123;</span><br><span class="line">        BasicMessageChannel channel = <span class="keyword">new</span> BasicMessageChannel(flutterView, <span class="string">"MyMessageChannel"</span>, StringCodec.INSTANCE);</span><br><span class="line">        MyMessageChannel eventChannel = <span class="keyword">new</span> MyMessageChannel((Activity) flutterView.getContext(), channel);</span><br><span class="line">        channel.setMessageHandler(eventChannel);</span><br><span class="line">        <span class="keyword">return</span> eventChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        channel.send(<span class="string">"给flutter发消息了"</span>);</span><br><span class="line">        channel.send(<span class="string">"给flutter发消息了，请回答"</span>, <span class="keyword">new</span> BasicMessageChannel.Reply() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reply</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">                Toast.makeText(activity,o.toString(),Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyMessageChannel</span><span class="params">(Activity activity, BasicMessageChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String s, BasicMessageChannel.Reply&lt;String&gt; reply)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(activity,s,Toast.LENGTH_LONG).show();</span><br><span class="line">        reply.reply(<span class="string">"知道了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Flutter端-2"><a href="#Flutter端-2" class="headerlink" title="Flutter端"></a>Flutter端</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> basicMessageChannel = <span class="keyword">const</span> BasicMessageChannel(<span class="string">'MyMessageChannel'</span>, StringCodec());</span><br><span class="line">basicMessageChannel.setMessageHandler(</span><br><span class="line">      (<span class="built_in">String</span> message) =&gt; Future&lt;<span class="built_in">String</span>&gt;(() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _counter = message;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"flutter:知道了"</span>;</span><br><span class="line">  &#125;),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; future= basicMessageChannel.send(<span class="string">"来自flutter的message"</span>);</span><br><span class="line">future.then((message) &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    _counter = message;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h2><p>主要分析下Android端框架的事件流程，我们从EventChannel入手</p><h3 id="事件注册流程"><a href="#事件注册流程" class="headerlink" title="事件注册流程"></a>事件注册流程</h3><p>EventChannel创建需要传入一个BinaryMessenger，然后给它设置一个EventChannel.StreamHandler.setStreamHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStreamHandler</span><span class="params">(EventChannel.StreamHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messenger.setMessageHandler(<span class="keyword">this</span>.name, handler == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> EventChannel.IncomingStreamRequestHandler(handler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置setStreamHandler方法，用了一个IncomingStreamRequestHandler包装StreamHandler，IncomingStreamRequestHandler就是BinaryMessengerHandler类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BinaryReply</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UiThread</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reply</span><span class="params">(@Nullable ByteBuffer var1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BinaryMessageHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UiThread</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(@Nullable ByteBuffer var1, @NonNull BinaryMessenger.BinaryReply var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BinaryMessageHandler就一个方法onMessage,接收消息的方法，原始数据是ByteBuffer类型，另一个参数BinaryReply接口,可以回调回复一个ByteBuffer的消息。</p><p>IncomingStreamRequestHandler代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IncomingStreamRequestHandler</span> <span class="keyword">implements</span> <span class="title">BinaryMessageHandler</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> EventChannel.StreamHandler handler;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;EventChannel.EventSink&gt; activeSink = <span class="keyword">new</span> AtomicReference((Object)<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      IncomingStreamRequestHandler(EventChannel.StreamHandler handler) &#123;</span><br><span class="line">          <span class="keyword">this</span>.handler = handler;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(ByteBuffer message, BinaryReply reply)</span> </span>&#123;</span><br><span class="line">          MethodCall call = EventChannel.<span class="keyword">this</span>.codec.decodeMethodCall(message);</span><br><span class="line">          <span class="keyword">if</span> (call.method.equals(<span class="string">"listen"</span>)) &#123;</span><br><span class="line">              <span class="keyword">this</span>.onListen(call.arguments, reply);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (call.method.equals(<span class="string">"cancel"</span>)) &#123;</span><br><span class="line">              <span class="keyword">this</span>.onCancel(call.arguments, reply);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              reply.reply((ByteBuffer)<span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onListen</span><span class="params">(Object arguments, BinaryReply callback)</span> </span>&#123;</span><br><span class="line">          EventChannel.EventSink eventSink = <span class="keyword">new</span> EventChannel.IncomingStreamRequestHandler.EventSinkImplementation();</span><br><span class="line">          EventChannel.EventSink oldSink = (EventChannel.EventSink)<span class="keyword">this</span>.activeSink.getAndSet(eventSink);</span><br><span class="line">          <span class="keyword">if</span> (oldSink != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">this</span>.handler.onCancel((Object)<span class="keyword">null</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (RuntimeException var7) &#123;</span><br><span class="line">                  Log.e(<span class="string">"EventChannel#"</span> + EventChannel.<span class="keyword">this</span>.name, <span class="string">"Failed to close existing event stream"</span>, var7);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.handler.onListen(arguments, eventSink);</span><br><span class="line">              callback.reply(EventChannel.<span class="keyword">this</span>.codec.encodeSuccessEnvelope((Object)<span class="keyword">null</span>));</span><br><span class="line">          &#125; <span class="keyword">catch</span> (RuntimeException var6) &#123;</span><br><span class="line">              <span class="keyword">this</span>.activeSink.set((Object)<span class="keyword">null</span>);</span><br><span class="line">              Log.e(<span class="string">"EventChannel#"</span> + EventChannel.<span class="keyword">this</span>.name, <span class="string">"Failed to open event stream"</span>, var6);</span><br><span class="line">              callback.reply(EventChannel.<span class="keyword">this</span>.codec.encodeErrorEnvelope(<span class="string">"error"</span>, var6.getMessage(), (Object)<span class="keyword">null</span>));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onCancel</span><span class="params">(Object arguments, BinaryReply callback)</span> </span>&#123;</span><br><span class="line">          EventChannel.EventSink oldSink = (EventChannel.EventSink)<span class="keyword">this</span>.activeSink.getAndSet((Object)<span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (oldSink != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">this</span>.handler.onCancel(arguments);</span><br><span class="line">                  callback.reply(EventChannel.<span class="keyword">this</span>.codec.encodeSuccessEnvelope((Object)<span class="keyword">null</span>));</span><br><span class="line">              &#125; <span class="keyword">catch</span> (RuntimeException var5) &#123;</span><br><span class="line">                  Log.e(<span class="string">"EventChannel#"</span> + EventChannel.<span class="keyword">this</span>.name, <span class="string">"Failed to close event stream"</span>, var5);</span><br><span class="line">                  callback.reply(EventChannel.<span class="keyword">this</span>.codec.encodeErrorEnvelope(<span class="string">"error"</span>, var5.getMessage(), (Object)<span class="keyword">null</span>));</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              callback.reply(EventChannel.<span class="keyword">this</span>.codec.encodeErrorEnvelope(<span class="string">"error"</span>, <span class="string">"No active stream to cancel"</span>, (Object)<span class="keyword">null</span>));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>onMessage分发下去三个方法，开始监听和取消监听，名称不对就立即回复空消息。<br>onListen中创建EventChannel.EventSink，并回调给EventChannel.StreamHandler，就是我们自己写的继承方法了，然后在reply回复操作成功，可以看出每个消息都必须有回复。</p><h3 id="事件调用流程"><a href="#事件调用流程" class="headerlink" title="事件调用流程"></a>事件调用流程</h3><p>事件调用由EventSink发起，看EventSinkImplementation：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EventSinkImplementation</span> <span class="keyword">implements</span> <span class="title">EventChannel</span>.<span class="title">EventSink</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> AtomicBoolean hasEnded;</span><br><span class="line"></span><br><span class="line">           <span class="function"><span class="keyword">private</span> <span class="title">EventSinkImplementation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">this</span>.hasEnded = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@UiThread</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (!<span class="keyword">this</span>.hasEnded.get() &amp;&amp; IncomingStreamRequestHandler.<span class="keyword">this</span>.activeSink.get() == <span class="keyword">this</span>) &#123;</span><br><span class="line">                   EventChannel.<span class="keyword">this</span>.messenger.send(EventChannel.<span class="keyword">this</span>.name, EventChannel.<span class="keyword">this</span>.codec.encodeSuccessEnvelope(event));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@UiThread</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String errorCode, String errorMessage, Object errorDetails)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (!<span class="keyword">this</span>.hasEnded.get() &amp;&amp; IncomingStreamRequestHandler.<span class="keyword">this</span>.activeSink.get() == <span class="keyword">this</span>) &#123;</span><br><span class="line">                   EventChannel.<span class="keyword">this</span>.messenger.send(EventChannel.<span class="keyword">this</span>.name, EventChannel.<span class="keyword">this</span>.codec.encodeErrorEnvelope(errorCode, errorMessage, errorDetails));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@UiThread</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endOfStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (!<span class="keyword">this</span>.hasEnded.getAndSet(<span class="keyword">true</span>) &amp;&amp; IncomingStreamRequestHandler.<span class="keyword">this</span>.activeSink.get() == <span class="keyword">this</span>) &#123;</span><br><span class="line">                   EventChannel.<span class="keyword">this</span>.messenger.send(EventChannel.<span class="keyword">this</span>.name, (ByteBuffer)<span class="keyword">null</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>所有的事件发送都由BinaryMessenger转发，由MethodCodec编码成ByteBuffer类型数据。<br>BinaryMessenger实际是FlutterView：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String channel, ByteBuffer message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.send(channel, message, (BinaryReply)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String channel, ByteBuffer message, BinaryReply callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isAttached()) &#123;</span><br><span class="line">        Log.d(<span class="string">"FlutterView"</span>, <span class="string">"FlutterView.send called on a detached view, channel="</span> + channel);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mNativeView.send(channel, message, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FlutterNativeView：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String channel, ByteBuffer message, BinaryReply callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isAttached()) &#123;</span><br><span class="line">        Log.d(<span class="string">"FlutterNativeView"</span>, <span class="string">"FlutterView.send called on a detached view, channel="</span> + channel);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.dartExecutor.send(channel, message, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DartExecutor:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(@NonNull String channel, @Nullable ByteBuffer message, @Nullable BinaryReply callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messenger.send(channel, message, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>DartMessenger：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(@NonNull String channel, @NonNull ByteBuffer message)</span> </span>&#123;</span><br><span class="line">    Log.v(<span class="string">"DartMessenger"</span>, <span class="string">"Sending message over channel '"</span> + channel + <span class="string">"'"</span>);</span><br><span class="line">    <span class="keyword">this</span>.send(channel, message, (BinaryReply)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(@NonNull String channel, @Nullable ByteBuffer message, @Nullable BinaryReply callback)</span> </span>&#123;</span><br><span class="line">    Log.v(<span class="string">"DartMessenger"</span>, <span class="string">"Sending message with callback over channel '"</span> + channel + <span class="string">"'"</span>);</span><br><span class="line">    <span class="keyword">int</span> replyId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        replyId = <span class="keyword">this</span>.nextReplyId++;</span><br><span class="line">        <span class="keyword">this</span>.pendingReplies.put(replyId, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (message == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.flutterJNI.dispatchEmptyPlatformMessage(channel, replyId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.flutterJNI.dispatchPlatformMessage(channel, message, message.position(), replyId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DartMessenger设置replayId,直接线性递增计数，BinaryReply会保存在map结构pendingReplies中，replyId和BinaryReply一一绑定。</p><p>EventChannel是单向通信，不需要BinaryReply，可以猜测MethodChannel和BaseMessageChannel需要用到BinaryReply，BinaryReply在哪里创建的呢？</p><p>DratMessage接受消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessageFromDart</span><span class="params">(@NonNull String channel, @Nullable <span class="keyword">byte</span>[] message, <span class="keyword">int</span> replyId)</span> </span>&#123;</span><br><span class="line">    Log.v(<span class="string">"DartMessenger"</span>, <span class="string">"Received message from Dart over channel '"</span> + channel + <span class="string">"'"</span>);</span><br><span class="line">    BinaryMessageHandler handler = (BinaryMessageHandler)<span class="keyword">this</span>.messageHandlers.get(channel);</span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Log.v(<span class="string">"DartMessenger"</span>, <span class="string">"Deferring to registered handler to process message."</span>);</span><br><span class="line">            ByteBuffer buffer = message == <span class="keyword">null</span> ? <span class="keyword">null</span> : ByteBuffer.wrap(message);</span><br><span class="line">            handler.onMessage(buffer, <span class="keyword">new</span> DartMessenger.Reply(<span class="keyword">this</span>.flutterJNI, replyId));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var6) &#123;</span><br><span class="line">            Log.e(<span class="string">"DartMessenger"</span>, <span class="string">"Uncaught exception in binary message listener"</span>, var6);</span><br><span class="line">            <span class="keyword">this</span>.flutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.v(<span class="string">"DartMessenger"</span>, <span class="string">"No registered handler for message. Responding to Dart with empty reply message."</span>);</span><br><span class="line">        <span class="keyword">this</span>.flutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePlatformMessageResponse</span><span class="params">(<span class="keyword">int</span> replyId, @Nullable <span class="keyword">byte</span>[] reply)</span> </span>&#123;</span><br><span class="line">    Log.v(<span class="string">"DartMessenger"</span>, <span class="string">"Received message reply from Dart."</span>);</span><br><span class="line">    BinaryReply callback = (BinaryReply)<span class="keyword">this</span>.pendingReplies.remove(replyId);</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Log.v(<span class="string">"DartMessenger"</span>, <span class="string">"Invoking registered callback for reply from Dart."</span>);</span><br><span class="line">            callback.reply(reply == <span class="keyword">null</span> ? <span class="keyword">null</span> : ByteBuffer.wrap(reply));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            Log.e(<span class="string">"DartMessenger"</span>, <span class="string">"Uncaught exception in binary message reply handler"</span>, var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接受dart消息时会创建DartMessenger.Reply，然后回调给BinaryMessageHandler。处理回调消息时根据replayId移除BinaryReply，然后再回调reply方法，所以reply是能且仅能调用一次。</p><p>Reply代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reply</span> <span class="keyword">implements</span> <span class="title">BinaryReply</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FlutterJNI flutterJNI;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> replyId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean done = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Reply(<span class="meta">@NonNull</span> FlutterJNI flutterJNI, <span class="keyword">int</span> replyId) &#123;</span><br><span class="line">        <span class="keyword">this</span>.flutterJNI = flutterJNI;</span><br><span class="line">        <span class="keyword">this</span>.replyId = replyId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reply</span><span class="params">(@Nullable ByteBuffer reply)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.done.getAndSet(<span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Reply already submitted"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reply == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.flutterJNI.invokePlatformMessageEmptyResponseCallback(<span class="keyword">this</span>.replyId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.flutterJNI.invokePlatformMessageResponseCallback(<span class="keyword">this</span>.replyId, reply, reply.position());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过AtomicBoolean使reply只能调用一次，多次调用会抛出”Reply already submitted”异常。</p><p>FlutterJNI：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchPlatformMessage</span><span class="params">(@NonNull String channel, @Nullable ByteBuffer message, <span class="keyword">int</span> position, <span class="keyword">int</span> responseId)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.ensureRunningOnMainThread();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isAttached()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.nativeDispatchPlatformMessage(<span class="keyword">this</span>.nativePlatformViewId, channel, message, position, responseId);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Log.w(<span class="string">"FlutterJNI"</span>, <span class="string">"Tried to send a platform message to Flutter, but FlutterJNI was detached from native C++. Could not send. Channel: "</span> + channel + <span class="string">". Response ID: "</span> + responseId);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeDispatchPlatformMessage</span><span class="params">(<span class="keyword">long</span> var1, @NonNull String var3, @Nullable ByteBuffer var4, <span class="keyword">int</span> var5, <span class="keyword">int</span> var6)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called by native.</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePlatformMessage</span><span class="params">(@NonNull <span class="keyword">final</span> String channel, <span class="keyword">byte</span>[] message, <span class="keyword">final</span> <span class="keyword">int</span> replyId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (platformMessageHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    platformMessageHandler.handleMessageFromDart(channel, message, replyId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到通过层层转调后到native方法nativeDispatchPlatformMessage，参数分别是还是channel名称，ByteBuffer数据，数据长度，回答id。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每个消息都有一个来回的传递，完成一个闭环。先分析从dart到android的调用，EventChannel的启动监听就是一个（BasicMessageChannel的dart消息，MethodChannel的方法调用也是），我们分析其流程：</p><p>1.Dart调用listen方法通过 Platform Channel 机制调用到FlutterJNI的handlePlatformMessage，并随赠一个replyId<br>2.FlutterJNI调用DartMessenger的handleMessageFromDart<br>3.DartMessenger创建reply并转发到BinaryMessageHandler<br>4.IncomingStreamRequestHandler接受到listen消息创建EventSink，reply回复成功或者失败<br>5.Reply通过FlutterJNI回复消息给Platform Channel，对应之前的replyId</p><p>EventChannel发送消息不需要回复，MethodChannel不能发送消息（只能接受方法调用然后回复），BasicMessageChannel可以发送消息并等待回复，分析其流程：</p><p>1.BasicMessageChannel发送消息,需要回调就创建一个IncomingReplyHandler的BinaryReply<br>2.FlutterView发送消息，层层向下转发到DartMessenger<br>3.DartMessenger发送消息，有BinaryReply就replyId自增并绑定BinaryReply到map中<br>4.flutterJNI发送消息到Platform Channel并随带replyId<br>5.Dart层回复通过Platform Channel调用到FlutterJNI的handlePlatformMessageResponse返回replyId<br>6.DartMessenger收到消息回复则移除replyId，调用BinaryReply的回复方法</p><p>两套流程里面都有replyId，但两者却是不冲突的，replyId由发送者创建，每次通信都有方向，只能回复一次，所以不会有id冲突问题。android发送的replyId和dart发送的replyId可以一样，但底层知道方向，维持了两套，不会冲突。</p>]]></content>
    
    <summary type="html">
    
      Flutter与native三种通信方式的使用与数据传递解析
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://anddymao.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Activity启动与StartingWindow流程深入解析</title>
    <link href="http://anddymao.com/2019/11/02/2019-11-2-Activity%E5%90%AF%E5%8A%A8%E4%B8%8EStartingWindow/"/>
    <id>http://anddymao.com/2019/11/02/2019-11-2-Activity启动与StartingWindow/</id>
    <published>2019-11-02T06:00:00.000Z</published>
    <updated>2020-01-19T02:36:48.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>Starting Window就是一个用于在Activity创建并初始化成功前显示的临时窗口，拥有的Window Type是TYPE_APPLICATION_STARTING。<br>在startActivity，从而能够立即响应，当activity显示第一帧后会移除这个窗口。</p><p>设置windowDisablePreview属性可以控制Starting Window是否显示，默认是开启，Starting Window样式根据activity的主题生成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name=<span class="string">"android:windowDisablePreview"</span>&gt;<span class="literal">true</span>&lt;/item&gt;</span><br></pre></td></tr></table></figure><p>Starting Window是每个Activity都可以设置的，默认的黑或者白其实就是startWindow，比如从Activity A启动Activity B，A执行onPause后界面就会进入Starting Window了，<br>此时B的onCreate可能都还没执行，直到B的第一帧显示出来后Starting Window才会消失。所以在onCreate改变主题没法影响到startWindow。</p><h2 id="Activity启动流程"><a href="#Activity启动流程" class="headerlink" title="Activity启动流程"></a>Activity启动流程</h2><p>我基于android-28源码分析下整个流程。</p><h3 id="应用启动AMS"><a href="#应用启动AMS" class="headerlink" title="应用启动AMS"></a>应用启动AMS</h3><p>Activity启动流程，首先在应用进程调用startActivity方法，然后调用到Instrumentation，Instrumentation再调用到AMS,我们看下Instrumentation:execStartActivity方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">         Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">     IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">     Uri referrer = target != <span class="keyword">null</span> ? target.onProvideReferrer() : <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> (referrer != <span class="keyword">null</span>) &#123;</span><br><span class="line">         intent.putExtra(Intent.EXTRA_REFERRER, referrer);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (mActivityMonitors != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">int</span> N = mActivityMonitors.size();</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                 <span class="keyword">final</span> ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                 ActivityResult result = <span class="keyword">null</span>;</span><br><span class="line">                 <span class="keyword">if</span> (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class="line">                     result = am.onStartActivity(intent);</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     am.mHits++;</span><br><span class="line">                     <span class="keyword">return</span> result;</span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (am.match(who, <span class="keyword">null</span>, intent)) &#123;</span><br><span class="line">                     am.mHits++;</span><br><span class="line">                     <span class="keyword">if</span> (am.isBlocking()) &#123;</span><br><span class="line">                         <span class="keyword">return</span> requestCode &gt;= <span class="number">0</span> ? am.getResult() : <span class="keyword">null</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         intent.migrateExtraStreamToClipData();</span><br><span class="line">         intent.prepareToLeaveProcess(who);</span><br><span class="line">         <span class="keyword">int</span> result = ActivityManager.getService()</span><br><span class="line">             .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                     intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                     token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                     requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">         checkStartActivityResult(result, intent);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>ActivityManager.getService()获取到IActivityManager的binder引用，然后执行binder方法startActivity，checkStartActivityResult处理返回结果，启动失败都是在这处理的，常见如permission和class not found问题。</p><h3 id="AMS启动Activity"><a href="#AMS启动Activity" class="headerlink" title="AMS启动Activity"></a>AMS启动Activity</h3><h4 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h4><p>ActivityManagerService的startActivity方法会调用startActivityAsUser，startActivityAsUser代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line"></span><br><span class="line">    userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), <span class="string">"startActivityAsUser"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">    <span class="keyword">return</span> mActivityStartController.obtainStarter(intent, <span class="string">"startActivityAsUser"</span>)</span><br><span class="line">            .setCaller(caller)</span><br><span class="line">            .setCallingPackage(callingPackage)</span><br><span class="line">            .setResolvedType(resolvedType)</span><br><span class="line">            .setResultTo(resultTo)</span><br><span class="line">            .setResultWho(resultWho)</span><br><span class="line">            .setRequestCode(requestCode)</span><br><span class="line">            .setStartFlags(startFlags)</span><br><span class="line">            .setProfilerInfo(profilerInfo)</span><br><span class="line">            .setActivityOptions(bOptions)</span><br><span class="line">            .setMayWait(userId)</span><br><span class="line">            .execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ActivityStarter"><a href="#ActivityStarter" class="headerlink" title="ActivityStarter"></a>ActivityStarter</h4><p>ActivityManagerService通过控制器ActivityStartController设置参数最后执行ActivityStarter的execute方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TODO(b/64750076): Look into passing request directly to these methods to allow</span></span><br><span class="line">        <span class="comment">// for transactional diffs and preprocessing.</span></span><br><span class="line">        <span class="keyword">if</span> (mRequest.mayWait) &#123;</span><br><span class="line">            <span class="keyword">return</span> startActivityMayWait(mRequest.caller, mRequest.callingUid,</span><br><span class="line">                    mRequest.callingPackage, mRequest.intent, mRequest.resolvedType,</span><br><span class="line">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                    mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,</span><br><span class="line">                    mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,</span><br><span class="line">                    mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,</span><br><span class="line">                    mRequest.inTask, mRequest.reason,</span><br><span class="line">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,</span><br><span class="line">                    mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,</span><br><span class="line">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                    mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,</span><br><span class="line">                    mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,</span><br><span class="line">                    mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,</span><br><span class="line">                    mRequest.ignoreTargetSecurity, mRequest.componentSpecified,</span><br><span class="line">                    mRequest.outActivity, mRequest.inTask, mRequest.reason,</span><br><span class="line">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        onExecutionComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>execute调用startActivityMayWait或者startActivity，这两个方法最后都会调用到startActivityUnchecked。</p><p>startActivityUnchecked获取到Activity的信息ActivityRecord，ActivityRecord是activity历史栈中的一个节点，代表一个activity.<br>startActivityUnchecked再调用到ActivityStackSupervisor的resumeFocusedStackTopActivityLocked方法。</p><h4 id="ActivityStack和ActivityStackSupervisor"><a href="#ActivityStack和ActivityStackSupervisor" class="headerlink" title="ActivityStack和ActivityStackSupervisor"></a>ActivityStack和ActivityStackSupervisor</h4><p>ActivityStack是activity的栈，ActivityStackSupervisor是ActivityStack的监督者，核心调用转到了ActivityStackSupervisor实现，里面调用顺序如下：</p><p>ActivityStackSupervisor： resumeFocusedStackTopActivityLocked<br>ActivityStack: resumeTopActivityUncheckedLocked<br>ActivityStackSupervisor: resumeTopActivityInnerLocked<br>ActivityStackSupervisor: startSpecificActivityLocked<br>ActivityStackSupervisor: realStartActivityLocked</p><p>realStartActivityLocked就是真正启动activity的地方了，里面调用到了LaunchActivityItem，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,</span><br><span class="line">          r.appToken);</span><br><span class="line">  clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="keyword">new</span> Intent(r.intent),</span><br><span class="line">          System.identityHashCode(r), r.info,</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Have this take the merged configuration instead of separate global</span></span><br><span class="line">          <span class="comment">// and override configs.</span></span><br><span class="line">          mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">          mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">          r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">          r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class="line">          profilerInfo));</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// Schedule transaction.</span></span><br><span class="line">   mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br></pre></td></tr></table></figure><p>clientTransaction添加了一个LaunchActivityItem的事务，LaunchActivityItem留待后续再详解。</p><h4 id="ClientTransaction事务传递"><a href="#ClientTransaction事务传递" class="headerlink" title="ClientTransaction事务传递"></a>ClientTransaction事务传递</h4><p>ClientLifecycleManager的scheduleTransaction方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IApplicationThread client = transaction.getClient();</span><br><span class="line">    transaction.schedule();</span><br><span class="line">    <span class="keyword">if</span> (!(client <span class="keyword">instanceof</span> Binder)) &#123;</span><br><span class="line">        <span class="comment">// If client is not an instance of Binder - it's a remote call and at this point it is</span></span><br><span class="line">        <span class="comment">// safe to recycle the object. All objects used for local calls will be recycled after</span></span><br><span class="line">        <span class="comment">// the transaction is executed on client in ActivityThread.</span></span><br><span class="line">        transaction.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClientTransaction的schedule方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mClient.scheduleTransaction(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ApplicationThread的scheduleTransaction方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ActivityThread.<span class="keyword">this</span>.scheduleTransaction(transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ClientTransaction的scheduleTransaction方法,层层调用下来，调用到mClient的scheduleTransaction，mClient是IApplicationThread类型，IApplicationThread是一个控制接口，android.app.IApplicationThread.Stub继承Binder并实现IApplicationThread，<br>最后又被ActivityThread中的ApplicationThread实现。这是一个binder方法，调用到了应用进程，执行ApplicationThread的scheduleTransaction方法。</p><h3 id="用户进程ActivityThread启动Activity"><a href="#用户进程ActivityThread启动Activity" class="headerlink" title="用户进程ActivityThread启动Activity"></a>用户进程ActivityThread启动Activity</h3><h4 id="scheduleTransaction"><a href="#scheduleTransaction" class="headerlink" title="scheduleTransaction"></a>scheduleTransaction</h4><p>ActivityThread的scheduleTransaction方法，实际在父类ClientTransactionHandler中，发送一个消息执行事务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    transaction.preExecute(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.sendMessage(<span class="number">159</span>, transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在H（handler）中被执行，这里到了应用主线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">159</span>:</span><br><span class="line">     ClientTransaction transaction = (ClientTransaction)msg.obj;</span><br><span class="line">     ActivityThread.<span class="keyword">this</span>.mTransactionExecutor.execute(transaction);</span><br><span class="line">     <span class="keyword">if</span> (ActivityThread.isSystem()) &#123;</span><br><span class="line">         transaction.recycle();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h4 id="ClientTransaction事务"><a href="#ClientTransaction事务" class="headerlink" title="ClientTransaction事务"></a>ClientTransaction事务</h4><p>这里有个execute方法，事务执行器启动了事务。这个就是之前被添加的LaunchActivityItem，看其execute方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class="line">            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">            mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">            mProfilerInfo, client);</span><br><span class="line">    client.handleLaunchActivity(r, pendingActions, <span class="keyword">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道ClientTransactionHandler的实现就是ActivityThread，这个事务处理已经在用户主线程了，看对应handleLaunchActivity方法。</p><h4 id="activity创建"><a href="#activity创建" class="headerlink" title="activity创建"></a>activity创建</h4><p>ActivityThread的handleLaunchActivity方法，进行窗口和配置的初始化，然后调用performLaunchActivity。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">handleLaunchActivity</span><span class="params">(ActivityThread.ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.unscheduleGcIdler();</span><br><span class="line">    <span class="keyword">this</span>.mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (r.profilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">        <span class="keyword">this</span>.mProfiler.startProfiling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleConfigurationChanged((Configuration)<span class="keyword">null</span>, (CompatibilityInfo)<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ThreadedRenderer.sRendererDisabled) &#123;</span><br><span class="line">        GraphicsEnvironment.earlyInitEGL();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line">    Activity a = <span class="keyword">this</span>.performLaunchActivity(r, customIntent);</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> Configuration(<span class="keyword">this</span>.mConfiguration);</span><br><span class="line">        <span class="keyword">this</span>.reportSizeConfigurations(r);</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; pendingActions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pendingActions.setOldState(r.state);</span><br><span class="line">            pendingActions.setRestoreInstanceState(<span class="keyword">true</span>);</span><br><span class="line">            pendingActions.setCallOnPostCreate(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManager.getService().finishActivity(r.token, <span class="number">0</span>, (Intent)<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var6.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>performLaunchActivity获取到了classloader，然后调用mInstrumentation.newActivity创建activity：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityThread.ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">       ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">       <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">           r.packageInfo = <span class="keyword">this</span>.getPackageInfo((ApplicationInfo)aInfo.applicationInfo, r.compatInfo, <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ComponentName component = r.intent.getComponent();</span><br><span class="line">       <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">           component = r.intent.resolveActivity(<span class="keyword">this</span>.mInitialApplication.getPackageManager());</span><br><span class="line">           r.intent.setComponent(component);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">           component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ContextImpl appContext = <span class="keyword">this</span>.createBaseContextForActivity(r);</span><br><span class="line">       Activity activity = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">           activity = <span class="keyword">this</span>.mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class="line">           StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">           r.intent.setExtrasClassLoader(cl);</span><br><span class="line">           r.intent.prepareToEnterProcess();</span><br><span class="line">           <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">               r.state.setClassLoader(cl);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception var14) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.mInstrumentation.onException(activity, var14)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to instantiate activity "</span> + component + <span class="string">": "</span> + var14.toString(), var14);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, <span class="keyword">this</span>.mInstrumentation);</span><br><span class="line">           <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">               CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">               Configuration config = <span class="keyword">new</span> Configuration(<span class="keyword">this</span>.mCompatConfiguration);</span><br><span class="line">               <span class="keyword">if</span> (r.overrideConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   config.updateFrom(r.overrideConfig);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               Window window = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                   window = r.mPendingRemoveWindow;</span><br><span class="line">                   r.mPendingRemoveWindow = <span class="keyword">null</span>;</span><br><span class="line">                   r.mPendingRemoveWindowManager = <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               appContext.setOuterContext(activity);</span><br><span class="line">               activity.attach(appContext, <span class="keyword">this</span>, <span class="keyword">this</span>.getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line">               <span class="keyword">if</span> (customIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   activity.mIntent = customIntent;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               r.lastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">this</span>.checkAndBlockForNetworkAccess();</span><br><span class="line">               activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">               <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                   activity.setTheme(theme);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">this</span>.mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Activity "</span> + r.intent.getComponent().toShortString() + <span class="string">" did not call through to super.onCreate()"</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               r.activity = activity;</span><br><span class="line">               r.stopped = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                   activity.performStart();</span><br><span class="line">                   r.stopped = <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (r.state != <span class="keyword">null</span> || r.persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">this</span>.mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                   activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">this</span>.mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Activity "</span> + r.intent.getComponent().toShortString() + <span class="string">" did not call through to super.onPostCreate()"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           r.paused = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">this</span>.mActivities.put(r.token, r);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SuperNotCalledException var12) &#123;</span><br><span class="line">           <span class="keyword">throw</span> var12;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception var13) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.mInstrumentation.onException(activity, var13)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to start activity "</span> + component + <span class="string">": "</span> + var13.toString(), var13);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> activity;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Instrumentation创建activity：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className, Intent intent)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Activity)cl.loadClass(className).newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>应用启动activity<br>1.Activity:startActivityForResult<br>2.Instrumentation:execStartActivity<br>3.ActivityManagerService:startActivity</p><p>AMS启动Activity<br>1.ActivityManagerService:startActivity AMS检查用户信息调用到Activity启动器<br>2.ActivityStarter:startActivityUnchecked Activity启动器获取到activity栈等信息，设置一些状态<br>3.ActivityStackSupervisor：realStartActivityLocked添加使用LaunchActivityItem事务并使用IApplicationThread安排进计划</p><p>ActivityThread创建Activity<br>1.ActivityThread:scheduleTransaction安排事务，发送一个消息给handler<br>2.ActivityThread在Handler主线程中执行事务，即LaunchActivityItem的execute方法<br>3.ActivityThread：handleLaunchActivity到performLaunchActivity获取classloader，创建window<br>4.Instrumentation的newActivity通过classloader加载activity类</p><h2 id="Starting-Window-流程"><a href="#Starting-Window-流程" class="headerlink" title="Starting Window 流程"></a>Starting Window 流程</h2><h3 id="Starting-Window显示"><a href="#Starting-Window显示" class="headerlink" title="Starting Window显示"></a>Starting Window显示</h3><h4 id="调用入口"><a href="#调用入口" class="headerlink" title="调用入口"></a>调用入口</h4><p>Starting Window是启动activity立即显示的，所以在AMS启动activity中被创建的，果然在ActivityStarter找到了对应方法。</p><p>ActivityStarter调用startActivityUnchecked时会调用setTargetStackAndMoveToFrontIfNeeded：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Figure out which task and activity to bring to front when we have found an existing matching</span></span><br><span class="line"><span class="comment"> * activity record in history. May also clear the task if needed.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> intentActivity Existing matching activity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> ActivityRecord&#125; brought to front.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ActivityRecord <span class="title">setTargetStackAndMoveToFrontIfNeeded</span><span class="params">(ActivityRecord intentActivity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">      intentActivity.showStartingWindow(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="keyword">false</span> <span class="comment">/* newTask */</span>,</span><br><span class="line">                        <span class="keyword">true</span> <span class="comment">/* taskSwitch */</span>);</span><br><span class="line">                        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是已经有activity存在时恢复activity调用的，恢复前会调用showStartingWindow显示StartingWindow。</p><p>又在resumeTopActivityInnerLocked和moveTaskToFrontLocked等处找到了showStartingWindow的调用。<br>resumeTopActivityInnerLocked是前面正常启动activity的步骤，moveTaskToFrontLocked应该是把activity移到前台的调用，<br>都是activity回到前台时需要，符合我们的理解。</p><p>ActivityRecord的showStartingWindow方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showStartingWindow</span><span class="params">(ActivityRecord prev, <span class="keyword">boolean</span> newTask, <span class="keyword">boolean</span> taskSwitch,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> fromRecents)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mWindowContainerController == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mTaskOverlay) &#123;</span><br><span class="line">        <span class="comment">// We don't show starting window for overlay activities.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> CompatibilityInfo compatInfo =</span><br><span class="line">            service.compatibilityInfoForPackageLocked(info.applicationInfo);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shown = mWindowContainerController.addStartingWindow(packageName, theme,</span><br><span class="line">            compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags,</span><br><span class="line">            prev != <span class="keyword">null</span> ? prev.appToken : <span class="keyword">null</span>, newTask, taskSwitch, isProcessRunning(),</span><br><span class="line">            allowTaskSnapshot(),</span><br><span class="line">            mState.ordinal() &gt;= RESUMED.ordinal() &amp;&amp; mState.ordinal() &lt;= STOPPED.ordinal(),</span><br><span class="line">            fromRecents);</span><br><span class="line">    <span class="keyword">if</span> (shown) &#123;</span><br><span class="line">        mStartingWindowState = STARTING_WINDOW_SHOWN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断主题是否添加"><a href="#判断主题是否添加" class="headerlink" title="判断主题是否添加"></a>判断主题是否添加</h4><p>mWindowContainerController.addStartingWindow，<br>这里获取了主题样式，判断是否要显示starting window，如果是透明或者是窗口模式等等就不会显示，之前讲的windowDisablePreview熟悉也是在这里获取，不可用就直接false，最后调用scheduleAddStartingWindow。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addStartingWindow</span><span class="params">(String pkg, <span class="keyword">int</span> theme, CompatibilityInfo compatInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">         CharSequence nonLocalizedLabel, <span class="keyword">int</span> labelRes, <span class="keyword">int</span> icon, <span class="keyword">int</span> logo, <span class="keyword">int</span> windowFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">         IBinder transferFrom, <span class="keyword">boolean</span> newTask, <span class="keyword">boolean</span> taskSwitch, <span class="keyword">boolean</span> processRunning,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">boolean</span> allowTaskSnapshot, <span class="keyword">boolean</span> activityCreated, <span class="keyword">boolean</span> fromRecents)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">         <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"setAppStartingWindow: token="</span> + mToken</span><br><span class="line">                 + <span class="string">" pkg="</span> + pkg + <span class="string">" transferFrom="</span> + transferFrom + <span class="string">" newTask="</span> + newTask</span><br><span class="line">                 + <span class="string">" taskSwitch="</span> + taskSwitch + <span class="string">" processRunning="</span> + processRunning</span><br><span class="line">                 + <span class="string">" allowTaskSnapshot="</span> + allowTaskSnapshot);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (mContainer == <span class="keyword">null</span>) &#123;</span><br><span class="line">             Slog.w(TAG_WM, <span class="string">"Attempted to set icon of non-existing app token: "</span> + mToken);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// If the display is frozen, we won't do anything until the actual window is</span></span><br><span class="line">         <span class="comment">// displayed so there is no reason to put in the starting window.</span></span><br><span class="line">         <span class="keyword">if</span> (!mContainer.okToDisplay()) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (mContainer.startingData != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">final</span> WindowState mainWin = mContainer.findMainWindow();</span><br><span class="line">         <span class="keyword">if</span> (mainWin != <span class="keyword">null</span> &amp;&amp; mainWin.mWinAnimator.getShown()) &#123;</span><br><span class="line">             <span class="comment">// App already has a visible window...why would you want a starting window?</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">final</span> TaskSnapshot snapshot = mService.mTaskSnapshotController.getSnapshot(</span><br><span class="line">                 mContainer.getTask().mTaskId, mContainer.getTask().mUserId,</span><br><span class="line">                 <span class="keyword">false</span> <span class="comment">/* restoreFromDisk */</span>, <span class="keyword">false</span> <span class="comment">/* reducedResolution */</span>);</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> type = getStartingWindowType(newTask, taskSwitch, processRunning,</span><br><span class="line">                 allowTaskSnapshot, activityCreated, fromRecents, snapshot);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (type == STARTING_WINDOW_TYPE_SNAPSHOT) &#123;</span><br><span class="line">             <span class="keyword">return</span> createSnapshot(snapshot);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// If this is a translucent window, then don't show a starting window -- the current</span></span><br><span class="line">         <span class="comment">// effect (a full-screen opaque starting window that fades away to the real contents</span></span><br><span class="line">         <span class="comment">// when it is ready) does not work for this.</span></span><br><span class="line">         <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"Checking theme of starting window: 0x"</span></span><br><span class="line">                 + Integer.toHexString(theme));</span><br><span class="line">         <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">             AttributeCache.Entry ent = AttributeCache.instance().get(pkg, theme,</span><br><span class="line">                     com.android.internal.R.styleable.Window, mService.mCurrentUserId);</span><br><span class="line">             <span class="keyword">if</span> (ent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// Whoops!  App doesn't exist. Um. Okay. We'll just pretend like we didn't</span></span><br><span class="line">                 <span class="comment">// see that.</span></span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">boolean</span> windowIsTranslucent = ent.array.getBoolean(</span><br><span class="line">                     com.android.internal.R.styleable.Window_windowIsTranslucent, <span class="keyword">false</span>);</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">boolean</span> windowIsFloating = ent.array.getBoolean(</span><br><span class="line">                     com.android.internal.R.styleable.Window_windowIsFloating, <span class="keyword">false</span>);</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">boolean</span> windowShowWallpaper = ent.array.getBoolean(</span><br><span class="line">                     com.android.internal.R.styleable.Window_windowShowWallpaper, <span class="keyword">false</span>);</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">boolean</span> windowDisableStarting = ent.array.getBoolean(</span><br><span class="line">                     com.android.internal.R.styleable.Window_windowDisablePreview, <span class="keyword">false</span>);</span><br><span class="line">             <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"Translucent="</span> + windowIsTranslucent</span><br><span class="line">                     + <span class="string">" Floating="</span> + windowIsFloating</span><br><span class="line">                     + <span class="string">" ShowWallpaper="</span> + windowShowWallpaper);</span><br><span class="line">             <span class="keyword">if</span> (windowIsTranslucent) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (windowIsFloating || windowDisableStarting) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (windowShowWallpaper) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (mContainer.getDisplayContent().mWallpaperController.getWallpaperTarget()</span><br><span class="line">                         == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// If this theme is requesting a wallpaper, and the wallpaper</span></span><br><span class="line">                     <span class="comment">// is not currently visible, then this effectively serves as</span></span><br><span class="line">                     <span class="comment">// an opaque window and our starting window transition animation</span></span><br><span class="line">                     <span class="comment">// can still work.  We just need to make sure the starting window</span></span><br><span class="line">                     <span class="comment">// is also showing the wallpaper.</span></span><br><span class="line">                     windowFlags |= FLAG_SHOW_WALLPAPER;</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (mContainer.transferStartingWindow(transferFrom)) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// There is no existing starting window, and we don't want to create a splash screen, so</span></span><br><span class="line">         <span class="comment">// that's it!</span></span><br><span class="line">         <span class="keyword">if</span> (type != STARTING_WINDOW_TYPE_SPLASH_SCREEN) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"Creating SplashScreenStartingData"</span>);</span><br><span class="line">         mContainer.startingData = <span class="keyword">new</span> SplashScreenStartingData(mService, pkg, theme,</span><br><span class="line">                 compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags,</span><br><span class="line">                 mContainer.getMergedOverrideConfiguration());</span><br><span class="line">         scheduleAddStartingWindow();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h4><p>scheduleAddStartingWindow有一个动画控制handler，把Starting Windows放到了第一个消息：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">scheduleAddStartingWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// Note: we really want to do sendMessageAtFrontOfQueue() because we</span></span><br><span class="line">         <span class="comment">// want to process the message ASAP, before any other queued</span></span><br><span class="line">         <span class="comment">// messages.</span></span><br><span class="line">         <span class="keyword">if</span> (!mService.mAnimationHandler.hasCallbacks(mAddStartingWindow)) &#123;</span><br><span class="line">             <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"Enqueueing ADD_STARTING"</span>);</span><br><span class="line">             mService.mAnimationHandler.postAtFrontOfQueue(mAddStartingWindow);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">```     </span><br><span class="line"></span><br><span class="line">mAddStartingWindow是一个runnable，mAddStartingWindow创建并添加了surface，如果发现了中断就用surface.remove()移除界面。</span><br><span class="line">```java</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mAddStartingWindow = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> StartingData startingData;</span><br><span class="line">            <span class="keyword">final</span> AppWindowToken container;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (mWindowMap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mContainer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"mContainer was null while trying to"</span></span><br><span class="line">                            + <span class="string">" add starting window"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// There can only be one adding request, silly caller!</span></span><br><span class="line">                mService.mAnimationHandler.removeCallbacks(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                startingData = mContainer.startingData;</span><br><span class="line">                container = mContainer;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (startingData == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Animation has been canceled... do nothing.</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_STARTING_WINDOW)</span><br><span class="line">                    Slog.v(TAG_WM, <span class="string">"startingData was nulled out before handling"</span></span><br><span class="line">                            + <span class="string">" mAddStartingWindow: "</span> + mContainer);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"Add starting "</span></span><br><span class="line">                    + AppWindowContainerController.<span class="keyword">this</span> + <span class="string">": startingData="</span></span><br><span class="line">                    + container.startingData);</span><br><span class="line"></span><br><span class="line">            StartingSurface surface = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                surface = startingData.createStartingSurface(container);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG_WM, <span class="string">"Exception when adding starting window"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (surface != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> abort = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (mWindowMap) &#123;</span><br><span class="line">                    <span class="comment">// If the window was successfully added, then</span></span><br><span class="line">                    <span class="comment">// we need to remove it.</span></span><br><span class="line">                    <span class="keyword">if</span> (container.removed || container.startingData == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM,</span><br><span class="line">                                <span class="string">"Aborted starting "</span> + container</span><br><span class="line">                                        + <span class="string">": removed="</span> + container.removed</span><br><span class="line">                                        + <span class="string">" startingData="</span> + container.startingData);</span><br><span class="line">                        container.startingWindow = <span class="keyword">null</span>;</span><br><span class="line">                        container.startingData = <span class="keyword">null</span>;</span><br><span class="line">                        abort = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        container.startingSurface = surface;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_STARTING_WINDOW &amp;&amp; !abort) Slog.v(TAG_WM,</span><br><span class="line">                            <span class="string">"Added starting "</span> + mContainer</span><br><span class="line">                                    + <span class="string">": startingWindow="</span></span><br><span class="line">                                    + container.startingWindow + <span class="string">" startingView="</span></span><br><span class="line">                                    + container.startingSurface);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (abort) &#123;</span><br><span class="line">                    surface.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) &#123;</span><br><span class="line">                Slog.v(TAG_WM, <span class="string">"Surface returned was null: "</span> + mContainer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>createStartingSurface属于StartingData的虚方法，实现在SplashScreenStartingData中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">StartingSurface <span class="title">createStartingSurface</span><span class="params">(AppWindowToken atoken)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mService.mPolicy.addSplashScreen(atoken.token, mPkg, mTheme, mCompatInfo,</span><br><span class="line">            mNonLocalizedLabel, mLabelRes, mIcon, mLogo, mWindowFlags,</span><br><span class="line">            mMergedOverrideConfiguration, atoken.getDisplayContent().getDisplayId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到PhoneWindowManager的addSplashScreen方法，根据样式添加界面，最后通过熟悉的WindowManager.addView显示在界面上，window的类型是TYPE_APPLICATION_STARTING。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> StartingSurface <span class="title">addSplashScreen</span><span class="params">(IBinder appToken, String packageName, <span class="keyword">int</span> theme,</span></span></span><br><span class="line"><span class="function"><span class="params">         CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, <span class="keyword">int</span> labelRes, <span class="keyword">int</span> icon,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> logo, <span class="keyword">int</span> windowFlags, Configuration overrideConfig, <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!SHOW_SPLASH_SCREENS) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (packageName == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     WindowManager wm = <span class="keyword">null</span>;</span><br><span class="line">     View view = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Context context = mContext;</span><br><span class="line">         <span class="keyword">if</span> (DEBUG_SPLASH_SCREEN) Slog.d(TAG, <span class="string">"addSplashScreen "</span> + packageName</span><br><span class="line">                 + <span class="string">": nonLocalizedLabel="</span> + nonLocalizedLabel + <span class="string">" theme="</span></span><br><span class="line">                 + Integer.toHexString(theme));</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Obtain proper context to launch on the right display.</span></span><br><span class="line">         <span class="keyword">final</span> Context displayContext = getDisplayContext(context, displayId);</span><br><span class="line">         <span class="keyword">if</span> (displayContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// Can't show splash screen on requested display, so skip showing at all.</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         context = displayContext;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (theme != context.getThemeResId() || labelRes != <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 context = context.createPackageContext(packageName, CONTEXT_RESTRICTED);</span><br><span class="line">                 context.setTheme(theme);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">                 <span class="comment">// Ignore</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (overrideConfig != <span class="keyword">null</span> &amp;&amp; !overrideConfig.equals(EMPTY)) &#123;</span><br><span class="line">             <span class="keyword">if</span> (DEBUG_SPLASH_SCREEN) Slog.d(TAG, <span class="string">"addSplashScreen: creating context based"</span></span><br><span class="line">                     + <span class="string">" on overrideConfig"</span> + overrideConfig + <span class="string">" for splash screen"</span>);</span><br><span class="line">             <span class="keyword">final</span> Context overrideContext = context.createConfigurationContext(overrideConfig);</span><br><span class="line">             overrideContext.setTheme(theme);</span><br><span class="line">             <span class="keyword">final</span> TypedArray typedArray = overrideContext.obtainStyledAttributes(</span><br><span class="line">                     com.android.internal.R.styleable.Window);</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">int</span> resId = typedArray.getResourceId(R.styleable.Window_windowBackground, <span class="number">0</span>);</span><br><span class="line">             <span class="keyword">if</span> (resId != <span class="number">0</span> &amp;&amp; overrideContext.getDrawable(resId) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// We want to use the windowBackground for the override context if it is</span></span><br><span class="line">                 <span class="comment">// available, otherwise we use the default one to make sure a themed starting</span></span><br><span class="line">                 <span class="comment">// window is displayed for the app.</span></span><br><span class="line">                 <span class="keyword">if</span> (DEBUG_SPLASH_SCREEN) Slog.d(TAG, <span class="string">"addSplashScreen: apply overrideConfig"</span></span><br><span class="line">                         + overrideConfig + <span class="string">" to starting window resId="</span> + resId);</span><br><span class="line">                 context = overrideContext;</span><br><span class="line">             &#125;</span><br><span class="line">             typedArray.recycle();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">final</span> PhoneWindow win = <span class="keyword">new</span> PhoneWindow(context);</span><br><span class="line">         win.setIsStartingWindow(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">         CharSequence label = context.getResources().getText(labelRes, <span class="keyword">null</span>);</span><br><span class="line">         <span class="comment">// Only change the accessibility title if the label is localized</span></span><br><span class="line">         <span class="keyword">if</span> (label != <span class="keyword">null</span>) &#123;</span><br><span class="line">             win.setTitle(label, <span class="keyword">true</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             win.setTitle(nonLocalizedLabel, <span class="keyword">false</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         win.setType(</span><br><span class="line">             WindowManager.LayoutParams.TYPE_APPLICATION_STARTING);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">synchronized</span> (mWindowManagerFuncs.getWindowManagerLock()) &#123;</span><br><span class="line">             <span class="comment">// Assumes it's safe to show starting windows of launched apps while</span></span><br><span class="line">             <span class="comment">// the keyguard is being hidden. This is okay because starting windows never show</span></span><br><span class="line">             <span class="comment">// secret information.</span></span><br><span class="line">             <span class="keyword">if</span> (mKeyguardOccluded) &#123;</span><br><span class="line">                 windowFlags |= FLAG_SHOW_WHEN_LOCKED;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Force the window flags: this is a fake window, so it is not really</span></span><br><span class="line">         <span class="comment">// touchable or focusable by the user.  We also add in the ALT_FOCUSABLE_IM</span></span><br><span class="line">         <span class="comment">// flag because we do know that the next window will take input</span></span><br><span class="line">         <span class="comment">// focus, so we want to get the IME window up on top of us right away.</span></span><br><span class="line">         win.setFlags(</span><br><span class="line">             windowFlags|</span><br><span class="line">             WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE|</span><br><span class="line">             WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|</span><br><span class="line">             WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,</span><br><span class="line">             windowFlags|</span><br><span class="line">             WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE|</span><br><span class="line">             WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|</span><br><span class="line">             WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);</span><br><span class="line"></span><br><span class="line">         win.setDefaultIcon(icon);</span><br><span class="line">         win.setDefaultLogo(logo);</span><br><span class="line"></span><br><span class="line">         win.setLayout(WindowManager.LayoutParams.MATCH_PARENT,</span><br><span class="line">                 WindowManager.LayoutParams.MATCH_PARENT);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">final</span> WindowManager.LayoutParams params = win.getAttributes();</span><br><span class="line">         params.token = appToken;</span><br><span class="line">         params.packageName = packageName;</span><br><span class="line">         params.windowAnimations = win.getWindowStyle().getResourceId(</span><br><span class="line">                 com.android.internal.R.styleable.Window_windowAnimationStyle, <span class="number">0</span>);</span><br><span class="line">         params.privateFlags |=</span><br><span class="line">                 WindowManager.LayoutParams.PRIVATE_FLAG_FAKE_HARDWARE_ACCELERATED;</span><br><span class="line">         params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (!compatInfo.supportsScreen()) &#123;</span><br><span class="line">             params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         params.setTitle(<span class="string">"Splash Screen "</span> + packageName);</span><br><span class="line">         addSplashscreenContent(win, context);</span><br><span class="line"></span><br><span class="line">         wm = (WindowManager) context.getSystemService(WINDOW_SERVICE);</span><br><span class="line">         view = win.getDecorView();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (DEBUG_SPLASH_SCREEN) Slog.d(TAG, <span class="string">"Adding splash screen window for "</span></span><br><span class="line">             + packageName + <span class="string">" / "</span> + appToken + <span class="string">": "</span> + (view.getParent() != <span class="keyword">null</span> ? view : <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">         wm.addView(view, params);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Only return the view if it was successfully added to the</span></span><br><span class="line">         <span class="comment">// window manager... which we can tell by it having a parent.</span></span><br><span class="line">         <span class="keyword">return</span> view.getParent() != <span class="keyword">null</span> ? <span class="keyword">new</span> SplashScreenSurface(view, appToken) : <span class="keyword">null</span>;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (WindowManager.BadTokenException e) &#123;</span><br><span class="line">         <span class="comment">// ignore</span></span><br><span class="line">         Log.w(TAG, appToken + <span class="string">" already running, starting window not displayed. "</span> +</span><br><span class="line">                 e.getMessage());</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">         <span class="comment">// don't crash if something else bad happens, for example a</span></span><br><span class="line">         <span class="comment">// failure loading resources because we are loading from an app</span></span><br><span class="line">         <span class="comment">// on external storage that has been unmounted.</span></span><br><span class="line">         Log.w(TAG, appToken + <span class="string">" failed creating starting window"</span>, e);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (view != <span class="keyword">null</span> &amp;&amp; view.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">             Log.w(TAG, <span class="string">"view not successfully added to wm, removing view"</span>);</span><br><span class="line">             wm.removeViewImmediate(view);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Starting-Window移除"><a href="#Starting-Window移除" class="headerlink" title="Starting Window移除"></a>Starting Window移除</h3><p>显示第一帧后Starting Window就可以消失了。</p><h4 id="调用入口-1"><a href="#调用入口-1" class="headerlink" title="调用入口"></a>调用入口</h4><p>在AppWindowToken:onFirstWindowDrawn找到了调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onFirstWindowDrawn</span><span class="params">(WindowState win, WindowStateAnimator winAnimator)</span> </span>&#123;</span><br><span class="line">    firstWindowDrawn = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We now have a good window to show, remove dead placeholders</span></span><br><span class="line">    removeDeadWindows();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (startingWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STARTING_WINDOW || DEBUG_ANIM) Slog.v(TAG, <span class="string">"Finish starting "</span></span><br><span class="line">                + win.mToken + <span class="string">": first real window is shown, no animation"</span>);</span><br><span class="line">        <span class="comment">// If this initial window is animating, stop it -- we will do an animation to reveal</span></span><br><span class="line">        <span class="comment">// it from behind the starting window, so there is no need for it to also be doing its</span></span><br><span class="line">        <span class="comment">// own stuff.</span></span><br><span class="line">        win.cancelAnimation();</span><br><span class="line">        <span class="keyword">if</span> (getController() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getController().removeStartingWindow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateReportedVisibilityLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有handleClosingApps，notifyAppStopped等activity异常退出时也需要销毁掉 Starting Window，这里不一一看了，直接看remove流程。</p><h4 id="remove流程"><a href="#remove流程" class="headerlink" title="remove流程"></a>remove流程</h4><p>AppWindowContainerController的removeStartingWindow方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeStartingWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mWindowMap) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mContainer.startingWindow == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (mContainer.startingData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// Starting window has not been added yet, but it is scheduled to be added.</span></span><br><span class="line">                  <span class="comment">// Go ahead and cancel the request.</span></span><br><span class="line">                  <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM,</span><br><span class="line">                          <span class="string">"Clearing startingData for token="</span> + mContainer);</span><br><span class="line">                  mContainer.startingData = <span class="keyword">null</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">final</span> StartingSurface surface;</span><br><span class="line">          <span class="keyword">if</span> (mContainer.startingData != <span class="keyword">null</span>) &#123;</span><br><span class="line">              surface = mContainer.startingSurface;</span><br><span class="line">              mContainer.startingData = <span class="keyword">null</span>;</span><br><span class="line">              mContainer.startingSurface = <span class="keyword">null</span>;</span><br><span class="line">              mContainer.startingWindow = <span class="keyword">null</span>;</span><br><span class="line">              mContainer.startingDisplayed = <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">if</span> (surface == <span class="keyword">null</span> &amp;&amp; DEBUG_STARTING_WINDOW) &#123;</span><br><span class="line">                  Slog.v(TAG_WM, <span class="string">"startingWindow was set but startingSurface==null, couldn't "</span></span><br><span class="line">                          + <span class="string">"remove"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) &#123;</span><br><span class="line">                  Slog.v(TAG_WM, <span class="string">"Tried to remove starting window but startingWindow was null:"</span></span><br><span class="line">                          + mContainer);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"Schedule remove starting "</span> + mContainer</span><br><span class="line">                  + <span class="string">" startingWindow="</span> + mContainer.startingWindow</span><br><span class="line">                  + <span class="string">" startingView="</span> + mContainer.startingSurface);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Use the same thread to remove the window as we used to add it, as otherwise we end up</span></span><br><span class="line">          <span class="comment">// with things in the view hierarchy being called from different threads.</span></span><br><span class="line">          mService.mAnimationHandler.post(() -&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v(TAG_WM, <span class="string">"Removing startingView="</span> + surface);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  surface.remove();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  Slog.w(TAG_WM, <span class="string">"Exception when removing starting window"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>在mAnimationHandler中调用surface.remove()方法，和前面创建时一样。</p><p>StartingSurface的remove方法在SplashScreenSurface实现，直接调用WindowManager的removeView方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplashScreenSurface</span> <span class="keyword">implements</span> <span class="title">StartingSurface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = PhoneWindowManager.TAG;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> View mView;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBinder mAppToken;</span><br><span class="line"></span><br><span class="line">    SplashScreenSurface(View view, IBinder appToken) &#123;</span><br><span class="line">        mView = view;</span><br><span class="line">        mAppToken = appToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SPLASH_SCREEN) Slog.v(TAG, <span class="string">"Removing splash screen window for "</span> + mAppToken + <span class="string">": "</span></span><br><span class="line">                        + <span class="keyword">this</span> + <span class="string">" Callers="</span> + Debug.getCallers(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> WindowManager wm = mView.getContext().getSystemService(WindowManager.class);</span><br><span class="line">        wm.removeView(mView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Starting Window显示<br>时机：AMS找到Activity信息后，创建activity前，直接由AMS进程控制<br>流程：<br>1.AppWindowContainerController:addStartingWindow 控制是否添加<br>2.scheduleAddStartingWindow把mAddStartingWindow放到mAnimationHandler中执行<br>3.SplashScreenStartingData:createStartingSurface创建窗口<br>4.PhoneWindowManager:addSplashScreen通过WMS添加view</p><p>Starting Window消失<br>时机：activity显示第一帧或者activity异常退出<br>流程：<br>1.AppWindowContainerController:removeStartingWindow 如果surface存在则发消息到mAnimationHandler<br>2.mAnimationHandler执行surface.remove();<br>3.SplashScreenSurface的remove方法通过WMS移除view</p>]]></content>
    
    <summary type="html">
    
      从Activity启动流程深入解析Starting Window
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>视频滤镜框架movit介绍与流程解析</title>
    <link href="http://anddymao.com/2019/10/27/2019-10-27-movit/"/>
    <id>http://anddymao.com/2019/10/27/2019-10-27-movit/</id>
    <published>2019-10-27T06:00:00.000Z</published>
    <updated>2020-01-19T02:36:48.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>官方介绍：A library for high-quality, high-performance video filters。<br>一个高质量高性能的视频滤镜框架，采用GNU2协议。</p><p>源码链接：<br><a href="https://git.sesse.net/?p=movit;a=summary" target="_blank" rel="noopener">https://git.sesse.net/?p=movit;a=summary</a></p><p>采用C++编写，官方讲解基本没有，网上信息很少，只能靠源码了解了。</p><h2 id="类定义和结构"><a href="#类定义和结构" class="headerlink" title="类定义和结构"></a>类定义和结构</h2><p>先看make文件Makefile.in：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HDRS = effect_chain.h effect_util.h effect.h input.h image_format.h init.h util.h defs.h resource_pool.h fp16.h ycbcr.h version.h</span><br><span class="line">HDRS += $(INPUTS:=.h)</span><br><span class="line">HDRS += $(EFFECTS:=.h)</span><br></pre></td></tr></table></figure></p><p>这些就是movit的主要流程代码了.Effect_chain为核心，effect为基础单位，输入工具类为辅助，组合成了一个链式结构框架。</p><p>其余都是effect和input各种类型的实例，还有测试代码和着色器代码，可以先忽略。</p><h3 id="Effect"><a href="#Effect" class="headerlink" title="Effect"></a>Effect</h3><p>特效的基本单位，定义了一些公共的方法，对于一个OpenGL程序，需要顶点着色器，片段着色器，传入参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">inform_input_size</span><span class="params">(<span class="keyword">unsigned</span> input_num, <span class="keyword">unsigned</span> width, <span class="keyword">unsigned</span> height)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// How many inputs this effect will take (a fixed number).</span></span><br><span class="line"><span class="comment">// If you have only one input, it will be called INPUT() in GLSL;</span></span><br><span class="line"><span class="comment">// if you have several, they will be INPUT1(), INPUT2(), and so on.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="title">num_inputs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inform the effect that it has been just added to the EffectChain.</span></span><br><span class="line"><span class="comment">// The primary use for this is to store the ResourcePool uesd by</span></span><br><span class="line"><span class="comment">// the chain; for modifications to it, rewrite_graph() below</span></span><br><span class="line"><span class="comment">// is probably a better fit.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">inform_added</span><span class="params">(EffectChain *chain)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let the effect rewrite the effect chain as it sees fit.</span></span><br><span class="line"><span class="comment">// Most effects won't need to do this, but this is very useful</span></span><br><span class="line"><span class="comment">// if you have an effect that consists of multiple sub-effects</span></span><br><span class="line"><span class="comment">// (for instance, two passes). The effect is given to its own</span></span><br><span class="line"><span class="comment">// pointer, and it can add new ones (by using add_node()</span></span><br><span class="line"><span class="comment">// and connect_node()) as it sees fit. This is called at</span></span><br><span class="line"><span class="comment">// EffectChain::finalize() time, when the entire graph is known,</span></span><br><span class="line"><span class="comment">// in the order that the effects were originally added.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that if the effect wants to take itself entirely out</span></span><br><span class="line"><span class="comment">// of the chain, it must set “disabled” to true and then disconnect</span></span><br><span class="line"><span class="comment">// itself from all other effects.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">rewrite_graph</span><span class="params">(EffectChain *graph, Node *self)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the GLSL fragment shader string for this effect.</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">output_fragment_shader</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set all OpenGL state that this effect needs before rendering.</span></span><br><span class="line"><span class="comment">// The default implementation sets one uniform per registered parameter,</span></span><br><span class="line"><span class="comment">// but no other state.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// &lt;sampler_num&gt; is the first free texture sampler. If you want to use</span></span><br><span class="line"><span class="comment">// textures, you can bind a texture to GL_TEXTURE0 + &lt;sampler_num&gt;,</span></span><br><span class="line"><span class="comment">// and then increment the number (so that the next effect in the chain</span></span><br><span class="line"><span class="comment">// will use a different sampler).</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set_gl_state</span><span class="params">(GLuint glsl_program_num, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; prefix, <span class="keyword">unsigned</span> *sampler_num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you set any special OpenGL state in set_gl_state(), you can clear it</span></span><br><span class="line"><span class="comment">// after rendering here. The default implementation does nothing.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">clear_gl_state</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set a parameter; intended to be called from user code.</span></span><br><span class="line"><span class="comment">// Neither of these take ownership of the pointer.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">set_int</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key, <span class="keyword">int</span> value)</span> MUST_CHECK_RESULT</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">set_ivec2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key, <span class="keyword">const</span> <span class="keyword">int</span> *values)</span> MUST_CHECK_RESULT</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">set_float</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key, <span class="keyword">float</span> value)</span> MUST_CHECK_RESULT</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">set_vec2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key, <span class="keyword">const</span> <span class="keyword">float</span> *values)</span> MUST_CHECK_RESULT</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">set_vec3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key, <span class="keyword">const</span> <span class="keyword">float</span> *values)</span> MUST_CHECK_RESULT</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">set_vec4</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key, <span class="keyword">const</span> <span class="keyword">float</span> *values)</span> MUST_CHECK_RESULT</span>;</span><br></pre></td></tr></table></figure><p>rewrite_graph可以重写有向图，num_inputs返回输入节点个数，默认为1，set_gl_state是渲软前设置状态，可以动态设置参数。set_int等就是设置具体类型参数了。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Input继承了Effect，num_inputs设置为0，get_color_space返回色彩空间，get_gamma_curve返回伽马曲线，用于色彩校正。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> :</span> <span class="keyword">public</span> Effect &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">num_inputs</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether this input can deliver linear gamma directly if it's</span></span><br><span class="line"><span class="comment">// asked to. (If so, set the parameter “output_linear_gamma”</span></span><br><span class="line"><span class="comment">// to activate it.)</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">can_output_linear_gamma</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether this input can supply mipmaps if asked to (by setting</span></span><br><span class="line"><span class="comment">// the "needs_mipmaps" integer parameter set to 1).</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">can_supply_mipmaps</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="title">get_width</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="title">get_height</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Colorspace <span class="title">get_color_space</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> GammaCurve <span class="title">get_gamma_curve</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="image-format"><a href="#image-format" class="headerlink" title="image_format"></a>image_format</h3><p>image_format定义了一些结构体，色彩显示相关的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> MovitPixelFormat &#123;</span><br><span class="line">FORMAT_RGB,</span><br><span class="line">FORMAT_RGBA_PREMULTIPLIED_ALPHA,</span><br><span class="line">FORMAT_RGBA_POSTMULTIPLIED_ALPHA,</span><br><span class="line">FORMAT_BGR,</span><br><span class="line">FORMAT_BGRA_PREMULTIPLIED_ALPHA,</span><br><span class="line">FORMAT_BGRA_POSTMULTIPLIED_ALPHA,</span><br><span class="line">FORMAT_GRAYSCALE,</span><br><span class="line">FORMAT_RG,</span><br><span class="line">FORMAT_R</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Colorspace &#123;</span><br><span class="line">COLORSPACE_INVALID = <span class="number">-1</span>,  <span class="comment">// For internal use.</span></span><br><span class="line">COLORSPACE_sRGB = <span class="number">0</span>,</span><br><span class="line">COLORSPACE_REC_709 = <span class="number">0</span>,  <span class="comment">// Same as sRGB.</span></span><br><span class="line">COLORSPACE_REC_601_525 = <span class="number">1</span>,</span><br><span class="line">COLORSPACE_REC_601_625 = <span class="number">2</span>,</span><br><span class="line">COLORSPACE_XYZ = <span class="number">3</span>,  <span class="comment">// Mostly useful for testing and debugging.</span></span><br><span class="line">COLORSPACE_REC_2020 = <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> GammaCurve &#123;</span><br><span class="line">GAMMA_INVALID = <span class="number">-1</span>,  <span class="comment">// For internal use.</span></span><br><span class="line">GAMMA_LINEAR = <span class="number">0</span>,</span><br><span class="line">GAMMA_sRGB = <span class="number">1</span>,</span><br><span class="line">GAMMA_REC_601 = <span class="number">2</span>,</span><br><span class="line">GAMMA_REC_709 = <span class="number">2</span>,  <span class="comment">// Same as Rec. 601.</span></span><br><span class="line">GAMMA_REC_2020_10_BIT = <span class="number">2</span>,  <span class="comment">// Same as Rec. 601.</span></span><br><span class="line">GAMMA_REC_2020_12_BIT = <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> YCbCrLumaCoefficients &#123;</span><br><span class="line">YCBCR_REC_601 = <span class="number">0</span>,</span><br><span class="line">YCBCR_REC_709 = <span class="number">1</span>,</span><br><span class="line">YCBCR_REC_2020 = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImageFormat</span> &#123;</span></span><br><span class="line">Colorspace color_space;</span><br><span class="line">GammaCurve gamma_curve;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>MovitPixelFormat是像素顺序结构，Colorspace是色彩空间，GammaCurve是伽马值，GAMMA_sRGB为1不校正。YCbCrLumaCoefficients是yuv亮度系数。</p><h3 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h3><p>包含一些工具方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">read_file</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;filename)</span></span>;</span><br><span class="line"><span class="function">GLuint <span class="title">compile_shader</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;shader_src, GLenum type)</span></span>;</span><br><span class="line"><span class="comment">// Output a GLSL 3x3 matrix declaration.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">output_glsl_mat3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> Eigen::Matrix3d &amp;m)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output GLSL scalar, 2-length and 3-length vector declarations.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">output_glsl_float</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">float</span> x)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">output_glsl_vec2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">output_glsl_vec3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span></span>;</span><br></pre></td></tr></table></figure><p>包括文件读取和gl操作的一些工具类。compile_shader编译shader，参数分别是shader的string和shader类型。<br>output_glsl_float等几个方法根据参数自动生成对应的glsl代码，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">output_glsl_float</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Use stringstream to be independent of the current locale in a thread-safe manner.</span></span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss.imbue(locale(<span class="string">"C"</span>));</span><br><span class="line">ss.precision(<span class="number">8</span>);</span><br><span class="line">ss &lt;&lt; scientific;</span><br><span class="line">ss &lt;&lt; <span class="string">"const float "</span> &lt;&lt; name &lt;&lt; <span class="string">" = "</span> &lt;&lt; x &lt;&lt; <span class="string">";\n"</span>;</span><br><span class="line"><span class="keyword">return</span> ss.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ResourcePool"><a href="#ResourcePool" class="headerlink" title="ResourcePool"></a>ResourcePool</h3><p>在多个EffectChains之间共享资源的类，如果有资源在多个EffectChain都要使用，每次获取释放会非常消耗资源，所以可以用ResourcePool，但是所有的EffectChains必须使用共享的OpenGLContext。</p><p>看公共方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourcePool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ResourcePool(<span class="keyword">size_t</span> program_freelist_max_length = <span class="number">100</span>,</span><br><span class="line">             <span class="keyword">size_t</span> texture_freelist_max_bytes = <span class="number">100</span> &lt;&lt; <span class="number">20</span>,  <span class="comment">// 100 MB.</span></span><br><span class="line">             <span class="keyword">size_t</span> fbo_freelist_max_length = <span class="number">100</span>,  <span class="comment">// Per context.</span></span><br><span class="line">             <span class="keyword">size_t</span> vao_freelist_max_length = <span class="number">100</span>);  <span class="comment">// Per context.</span></span><br><span class="line">~ResourcePool();</span><br><span class="line"></span><br><span class="line"><span class="function">GLuint <span class="title">compile_glsl_program</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; vertex_shader,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fragment_shader,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; frag_shader_outputs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_glsl_program</span><span class="params">(GLuint glsl_program_num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">GLuint <span class="title">compile_glsl_compute_program</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; compile_shader)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_glsl_compute_program</span><span class="params">(GLuint glsl_program_num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">GLuint <span class="title">use_glsl_program</span><span class="params">(GLuint glsl_program_num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unuse_glsl_program</span><span class="params">(GLuint instance_program_num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">GLuint <span class="title">create_2d_texture</span><span class="params">(GLint internal_format, GLsizei width, GLsizei height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_2d_texture</span><span class="params">(GLuint texture_num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">GLuint <span class="title">create_fbo</span><span class="params">(GLuint texture0_num,</span></span></span><br><span class="line"><span class="function"><span class="params">                  GLuint texture1_num = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  GLuint texture2_num = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  GLuint texture3_num = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_fbo</span><span class="params">(GLuint fbo_num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">GLuint <span class="title">create_vec2_vao</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;GLint&gt; &amp;attribute_indices,</span></span></span><br><span class="line"><span class="function"><span class="params">                       GLuint vbo_num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_vec2_vao</span><span class="params">(<span class="keyword">const</span> GLuint vao_num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean_context</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>可以缓存glsl程序，纹理，FBO，VAO。</p><h3 id="YCbCrInput"><a href="#YCbCrInput" class="headerlink" title="YCbCrInput"></a>YCbCrInput</h3><p>yuv输入类。一个重点是格式设置，一个重点是看片段着色器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> YCbCrInput::output_fragment_shader()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> frag_shader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ycbcr_input_splitting == YCBCR_INPUT_INTERLEAVED) &#123;</span><br><span class="line">frag_shader += <span class="string">"#define Y_CB_CR_SAME_TEXTURE 1\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ycbcr_input_splitting == YCBCR_INPUT_SPLIT_Y_AND_CBCR) &#123;</span><br><span class="line">cb_cr_offsets_equal =</span><br><span class="line">(<span class="built_in">fabs</span>(ycbcr_format.cb_x_position - ycbcr_format.cr_x_position) &lt; <span class="number">1e-6</span>) &amp;&amp;</span><br><span class="line">(<span class="built_in">fabs</span>(ycbcr_format.cb_y_position - ycbcr_format.cr_y_position) &lt; <span class="number">1e-6</span>);</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"#define Y_CB_CR_SAME_TEXTURE 0\n#define CB_CR_SAME_TEXTURE 1\n#define CB_CR_OFFSETS_EQUAL %d\n"</span>,</span><br><span class="line">cb_cr_offsets_equal);</span><br><span class="line">frag_shader += buf;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">frag_shader += <span class="string">"#define Y_CB_CR_SAME_TEXTURE 0\n#define CB_CR_SAME_TEXTURE 0\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frag_shader += read_file(<span class="string">"ycbcr_input.frag"</span>);</span><br><span class="line">frag_shader += <span class="string">"#undef CB_CR_SAME_TEXTURE\n#undef Y_CB_CR_SAME_TEXTURE\n"</span>;</span><br><span class="line"><span class="keyword">return</span> frag_shader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面读取了ycbcr_input.frag,看对应源码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> FUNCNAME(<span class="type">vec2</span> tc) &#123;</span><br><span class="line"><span class="comment">// OpenGL's origin is bottom-left, but most graphics software assumes</span></span><br><span class="line"><span class="comment">// a top-left origin. Thus, for inputs that come from the user,</span></span><br><span class="line"><span class="comment">// we flip the y coordinate.</span></span><br><span class="line">tc.y = <span class="number">1.0</span> - tc.y;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> ycbcr;</span><br><span class="line"><span class="meta">#if Y_CB_CR_SAME_TEXTURE</span></span><br><span class="line">ycbcr = tex2D(PREFIX(tex_y), tc).xyz;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">ycbcr.x = tex2D(PREFIX(tex_y), tc).x;</span><br><span class="line">  <span class="meta">#if CB_CR_SAME_TEXTURE</span></span><br><span class="line">    <span class="meta">#if CB_CR_OFFSETS_EQUAL</span></span><br><span class="line">ycbcr.yz = tex2D(PREFIX(tex_cbcr), tc + PREFIX(cb_offset)).xy;</span><br><span class="line">    <span class="meta">#else</span></span><br><span class="line">ycbcr.y = tex2D(PREFIX(tex_cbcr), tc + PREFIX(cb_offset)).x;</span><br><span class="line">ycbcr.z = tex2D(PREFIX(tex_cbcr), tc + PREFIX(cr_offset)).x;</span><br><span class="line">    <span class="meta">#endif</span></span><br><span class="line">  <span class="meta">#else</span></span><br><span class="line">ycbcr.y = tex2D(PREFIX(tex_cb), tc + PREFIX(cb_offset)).x;</span><br><span class="line">ycbcr.z = tex2D(PREFIX(tex_cr), tc + PREFIX(cr_offset)).x;</span><br><span class="line">  <span class="meta">#endif</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">ycbcr -= PREFIX(<span class="keyword">offset</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> rgba;</span><br><span class="line">rgba.rgb = PREFIX(inv_ycbcr_matrix) * ycbcr;</span><br><span class="line">rgba.a = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">return</span> rgba;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个纹理输入，PREFIX(tex_y)和(PREFIX(tex_cbcr)，PREFIX是预处理标记，因为会对应多个Effect，shader代码会处理一遍防止重名等问题。<br>有y和ub的纹理就可以通过偏移量获取到yuv数据，然后通过转换矩阵转成rgb数据。</p><h3 id="EffectChain"><a href="#EffectChain" class="headerlink" title="EffectChain"></a>EffectChain</h3><p>最后介绍最重要的EffectChain，效果链，实际结构是有向图，节点Node定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Effect *effect;</span><br><span class="line"><span class="keyword">bool</span> disabled;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Edges in the graph (forward and backward).</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node *&gt; outgoing_links;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node *&gt; incoming_links;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For unit tests only. Do not use from other code.</span></span><br><span class="line"><span class="comment">// Will contain an arbitrary choice if the node is in multiple phases.</span></span><br><span class="line">Phase *containing_phase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Node是双向链表结构，而且输入和输出节点都可以是多个。</p><p>多个Node可以组成Phase，包含一个单独的glsl程序。所有的节点组成EffectChain，有时有些glsl程序输入发生了变化，不得不用多个glsl程序，就需要用到phase.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Phase</span> &#123;</span></span><br><span class="line">Node *output_node;</span><br><span class="line"></span><br><span class="line">GLuint glsl_program_num;  <span class="comment">// Owned by the resource_pool.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Position and texcoord attribute indexes, although it doesn't matter</span></span><br><span class="line"><span class="comment">// which is which, because they contain the same data.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;GLint&gt; attribute_indexes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inputs are only inputs from other phases (ie., those that come from RTT);</span></span><br><span class="line"><span class="comment">// input textures are counted as part of &lt;effects&gt;.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Phase *&gt; inputs;</span><br><span class="line"><span class="comment">// Bound sampler numbers for each input. Redundant in a sense</span></span><br><span class="line"><span class="comment">// (it always corresponds to the index), but we need somewhere</span></span><br><span class="line"><span class="comment">// to hold the value for the uniform.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input_samplers;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node *&gt; effects;  <span class="comment">// In order.</span></span><br><span class="line"><span class="keyword">unsigned</span> output_width, output_height, virtual_output_width, virtual_output_height;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether this phase is compiled as a compute shader, ie., the last effect is</span></span><br><span class="line"><span class="comment">// marked as one.</span></span><br><span class="line"><span class="keyword">bool</span> is_compute_shader;</span><br><span class="line">Node *compute_shader_node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If &lt;is_compute_shader&gt;, which image unit the output buffer is bound to.</span></span><br><span class="line"><span class="comment">// This is used as source for a Uniform&lt;int&gt; below.</span></span><br><span class="line"><span class="keyword">int</span> outbuf_image_unit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// These are used in transforming from unnormalized to normalized coordinates</span></span><br><span class="line"><span class="comment">// in compute shaders.</span></span><br><span class="line"><span class="keyword">int</span> uniform_output_size[<span class="number">2</span>];</span><br><span class="line">Point2D inv_output_size, output_texcoord_adjust;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Identifier used to create unique variables in GLSL.</span></span><br><span class="line"><span class="comment">// Unique per-phase to increase cacheability of compiled shaders.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::pair&lt;Node *, NodeLinkType&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; effect_ids;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uniforms for this phase; combined from all the effects.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">int</span>&gt;&gt; uniforms_image2d;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">int</span>&gt;&gt; uniforms_sampler2d;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">bool</span>&gt;&gt; uniforms_bool;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">int</span>&gt;&gt; uniforms_int;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">int</span>&gt;&gt; uniforms_ivec2;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">float</span>&gt;&gt; uniforms_float;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">float</span>&gt;&gt; uniforms_vec2;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">float</span>&gt;&gt; uniforms_vec3;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;<span class="keyword">float</span>&gt;&gt; uniforms_vec4;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Uniform&lt;Eigen::Matrix3d&gt;&gt; uniforms_mat3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For measurement of GPU time used.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;GLuint&gt; timer_query_objects_running;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;GLuint&gt; timer_query_objects_free;</span><br><span class="line"><span class="keyword">uint64_t</span> time_elapsed_ns;</span><br><span class="line"><span class="keyword">uint64_t</span> num_measured_iterations;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>包含glsl程序需要的要素，按顺序的Effect节点，输入必须也是Phase，输出是Node。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EffectChain</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">EffectChain(<span class="keyword">float</span> aspect_nom, <span class="keyword">float</span> aspect_denom, ResourcePool *resource_pool = <span class="literal">nullptr</span>);</span><br><span class="line">~EffectChain();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Input *<span class="title">add_input</span><span class="params">(Input *input)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Effect *<span class="title">add_effect</span><span class="params">(Effect *effect)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> add_effect(effect, last_added_effect());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Effect *<span class="title">add_effect</span><span class="params">(Effect *effect, Effect *input)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Effect *&gt; inputs;</span><br><span class="line">inputs.push_back(input);</span><br><span class="line"><span class="keyword">return</span> add_effect(effect, inputs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Effect *<span class="title">add_effect</span><span class="params">(Effect *effect, Effect *input1, Effect *input2)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Effect *&gt; inputs;</span><br><span class="line">inputs.push_back(input1);</span><br><span class="line">inputs.push_back(input2);</span><br><span class="line"><span class="keyword">return</span> add_effect(effect, inputs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Effect *<span class="title">add_effect</span><span class="params">(Effect *effect, Effect *input1, Effect *input2, Effect *input3)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Effect *&gt; inputs;</span><br><span class="line">inputs.push_back(input1);</span><br><span class="line">inputs.push_back(input2);</span><br><span class="line">inputs.push_back(input3);</span><br><span class="line"><span class="keyword">return</span> add_effect(effect, inputs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Effect *<span class="title">add_effect</span><span class="params">(Effect *effect, Effect *input1, Effect *input2, Effect *input3, Effect *input4)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Effect *&gt; inputs;</span><br><span class="line">inputs.push_back(input1);</span><br><span class="line">inputs.push_back(input2);</span><br><span class="line">inputs.push_back(input3);</span><br><span class="line">inputs.push_back(input4);</span><br><span class="line"><span class="keyword">return</span> add_effect(effect, inputs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Effect *<span class="title">add_effect</span><span class="params">(Effect *effect, Effect *input1, Effect *input2, Effect *input3, Effect *input4, Effect *input5)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Effect *&gt; inputs;</span><br><span class="line">inputs.push_back(input1);</span><br><span class="line">inputs.push_back(input2);</span><br><span class="line">inputs.push_back(input3);</span><br><span class="line">inputs.push_back(input4);</span><br><span class="line">inputs.push_back(input5);</span><br><span class="line"><span class="keyword">return</span> add_effect(effect, inputs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Effect *<span class="title">add_effect</span><span class="params">(Effect *effect, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Effect *&gt; &amp;inputs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_output</span><span class="params">(<span class="keyword">const</span> ImageFormat &amp;format, OutputAlphaFormat alpha_format)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_ycbcr_output</span><span class="params">(<span class="keyword">const</span> ImageFormat &amp;format, OutputAlphaFormat alpha_format,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> YCbCrFormat &amp;ycbcr_format,</span></span></span><br><span class="line"><span class="function"><span class="params">      YCbCrOutputSplitting output_splitting = YCBCR_OUTPUT_INTERLEAVED,</span></span></span><br><span class="line"><span class="function"><span class="params">                      GLenum output_type = GL_UNSIGNED_BYTE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_ycbcr_output_format</span><span class="params">(<span class="keyword">const</span> YCbCrFormat &amp;ycbcr_format)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_dither_bits</span><span class="params">(<span class="keyword">unsigned</span> num_bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;num_dither_bits = num_bits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_output_origin</span><span class="params">(OutputOrigin output_origin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;output_origin = output_origin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_intermediate_format</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">GLenum intermediate_format,</span></span></span><br><span class="line"><span class="function"><span class="params">FramebufferTransformation transformation = NO_FRAMEBUFFER_TRANSFORMATION)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;intermediate_format = intermediate_format;</span><br><span class="line"><span class="keyword">this</span>-&gt;intermediate_transformation = transformation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_phase_timing</span><span class="params">(<span class="keyword">bool</span> enable)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset_phase_timing</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_phase_timing</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">render_to_screen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">render_to_fbo(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">render_to_fbo</span><span class="params">(GLuint fbo, <span class="keyword">unsigned</span> width, <span class="keyword">unsigned</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DestinationTexture</span> &#123;</span></span><br><span class="line">GLuint texnum;</span><br><span class="line">GLenum format;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">render_to_texture</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DestinationTexture&gt; &amp;destinations, <span class="keyword">unsigned</span> width, <span class="keyword">unsigned</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Effect *<span class="title">last_added_effect</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nodes.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nodes.back()-&gt;effect;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">add_node</span><span class="params">(Effect *effect)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect_nodes</span><span class="params">(Node *sender, Node *receiver)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace_receiver</span><span class="params">(Node *old_receiver, Node *new_receiver)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace_sender</span><span class="params">(Node *new_sender, Node *receiver)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node_between</span><span class="params">(Node *sender, Node *middle, Node *receiver)</span></span>;</span><br><span class="line"><span class="function">Node *<span class="title">find_node_for_effect</span><span class="params">(Effect *effect)</span> </span>&#123; <span class="keyword">return</span> node_map[effect]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">GLenum <span class="title">get_input_sampler</span><span class="params">(Node *node, <span class="keyword">unsigned</span> input_num)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">GLenum <span class="title">has_input_sampler</span><span class="params">(Node *node, <span class="keyword">unsigned</span> input_num)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ResourcePool *<span class="title">get_resource_pool</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> resource_pool; &#125;</span><br></pre></td></tr></table></figure><p>add_effect添加特效方法，finalize是生成glsl程序的方法，render_to_screen和render_to_fbo是渲染的方法，connect_nodes可以把输入和输出节点连接起来。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>fp16是16位和32为数据转换工具类，defs和version就是一些通用定义。</p><h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p>EffectChain.cpp中有两千多行代码，看重要流程代码，理解整体过程。生成EffectChain会进行添加节点，包括节点之间的连接关系，完成后就调用finalize组装，对应代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EffectChain::finalize()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; nodes.size(); ++i) &#123;</span><br><span class="line">nodes[i]-&gt;effect-&gt;rewrite_graph(<span class="keyword">this</span>, nodes[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find_color_spaces_for_inputs();</span><br><span class="line"></span><br><span class="line">propagate_alpha();</span><br><span class="line"></span><br><span class="line">propagate_gamma_and_color_space();</span><br><span class="line"></span><br><span class="line">fix_internal_color_spaces();</span><br><span class="line">fix_internal_alpha(<span class="number">6</span>);</span><br><span class="line">fix_output_color_space();</span><br><span class="line">fix_output_alpha();</span><br><span class="line"></span><br><span class="line">fix_internal_gamma_by_asking_inputs(<span class="number">9</span>);</span><br><span class="line">fix_internal_gamma_by_inserting_nodes(<span class="number">10</span>);</span><br><span class="line">fix_output_gamma();</span><br><span class="line">propagate_alpha();</span><br><span class="line">fix_internal_alpha(<span class="number">13</span>);</span><br><span class="line">fix_internal_gamma_by_asking_inputs(<span class="number">15</span>);</span><br><span class="line">fix_internal_gamma_by_inserting_nodes(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">add_ycbcr_conversion_if_needed();</span><br><span class="line"></span><br><span class="line">add_dither_if_needed();</span><br><span class="line"></span><br><span class="line">add_dummy_effect_if_needed();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;Node *, Phase *&gt; completed_effects;</span><br><span class="line">construct_phase(find_output_node(), &amp;completed_effects);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (has_dummy_effect &amp;&amp; !phases[phases.size() - <span class="number">2</span>]-&gt;is_compute_shader) &#123;</span><br><span class="line">resource_pool-&gt;release_glsl_program(phases.back()-&gt;glsl_program_num);</span><br><span class="line"><span class="keyword">delete</span> phases.back();</span><br><span class="line">phases.pop_back();</span><br><span class="line">has_dummy_effect = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(phases[<span class="number">0</span>]-&gt;inputs.empty());</span><br><span class="line"></span><br><span class="line">finalized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先遍历每个节点，进行rewrite_graph，然后进行颜色空间等设置。关键步骤是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">construct_phase(find_output_node(), &amp;completed_effects)；</span><br></pre></td></tr></table></figure><p>生成了phase结构。第一个参数是find_output_node，查找输出节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Node *EffectChain::find_output_node()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node *&gt; output_nodes;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; nodes.size(); ++i) &#123;</span><br><span class="line">Node *node = nodes[i];</span><br><span class="line"><span class="keyword">if</span> (node-&gt;disabled) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;outgoing_links.empty()) &#123;</span><br><span class="line">output_nodes.push_back(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">assert(output_nodes.size() == <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> output_nodes[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有输出的节点的节点就是最终的输出节点，只能有一个输出节点。</p><p>第二个参数是map<node *, phase *>类型的地址，就是返回的数据。</node></p><h3 id="construct-phase"><a href="#construct-phase" class="headerlink" title="construct_phase"></a>construct_phase</h3><p>从给定的效果和随后的链开始构建glsl程序。当需要改变纹理bound时，就会结束一个程序，还有需要多个效果，输出大小改变时也会结束程序。<br>在输出开始用一个简单的深度优先搜索，就不用在每个phase中明确的递归。</p><p>主要逻辑代码，省略部分非主线流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Phase *EffectChain::construct_phase(Node *output, <span class="built_in">map</span>&lt;Node *, Phase *&gt; *completed_effects)&#123;</span><br><span class="line">Phase *phase = <span class="keyword">new</span> Phase;</span><br><span class="line">phase-&gt;output_node = output;</span><br><span class="line">phase-&gt;is_compute_shader = <span class="literal">false</span>;</span><br><span class="line">phase-&gt;compute_shader_node = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;Node *&gt; effects_todo_this_phase;</span><br><span class="line">effects_todo_this_phase.push(output);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!effects_todo_this_phase.empty()) &#123;</span><br><span class="line">Node *node = effects_todo_this_phase.top();</span><br><span class="line">effects_todo_this_phase.pop();</span><br><span class="line"></span><br><span class="line">phase-&gt;effects.push_back(node);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all the dependencies of this effect, and add them to the stack.</span></span><br><span class="line">assert(node-&gt;effect-&gt;num_inputs() == node-&gt;incoming_links.size());</span><br><span class="line"><span class="keyword">for</span> (Node *dep : node-&gt;incoming_links) &#123;</span><br><span class="line"><span class="keyword">bool</span> start_new_phase = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(多种情况...)&#123;</span><br><span class="line">start_new_phase = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> (start_new_phase) &#123;</span><br><span class="line"><span class="comment">// Since we're starting a new phase here, we don't need to impose any</span></span><br><span class="line"><span class="comment">// new demands on this effect. Restore the status we had before we</span></span><br><span class="line"><span class="comment">// started looking at it.</span></span><br><span class="line">dep-&gt;needs_mipmaps = save_needs_mipmaps;</span><br><span class="line"></span><br><span class="line">phase-&gt;inputs.push_back(construct_phase(dep, completed_effects));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">effects_todo_this_phase.push(dep);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate the one-to-one status down through the dependency.</span></span><br><span class="line">dep-&gt;one_to_one_sampling = node-&gt;one_to_one_sampling &amp;&amp;</span><br><span class="line">dep-&gt;effect-&gt;one_to_one_sampling();</span><br><span class="line">dep-&gt;strong_one_to_one_sampling = node-&gt;strong_one_to_one_sampling &amp;&amp;</span><br><span class="line">dep-&gt;effect-&gt;strong_one_to_one_sampling();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node-&gt;incoming_link_type.push_back(start_new_phase ? IN_ANOTHER_PHASE : IN_SAME_PHASE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">compile_glsl_program(phase);</span><br><span class="line"></span><br><span class="line">phases.push_back(phase);</span><br><span class="line">    <span class="keyword">return</span> phase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从输出开始为phase添加节点，判断情况进行中断，如果需要添加新phase，则为新phase递归执行construct_phase方法，否则在当前处理node中添加节点，继续while循环。</p><h3 id="compile-glsl-program"><a href="#compile-glsl-program" class="headerlink" title="compile_glsl_program"></a>compile_glsl_program</h3><p>下一步是为每一个phase编译glsl程序。代码量也多，都是细致的操作代码，原理就是利用c的宏定义进行动态组合成一个glsl程序，相对多个程序需要内存拷贝，这样性能大大提高。解析下关键代码。</p><p>为每一个Node添加专属id：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Give each effect in the phase its own ID.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; phase-&gt;effects.size(); ++i) &#123;</span><br><span class="line">Node *node = phase-&gt;effects[i];</span><br><span class="line"><span class="keyword">char</span> effect_id[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(effect_id, <span class="string">"eff%u"</span>, i);</span><br><span class="line"><span class="keyword">bool</span> inserted = phase-&gt;effect_ids.insert(make_pair(make_pair(node, IN_SAME_PHASE), effect_id)).second;</span><br><span class="line">assert(inserted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为每个节点添加一个方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; phase-&gt;effects.size(); ++i) &#123;</span><br><span class="line">Node *node = phase-&gt;effects[i];</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> effect_id = phase-&gt;effect_ids[make_pair(node, IN_SAME_PHASE)];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; node-&gt;incoming_links.size(); ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;incoming_links.size() == <span class="number">1</span>) &#123;</span><br><span class="line">frag_shader += <span class="string">"#define INPUT"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"#define INPUT%d"</span>, j + <span class="number">1</span>);</span><br><span class="line">frag_shader += buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *input = node-&gt;incoming_links[j];</span><br><span class="line">NodeLinkType link_type = node-&gt;incoming_link_type[j];</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp;</span><br><span class="line">    input-&gt;effect-&gt;is_compute_shader() &amp;&amp;</span><br><span class="line">    node-&gt;incoming_link_type[j] == IN_SAME_PHASE) &#123;</span><br><span class="line"><span class="comment">// First effect after the compute shader reads the value</span></span><br><span class="line"><span class="comment">// that cs_output() wrote to a global variable,</span></span><br><span class="line"><span class="comment">// ignoring the tc (since all such effects have to be</span></span><br><span class="line"><span class="comment">// strong one-to-one).</span></span><br><span class="line">frag_shader += <span class="string">"(tc) CS_OUTPUT_VAL\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">assert(phase-&gt;effect_ids.count(make_pair(input, link_type)));</span><br><span class="line">frag_shader += <span class="built_in">string</span>(<span class="string">" "</span>) + phase-&gt;effect_ids[make_pair(input, link_type)] + <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frag_shader += <span class="string">"\n"</span>;</span><br><span class="line">frag_shader += <span class="built_in">string</span>(<span class="string">"#define FUNCNAME "</span>) + effect_id + <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;effect-&gt;is_compute_shader()) &#123;</span><br><span class="line">frag_shader += <span class="built_in">string</span>(<span class="string">"#define NORMALIZE_TEXTURE_COORDS(tc) ((tc) * "</span>) + effect_id + <span class="string">"_inv_output_size + "</span> + effect_id + <span class="string">"_output_texcoord_adjust)\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">frag_shader += replace_prefix(node-&gt;effect-&gt;output_fragment_shader(), effect_id);</span><br><span class="line">frag_shader += <span class="string">"#undef FUNCNAME\n"</span>;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;incoming_links.size() == <span class="number">1</span>) &#123;</span><br><span class="line">frag_shader += <span class="string">"#undef INPUT\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; node-&gt;incoming_links.size(); ++j) &#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"#undef INPUT%d\n"</span>, j + <span class="number">1</span>);</span><br><span class="line">frag_shader += buf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">frag_shader += <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面还有参数设置方法，组装后片段着色器代码后会编译glsl程序，然后获取参数位置，留待使用，不一一介绍了。</p><p>组合成的glsl片段着色器实例：<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> tc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define FUNCNAME eff0</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> eff0_tex;</span><br><span class="line"><span class="type">vec4</span> FUNCNAME(<span class="type">vec2</span> tc) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">texture2D</span>(eff0_tex, <span class="type">vec2</span>(tc.x,<span class="number">1.0</span>-tc.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#undef PREFIX</span></span><br><span class="line"><span class="meta">#undef FUNCNAME</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define INPUT eff0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define FUNCNAME eff1</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> eff1_strength;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> eff1_lut;</span><br><span class="line"><span class="type">vec4</span> FUNCNAME(<span class="type">vec2</span> tc) &#123; <span class="type">float</span> strength = eff1_strength; <span class="keyword">lowp</span> <span class="type">vec4</span> textureColor = INPUT(tc); <span class="keyword">mediump</span> <span class="type">float</span> blueColor = textureColor.b * <span class="number">63.0</span>; <span class="keyword">mediump</span> <span class="type">vec2</span> quad1; quad1.y = <span class="built_in">floor</span>(<span class="built_in">floor</span>(blueColor) / <span class="number">8.0</span>); quad1.x = <span class="built_in">floor</span>(blueColor) - (quad1.y * <span class="number">8.0</span>); <span class="keyword">mediump</span> <span class="type">vec2</span> quad2; quad2.y = <span class="built_in">floor</span>(<span class="built_in">ceil</span>(blueColor) / <span class="number">8.0</span>); quad2.x = <span class="built_in">ceil</span>(blueColor) - (quad2.y * <span class="number">8.0</span>); <span class="keyword">highp</span> <span class="type">vec2</span> texPos1; texPos1.x = (quad1.x * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.r); texPos1.y = (quad1.y * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.g); <span class="keyword">highp</span> <span class="type">vec2</span> texPos2; texPos2.x = (quad2.x * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.r); texPos2.y = (quad2.y * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.g); <span class="keyword">lowp</span> <span class="type">vec4</span> newColor1 = <span class="built_in">texture2D</span>(eff1_lut, texPos1); <span class="keyword">lowp</span> <span class="type">vec4</span> newColor2 = <span class="built_in">texture2D</span>(eff1_lut, texPos2); <span class="keyword">lowp</span> <span class="type">vec4</span> newColor = <span class="built_in">mix</span>(newColor1, newColor2, <span class="built_in">fract</span>(blueColor)); <span class="keyword">return</span> <span class="built_in">mix</span>(textureColor, <span class="type">vec4</span>(newColor.rgb, textureColor.w), strength); &#125; </span><br><span class="line"><span class="meta">#undef PREFIX</span></span><br><span class="line"><span class="meta">#undef FUNCNAME</span></span><br><span class="line"><span class="meta">#undef INPUT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define INPUT eff1</span></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = INPUT(tc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>opengl渲软流程都一样，但这里都多个phase，前面的phase需要先绘制在纹理上，最后一个phase绘制在目标fbo上，纹理采用resource_pool获取创建的纹理，可以缓存复用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (last_phase) &#123;</span><br><span class="line">    <span class="comment">// Last phase goes to the output the user specified.</span></span><br><span class="line">    <span class="keyword">if</span> (!phase-&gt;is_compute_shader) &#123;</span><br><span class="line">        assert(dest_fbo != (GLuint)<span class="number">-1</span>);</span><br><span class="line">        glBindFramebuffer(GL_FRAMEBUFFER, dest_fbo);</span><br><span class="line">        check_error();</span><br><span class="line">        GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);</span><br><span class="line">        assert(status == GL_FRAMEBUFFER_COMPLETE);</span><br><span class="line">        glViewport(x, y, width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dither_effect != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        CHECK(dither_effect-&gt;set_int(<span class="string">"output_width"</span>, width));</span><br><span class="line">        CHECK(dither_effect-&gt;set_int(<span class="string">"output_height"</span>, height));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!last_phase) &#123;</span><br><span class="line">    GLuint tex_num = resource_pool-&gt;create_2d_texture(intermediate_format, phase-&gt;output_width, phase-&gt;output_height);</span><br><span class="line">    output_textures.insert(make_pair(phase, tex_num));</span><br><span class="line">    phase_destinations.push_back(DestinationTexture&#123; tex_num, intermediate_format &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The output texture needs to have valid state to be written to by a compute shader.</span></span><br><span class="line">    glActiveTexture(GL_TEXTURE0);</span><br><span class="line">    check_error();</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, tex_num);</span><br><span class="line">    check_error();</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    check_error();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (phase-&gt;is_compute_shader) &#123;</span><br><span class="line">    assert(!destinations.empty());</span><br><span class="line">    phase_destinations = destinations;</span><br><span class="line">&#125;</span><br><span class="line">execute_phase(phase, output_textures, phase_destinations, &amp;generated_mipmaps);</span><br></pre></td></tr></table></figure><p>execute_phase包含一些输入输出大小，参数，资源缓存等逻辑，最后调用真正的绘制代码glDrawArrays。</p>]]></content>
    
    <summary type="html">
    
      高性能的OpenGL特效框架的内部原理
    
    </summary>
    
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="C" scheme="http://anddymao.com/tags/C/"/>
    
      <category term="OpenGl" scheme="http://anddymao.com/tags/OpenGl/"/>
    
  </entry>
  
  <entry>
    <title>mlt框架介绍和结构分析</title>
    <link href="http://anddymao.com/2019/10/27/2019-10-27-mlt/"/>
    <id>http://anddymao.com/2019/10/27/2019-10-27-mlt/</id>
    <published>2019-10-27T04:00:00.000Z</published>
    <updated>2020-01-19T02:36:48.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><p>官方介绍：The engine of a non-linear video editor that can be used in all sorts of apps,</p><p>视频编辑引擎。由C编写，它遵循基本的面向对象设计范式，主要采用的是生产者（producer）和消费者（consumer）模型，模块功能扩展可以有producer,consumer,filter,transition，animation。MLT的功能模块扩展可以使用FFmpeg，JACK，Movit，作为插件。</p><h3 id="结构和流"><a href="#结构和流" class="headerlink" title="结构和流"></a>结构和流</h3><p>MLT“网络”的一般结构只是一个<br>从“生产者”到“消费者”:</p><pre><code>+--------+   +--------+|Producer|--&gt;|Consumer|+--------+   +--------+</code></pre><p>一个典型的消费者向生产者请求MLT frame对象，执行一些操作，一帧的操作结束后，将其关闭。</p><p>生产者生产MLT Frame对象，而消费者消耗MLT框架对象。</p><p>过滤器也可以放在生产者和消费者之间：</p><pre><code>+--------+   +------+   +--------+|Producer|--&gt;|Filter|--&gt;|Consumer|+--------+   +------+   +--------+</code></pre><p>生产者，过滤器，转换器都是服务。</p><p>连接的消费者与生产者或服务之间的通信是分三个阶段进行：</p><p><em>获取帧数据</em>获取图像<br>*获取音频</p><p>消费者从它相连的服务去拉取数据，所以线程通常属于消费者，mlt_consumer提供一些基础功能确保实时吞吐。</p><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><h3 id="hello-world实例"><a href="#hello-world实例" class="headerlink" title="hello world实例"></a>hello world实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;framework/mlt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialise the factory</span></span><br><span class="line">    <span class="keyword">if</span> ( mlt_factory_init( <span class="literal">NULL</span> ) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Create the default consumer</span></span><br><span class="line">        mlt_consumer hello = mlt_factory_consumer( <span class="literal">NULL</span>, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create via the default producer</span></span><br><span class="line">        mlt_producer world = mlt_factory_producer( <span class="literal">NULL</span>, argv[ <span class="number">1</span> ] );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Connect the producer to the consumer</span></span><br><span class="line">        mlt_consumer_connect( hello, mlt_producer_service( world ) );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the consumer</span></span><br><span class="line">        mlt_consumer_start( hello );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait for the consumer to terminate</span></span><br><span class="line">        <span class="keyword">while</span>( !mlt_consumer_is_stopped( hello ) )</span><br><span class="line">            sleep( <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the consumer</span></span><br><span class="line">        mlt_consumer_close( hello );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the producer</span></span><br><span class="line">        mlt_producer_close( world );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the factory</span></span><br><span class="line">        mlt_factory_close( );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Report an error during initialisation</span></span><br><span class="line">        <span class="built_in">fprintf</span>( <span class="built_in">stderr</span>, <span class="string">"Unable to locate factory modules\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of program</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建生产者和消费者，然后连接，再启动消费者，最后关闭，就完成一次标准调用。<br>所有服务都通过工厂实例化，如<br>上面的mlt_factory_consumer和mlt_factory_producer调用。</p><h3 id="服务属性"><a href="#服务属性" class="headerlink" title="服务属性"></a>服务属性</h3><p>所有的服务都有属性,通过mlt_properties_set和mlt_properties_get获取对应的键值对。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mlt_properties properties = mlt_producer_properties( producer );</span><br><span class="line"></span><br><span class="line">mlt_properties_set( properties, <span class="string">"name"</span>, <span class="string">"value"</span> );</span><br><span class="line"></span><br><span class="line">data = mlt_properties_get( properties, <span class="string">"name"</span> );</span><br></pre></td></tr></table></figure><h3 id="播放列表"><a href="#播放列表" class="headerlink" title="播放列表"></a>播放列表</h3><p>可以创建一个播放列表mlt_playlist，然后通过mlt_factory_producer创建生产者添加到播放列表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mlt_producer <span class="title">create_playlist</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// We're creating a playlist here</span></span><br><span class="line">    mlt_playlist playlist = mlt_playlist_init( );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the playlist properties to ensure clean up</span></span><br><span class="line">    mlt_properties properties = mlt_playlist_properties( playlist );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop through each of the arguments</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; argc; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Create the producer</span></span><br><span class="line">        mlt_producer producer = mlt_factory_producer( <span class="literal">NULL</span>, argv[ i ] );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add it to the playlist</span></span><br><span class="line">        mlt_playlist_append( playlist, producer );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the producer (see below)</span></span><br><span class="line">        mlt_producer_close( producer );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the playlist as a producer</span></span><br><span class="line">    <span class="keyword">return</span> mlt_playlist_producer( playlist );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>与生产者和消费者一样，可以通过过滤器来操作过滤器<br>properties对象-可以调用mlt_filter_properties方法，并且<br>属性可以根据需要设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a producer from something</span></span><br><span class="line">mlt_producer producer = mlt_factory_producer( ... );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a consumer from something</span></span><br><span class="line">mlt_consumer consumer = mlt_factory_consumer( ... );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a greyscale filter</span></span><br><span class="line">mlt_filter filter = mlt_factory_filter( <span class="string">"greyscale"</span>, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect the filter to the producer</span></span><br><span class="line">mlt_filter_connect( filter, mlt_producer_service( producer ), <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect the consumer to filter</span></span><br><span class="line">mlt_consumer_connect( consumer, mlt_filter_service( filter ) );</span><br></pre></td></tr></table></figure><h3 id="混合转场"><a href="#混合转场" class="headerlink" title="混合转场"></a>混合转场</h3><p>混合是在播放列表上的相邻段之间引入过渡的最简单方法。</p><p>mlt_playlist_mix( playlist, i, 50, transition );<br>会在第i段和i+1短间加上50帧的转场，每段的时间不变，所以总长度会减少50帧。</p><p>注意添上转场只能倒序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the number of clips on the playlist</span></span><br><span class="line"><span class="keyword">int</span> i = mlt_playlist_count( );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate through them in reverse order</span></span><br><span class="line"><span class="keyword">while</span> ( i -- )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a transition</span></span><br><span class="line">    mlt_transition transition = mlt_factory_transition( <span class="string">"luma"</span>, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mix the first and second clips for 50 </span></span><br><span class="line">    mlt_playlist_mix( playlist, i, <span class="number">50</span>, transition );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close the transition</span></span><br><span class="line">    mlt_transition_close( transition );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实用性和优化"><a href="#实用性和优化" class="headerlink" title="实用性和优化"></a>实用性和优化</h3><p>当需要使用两个相同段融合转场时，为了实时渲软的效果，可以进行优化。<br>遍历整个播放列表，确定重叠实例的最大数量，然后创建克隆并将克隆索引分配给对应段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Optimise the playlist</span></span><br><span class="line">mlt_producer_optimise( mlt_playlist_producer( playlist ) );</span><br></pre></td></tr></table></figure><h3 id="多轨道"><a href="#多轨道" class="headerlink" title="多轨道"></a>多轨道</h3><p>多轨道结构图：</p><p><img src="/img/mlt_1.png" alt="多轨道结构"></p><p>调用源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mlt_producer <span class="title">create_tracks</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create the tractor</span></span><br><span class="line">    mlt_tractor tractor = mlt_tractor_new( );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Obtain the field</span></span><br><span class="line">    mlt_field field = mlt_tractor_field( tractor );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Obtain the multitrack</span></span><br><span class="line">    mlt_multitrack multitrack = mlt_tractor_multitrack( tractor );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a composite transition</span></span><br><span class="line">    mlt_transition transition = mlt_factory_transition( <span class="string">"composite"</span>, <span class="string">"10%/10%:15%x15%"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create track 0</span></span><br><span class="line">    mlt_producer track0 = create_playlist( argc, argv );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the watermark track - note we NEED loader for scaling here</span></span><br><span class="line">    mlt_producer track1 = mlt_factory_producer( <span class="string">"loader"</span>, <span class="string">"pango"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the length of track0</span></span><br><span class="line">    mlt_position length = mlt_producer_get_playtime( track0 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the properties of track1</span></span><br><span class="line">    mlt_properties properties = mlt_producer_properties( track1 );</span><br><span class="line">    mlt_properties_set( properties, <span class="string">"text"</span>, <span class="string">"Hello\nWorld"</span> );</span><br><span class="line">    mlt_properties_set_position( properties, <span class="string">"in"</span>, <span class="number">0</span> );</span><br><span class="line">    mlt_properties_set_position( properties, <span class="string">"out"</span>, length - <span class="number">1</span> );</span><br><span class="line">    mlt_properties_set_position( properties, <span class="string">"length"</span>, length );</span><br><span class="line">    mlt_properties_set_int( properties, <span class="string">"a_track"</span>, <span class="number">0</span> );</span><br><span class="line">    mlt_properties_set_int( properties, <span class="string">"b_track"</span>, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now set the properties on the transition</span></span><br><span class="line">    properties = mlt_transition_properties( transition );</span><br><span class="line">    mlt_properties_set_position( properties, <span class="string">"in"</span>, <span class="number">0</span> );</span><br><span class="line">    mlt_properties_set_position( properties, <span class="string">"out"</span>, length - <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add our tracks to the multitrack</span></span><br><span class="line">    mlt_multitrack_connect( multitrack, track0, <span class="number">0</span> );</span><br><span class="line">    mlt_multitrack_connect( multitrack, track1, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now plant the transition</span></span><br><span class="line">    mlt_field_plant_transition( field, transition, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close our references</span></span><br><span class="line">    mlt_producer_close( track0 );</span><br><span class="line">    mlt_producer_close( track1 );</span><br><span class="line">    mlt_transition_close( transition );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the tractor</span></span><br><span class="line">    <span class="keyword">return</span> mlt_tractor_producer( tractor );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p>mlt框架包含一个OO类层次结构，该层次结构包含以下内容</p><p>公共类和抽象：</p><pre><code>mlt_properties  mlt_frame  mlt_service    mlt_producer      mlt_playlist      mlt_tractor    mlt_filter    mlt_transition    mlt_consumermlt_dequemlt_poolmlt_factory</code></pre><p>可以将上面定义的每个类理解为将上面的类扩展到<br>左边。</p><h3 id="mlt-properties"><a href="#mlt-properties" class="headerlink" title="mlt_properties"></a>mlt_properties</h3><p>属性类是框架和服务类的基类。</p><p>它旨在为各种类型的计算机提供有效的查找表<br>信息，例如字符串，整数，浮点值和指针<br>数据和数据结构。</p><p>所有属性均由唯一的字符串索引。</p><p>除非属性对象关闭，否则分配的内存将保留，除非<br>您指定一个析构函数。在上述情况下，可以使用以下方法完成此操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mlt_properties_set_data（properties，“ image”，image，size，<span class="built_in">free</span>，<span class="literal">NULL</span>）;</span><br></pre></td></tr></table></figure><h3 id="mlt-deque"><a href="#mlt-deque" class="headerlink" title="mlt_deque"></a>mlt_deque</h3><p>堆栈和队列是MLT框架中的基本组件。 为了方便，选择实施“双端队列”（双端队列）- mlt_deque这封装了两者的功能。</p><h3 id="mlt-pool"><a href="#mlt-pool" class="headerlink" title="mlt_pool"></a>mlt_pool</h3><p>MLT框架通过mlt_pool提供内存池功能<br>API。一旦初始化，这些可以看作是直接替换malloc / realloc / free功能。</p><p>为了大内存分配的性能，内部有一个堆栈缓存，提升了性能。</p><p>API和传统的malloc/realloc/free 调用相同:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mlt_pool_alloc</span><span class="params">( <span class="keyword">int</span> size )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mlt_pool_realloc</span><span class="params">( <span class="keyword">void</span> *ptr, <span class="keyword">int</span> size )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mlt_pool_release</span><span class="params">( <span class="keyword">void</span> *release )</span></span>;</span><br></pre></td></tr></table></figure><h3 id="mlt-frame"><a href="#mlt-frame" class="headerlink" title="mlt_frame"></a>mlt_frame</h3><p>结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+------------+</span><br><span class="line">|frame       |</span><br><span class="line">+------------+</span><br><span class="line">| properties |</span><br><span class="line">| image stack|</span><br><span class="line">| audio stack|</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure><p>请求流程：</p><p><img src="/img/mlt_2.png" alt="请求流程"></p><h3 id="mlt-service"><a href="#mlt-service" class="headerlink" title="mlt_service"></a>mlt_service</h3><p>服务基类，包含扩展属性，允许多个输入和一个输出。 mlt_produce，mlt_filter，mlt_transition，mlt_consumer都继承mlt_service_s。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mlt_service_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mlt_properties_s</span> <span class="title">parent</span>;</span> <span class="comment">/**&lt; \private A service extends properties. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get a frame of data (virtual function).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param mlt_producer a producer</span></span><br><span class="line"><span class="comment"> * \param mlt_frame_ptr a frame pointer by reference</span></span><br><span class="line"><span class="comment"> * \param int an index</span></span><br><span class="line"><span class="comment"> * \return true if there was an error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ( *get_frame )( mlt_service self, mlt_frame_ptr frame, <span class="keyword">int</span> index );</span><br><span class="line"></span><br><span class="line"><span class="comment">/** the destructor virtual function */</span></span><br><span class="line">mlt_destructor close;</span><br><span class="line"><span class="keyword">void</span> *close_object; <span class="comment">/**&lt; the object supplied to the close virtual function */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *local; <span class="comment">/**&lt; \private instance object */</span></span><br><span class="line"><span class="keyword">void</span> *child; <span class="comment">/**&lt; \private the object of a subclass */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>local是mlt_service_base类型，定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">int size;</span><br><span class="line">int count;</span><br><span class="line">mlt_service *in;</span><br><span class="line">mlt_service out;</span><br><span class="line">int filter_count;</span><br><span class="line">int filter_size;</span><br><span class="line">mlt_filter *filters;</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">&#125;</span><br><span class="line">mlt_service_base;</span><br></pre></td></tr></table></figure><h3 id="mlt-producer"><a href="#mlt-producer" class="headerlink" title="mlt_producer"></a>mlt_producer</h3><p>一个生产者拥有0个输入和1个输出。</p><p>生产者提供了文件读取，管道，流或者图片及音频输入。</p><p>生产者，过滤器，混合器，消费者需要自己定制创建（或者使用插件提供的模板），提供了丰富的扩展性，下面介绍下自定义使用的主要流程方法，主要是get_frame和getImage：</p><p>一个生产者一般对应一个frame，frame可以设置position，对应长度：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">producer_get_frame</span><span class="params">(mlt_producer producer, mlt_frame_ptr frame, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate a frame</span></span><br><span class="line">    *frame = mlt_frame_init(MLT_PRODUCER_SERVICE(producer));</span><br><span class="line">    <span class="keyword">if</span> (*frame != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// Obtain properties of frame and producer</span></span><br><span class="line">        mlt_frame_set_position(*frame, mlt_producer_position(producer));</span><br><span class="line">        </span><br><span class="line">        mlt_frame_push_service(*frame, producer);</span><br><span class="line">        mlt_frame_push_get_image(*frame, producer_get_image);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate the next timecode</span></span><br><span class="line">    mlt_producer_prepare_next(producer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每一次图像处理都需要走get_image,根据进度可以进行不同的处理：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">producer_get_image(mlt_frame frame, <span class="keyword">uint8_t</span> **buffer, mlt_image_format *format, <span class="keyword">int</span> *width,</span><br><span class="line">                   <span class="keyword">int</span> *height, <span class="keyword">int</span> writable) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Obtain properties of frame</span></span><br><span class="line">    <span class="comment">//mlt_properties frame_props = MLT_FRAME_PROPERTIES(frame);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Obtain the producer for this frame</span></span><br><span class="line">    <span class="comment">//mlt_producer mlt_producer = mlt_properties_get_data(frame_props, "producer_android_jpeg", NULL);</span></span><br><span class="line"></span><br><span class="line">    mlt_producer producer = (mlt_producer) mlt_frame_pop_service(frame);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//do something here</span></span><br><span class="line">    </span><br><span class="line">    mlt_frame_set_image(frame, *buffer, size, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="mlt-filter"><a href="#mlt-filter" class="headerlink" title="mlt_filter"></a>mlt_filter</h3><p>过滤器主要处理流程：</p><p>处理frame：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> mlt_frame <span class="title">process</span><span class="params">(mlt_filter filter, mlt_frame frame)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something here</span></span><br><span class="line"></span><br><span class="line">    mlt_frame_push_service(frame, filter);</span><br><span class="line">    mlt_frame_push_get_image(frame, get_image);</span><br><span class="line">    <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理image：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">get_image(mlt_frame frame, <span class="keyword">uint8_t</span> **image, mlt_image_format *format, <span class="keyword">int</span> *width, <span class="keyword">int</span> *height,</span><br><span class="line">          <span class="keyword">int</span> writable) &#123;</span><br><span class="line">    mlt_filter filter = (mlt_filter) mlt_frame_pop_service(frame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something here</span></span><br><span class="line">    </span><br><span class="line">    *format = mlt_image_glsl;</span><br><span class="line">    <span class="keyword">return</span> mlt_frame_get_image(frame, image, format, width, height, writable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="mlt-transition"><a href="#mlt-transition" class="headerlink" title="mlt_transition"></a>mlt_transition</h3><p>混合器需要对应两个frame，处理当前a_frame时，把b_frame传给a_frame，处理frame：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> mlt_frame <span class="title">process</span><span class="params">(mlt_transition transition, mlt_frame a_frame, mlt_frame b_frame)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something here</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Push the transition on to the frame</span></span><br><span class="line">    mlt_frame_push_service(a_frame, transition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Push the b_frame on to the stack</span></span><br><span class="line">    mlt_frame_push_frame(a_frame, b_frame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Push the transition method</span></span><br><span class="line">    mlt_frame_push_get_image(a_frame, get_image);</span><br><span class="line">    <span class="keyword">return</span> a_frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理image时获取a_frame和b_frame,锁住混合器防止同时处理的异常，然后可以进行混合处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">get_image(mlt_frame a_frame, <span class="keyword">uint8_t</span> **image, mlt_image_format *format, <span class="keyword">int</span> *width, <span class="keyword">int</span> *height,</span><br><span class="line">          <span class="keyword">int</span> writable) &#123;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Get the b frame from the stack</span></span><br><span class="line">    mlt_frame b_frame = (mlt_frame) mlt_frame_pop_frame(a_frame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the transition object</span></span><br><span class="line">    mlt_transition transition = (mlt_transition) mlt_frame_pop_service(a_frame);</span><br><span class="line">    mlt_service service = MLT_TRANSITION_SERVICE(transition);</span><br><span class="line">    mlt_service_lock(service);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// do something here</span></span><br><span class="line">    </span><br><span class="line">    mlt_service_unlock(service);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mlt-consumer"><a href="#mlt-consumer" class="headerlink" title="mlt_consumer"></a>mlt_consumer</h3><p>消费者是整个框架的发动机，主要公共方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mlt_consumer_init</span><span class="params">( mlt_consumer <span class="keyword">this</span>, <span class="keyword">void</span> *child )</span></span>;</span><br><span class="line"><span class="function">mlt_service <span class="title">mlt_consumer_service</span><span class="params">( mlt_consumer <span class="keyword">this</span> )</span></span>;</span><br><span class="line"><span class="function">mlt_properties <span class="title">mlt_consumer_properties</span><span class="params">( mlt_consumer <span class="keyword">this</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mlt_consumer_connect</span><span class="params">( mlt_consumer <span class="keyword">this</span>, mlt_service producer )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mlt_consumer_start</span><span class="params">( mlt_consumer <span class="keyword">this</span> )</span></span>;</span><br><span class="line"><span class="function">mlt_frame <span class="title">mlt_consumer_get_frame</span><span class="params">( mlt_consumer <span class="keyword">this</span> )</span></span>;</span><br><span class="line"><span class="function">mlt_frame <span class="title">mlt_consumer_rt_frame</span><span class="params">( mlt_consumer <span class="keyword">this</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mlt_consumer_stop</span><span class="params">( mlt_consumer <span class="keyword">this</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mlt_consumer_is_stopped</span><span class="params">( mlt_consumer <span class="keyword">this</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mlt_consumer_close</span><span class="params">( mlt_consumer )</span></span>;</span><br></pre></td></tr></table></figure><p>包含一些状态控制，属性等方法，自己使用需要创建线程，在线程中获取frame，线程中的基本流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">consumer_thread</span><span class="params">( <span class="keyword">void</span> *arg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Map the argument to the object</span></span><br><span class="line">mlt_consumer <span class="keyword">this</span> = arg;</span><br><span class="line"><span class="comment">// Get the properties</span></span><br><span class="line">mlt_properties properties = MLT_CONSUMER_PROPERTIES( <span class="keyword">this</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convenience functionality</span></span><br><span class="line"><span class="keyword">int</span> terminate_on_pause = mlt_properties_get_int( properties, <span class="string">"terminate_on_pause"</span> );</span><br><span class="line"><span class="keyword">int</span> terminated = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Frame and size</span></span><br><span class="line">mlt_frame frame = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Loop while running</span></span><br><span class="line"><span class="keyword">while</span>( !terminated &amp;&amp; mlt_properties_get_int( properties, <span class="string">"running"</span> ) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Get the frame</span></span><br><span class="line">frame = mlt_consumer_rt_frame( <span class="keyword">this</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for termination</span></span><br><span class="line"><span class="keyword">if</span> ( terminate_on_pause &amp;&amp; frame != <span class="literal">NULL</span> )</span><br><span class="line">terminated = mlt_properties_get_double( MLT_FRAME_PROPERTIES( frame ), <span class="string">"_speed"</span> ) == <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that we have a frame to work with</span></span><br><span class="line"><span class="keyword">if</span> ( frame != <span class="literal">NULL</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Close the frame</span></span><br><span class="line">mlt_events_fire( properties, <span class="string">"consumer-frame-show"</span>, frame, <span class="literal">NULL</span> );</span><br><span class="line">mlt_frame_close( frame );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Indicate that the consumer is stopped</span></span><br><span class="line">mlt_properties_set_int( properties, <span class="string">"running"</span>, <span class="number">0</span> );</span><br><span class="line">mlt_consumer_stopped( <span class="keyword">this</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在while循环中用mlt_consumer_rt_frame获取frame，就发动起了整个框架。</p><h3 id="mlt-playlist"><a href="#mlt-playlist" class="headerlink" title="mlt_playlist"></a>mlt_playlist</h3><p>mlt_playlist实际也是个mlt_producer,结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mlt_playlist_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mlt_producer_s</span> <span class="title">parent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mlt_producer_s</span> <span class="title">blank</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">playlist_entry **<span class="built_in">list</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>playlist_entry是个mlt_playlist_clip_info的list，结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> clip;                 <span class="comment">/**&lt; the index of the clip within the playlist */</span></span><br><span class="line">mlt_producer producer;    <span class="comment">/**&lt; the clip's producer (or parent producer of a cut) */</span></span><br><span class="line">mlt_producer cut;         <span class="comment">/**&lt; the clips' cut producer */</span></span><br><span class="line">mlt_position start;       <span class="comment">/**&lt; the time this begins relative to the beginning of the playlist */</span></span><br><span class="line"><span class="keyword">char</span> *resource;           <span class="comment">/**&lt; the file name or address of the clip */</span></span><br><span class="line">mlt_position frame_in;    <span class="comment">/**&lt; the clip's in point */</span></span><br><span class="line">mlt_position frame_out;   <span class="comment">/**&lt; the clip's out point */</span></span><br><span class="line">mlt_position frame_count; <span class="comment">/**&lt; the duration of the clip */</span></span><br><span class="line">mlt_position length;      <span class="comment">/**&lt; the unedited duration of the clip */</span></span><br><span class="line"><span class="keyword">float</span> fps;                <span class="comment">/**&lt; the frame rate of the clip */</span></span><br><span class="line"><span class="keyword">int</span> repeat;               <span class="comment">/**&lt; the number of times the clip is repeated */</span></span><br><span class="line">&#125;</span><br><span class="line">mlt_playlist_clip_info;</span><br></pre></td></tr></table></figure><p>clip一段也是一个生产者，符合前面讲的多个生产者组合成一个播放列表.</p><h3 id="mlt-tractor"><a href="#mlt-tractor" class="headerlink" title="mlt_tractor"></a>mlt_tractor</h3><p>轨道也是生产者的组合，但是组合方式不一样，多个轨道是并行，比如音频和图像轨。</p><p>结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mlt_tractor_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mlt_producer_s</span> <span class="title">parent</span>;</span></span><br><span class="line">mlt_service producer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>结构非常简单，多个轨进行叠加要使用mlt_field,mlt_field专门是为track添加过滤和混合的，添加方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mlt_field_plant_filter(field, filter, <span class="number">0</span>);</span><br><span class="line">mlt_field_plant_transition(field, transition, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p> 基础内容来自:<br><a href="https://github.com/mltframework/mlt/blob/master/docs/framework.txt" target="_blank" rel="noopener">https://github.com/mltframework/mlt/blob/master/docs/framework.txt</a></p>]]></content>
    
    <summary type="html">
    
      关于mlt框架你所必须掌握的知识点
    
    </summary>
    
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="C" scheme="http://anddymao.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu下载安装OpenCV并在Clion中使用</title>
    <link href="http://anddymao.com/2019/10/26/2019-10-26-opencv-%E5%AE%89%E8%A3%85/"/>
    <id>http://anddymao.com/2019/10/26/2019-10-26-opencv-安装/</id>
    <published>2019-10-26T04:00:00.000Z</published>
    <updated>2020-01-18T02:16:08.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cmake下载安装"><a href="#cmake下载安装" class="headerlink" title="cmake下载安装"></a>cmake下载安装</h2><p><a href="https://cmake.org/download/" target="_blank" rel="noopener">https://cmake.org/download/</a></p><p>通过apt-get获取的不是最新版本，就去官网下载最新版本3.16.0-rc2。</p><p>解压后直接到bash.rc 配置环境变量就可以了</p><p>PATH=/home/cmake-3.16.0-rc2-Linux-x86_64/bin:$PATH</p><p>到命令行输入cmake版本会显示3.16.0-rc2</p><h2 id="下载-OpenCV"><a href="#下载-OpenCV" class="headerlink" title="下载 OpenCV"></a>下载 OpenCV</h2><p>直接官网转github下载release版本，最新版本4.1.2</p><p><a href="https://github.com/opencv/opencv/releases" target="_blank" rel="noopener">https://github.com/opencv/opencv/releases</a></p><p><a href="https://github.com/opencv/opencv_contrib/releases" target="_blank" rel="noopener">https://github.com/opencv/opencv_contrib/releases</a></p><p>opencv_contrib是一些额外的模块，也需要使用，就也下载了。</p><h2 id="安装-OpenCV"><a href="#安装-OpenCV" class="headerlink" title="安装 OpenCV"></a>安装 OpenCV</h2><p>进入OpenCV根目录，走一下流程即可。</p><p>mrdir build<br>cd build<br>cmake ..<br>make<br>make install</p><p>make install可能需要root权限，前面加sudo 。</p><h2 id="安装-opencv-contrib"><a href="#安装-opencv-contrib" class="headerlink" title="安装 opencv_contrib"></a>安装 opencv_contrib</h2><p>$ cd &lt;opencv_build_directory&gt;<br>$ cmake -DOPENCV_EXTRA_MODULES_PATH=&lt;opencv_contrib&gt;/modules &lt;opencv_source_directory&gt;<br>$ make -j5</p><p>github上提示的安装步骤如上。</p><p>到opencv_contrib目录，其实也是这几个步骤。</p><p>mrdir build<br>cd build<br>cmake ..<br>make<br>make install</p><p>但cmake这一步要用opencv_source_directory（即opencv的源码路径）编译opencv_contrib的module下的模块。</p><h2 id="创建Clion工程"><a href="#创建Clion工程" class="headerlink" title="创建Clion工程"></a>创建Clion工程</h2><p>创建一个工程，比如opencvtest</p><p>然后配置cmakelist：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.13)</span><br><span class="line">project(opencvtest)</span><br><span class="line"></span><br><span class="line">find_package(OpenCV REQUIRED)</span><br><span class="line">include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br><span class="line"></span><br><span class="line">add_executable(opencvtest main.cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(opencvtest $&#123;OpenCV_LIBS&#125;)</span><br></pre></td></tr></table></figure><p>随便找了下实例代码，在main.cpp添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/core/core.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/opencv.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui/highgui.hpp"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat img = imread(<span class="string">"../test.jpg"</span>);</span><br><span class="line">    namedWindow(<span class="string">"DisplayImage"</span>);</span><br><span class="line">    imshow(<span class="string">"Cat"</span>, img);</span><br><span class="line">    waitKey();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以run起来。</p><p>Mat是opencv的数据类型，namedWindow创建显示创建，imshow显示图片，然后等待操作，返回。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ubuntu上配置软件比较方便，一般几招，apt-get，官网下载，release版本配置path直接使用，源码版本自己make使用。</p>]]></content>
    
    <summary type="html">
    
      ubuntu软件安装基本流程和问题解决
    
    </summary>
    
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="C" scheme="http://anddymao.com/tags/C/"/>
    
      <category term="OpenCV" scheme="http://anddymao.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>NDK中使用MediaCodec编解码视频</title>
    <link href="http://anddymao.com/2019/10/16/2019-10-16-ndk-MediaCodec/"/>
    <id>http://anddymao.com/2019/10/16/2019-10-16-ndk-MediaCodec/</id>
    <published>2019-10-16T04:00:00.000Z</published>
    <updated>2020-01-18T02:16:08.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>MediaCodec 作为Android自带的视频编解码工具，可以直接利用底层硬件编解码能力，现在已经逐渐成为主流了。API21已经支持NDK方法了，MediaCodec api设计得非常精妙,另一个方面也是很多人觉得不好懂。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="MediaCodec的两个Buffer和三板斧"><a href="#MediaCodec的两个Buffer和三板斧" class="headerlink" title="MediaCodec的两个Buffer和三板斧"></a>MediaCodec的两个Buffer和三板斧</h3><p>MediaCodec内部包含InputBuffer和OutputBuffer，内部有一个自启线程，不断去查询两个Buffer，是一个生产者消费者模型。</p><p>进行数据处理时主要靠三板斧</p><p>第一步：取buffer地址<br>AMediaCodec_dequeueInputBuffer</p><p>第二步：获取buffer数据<br>AMediaCodec_getInputBuffer</p><p>第三步：buffer入队<br>AMediaCodec_queueInputBuffer</p><p>InputBuffer和OutputBuffer基本是对称的：</p><p>第一步：取buffer地址<br>AMediaCodec_dequeueOutputBuffer</p><p>第二步：获取buffer数据<br>AMediaCodec_getOutputBuffer</p><p>第三步：buffer释放<br>AMediaCodec_releaseOutputBuffer</p><p>只有第三步不同，AMediaCodec_queueInputBuffer是数据入队等待消费，AMediaCodec_releaseOutputBuffer是释放数据。<br>编码和解码过程，InputBuffer和OutputBuffer就互相置换下。<br>解码： 原始数据（视频流）-&gt; 提取器AMediaExtractor-&gt;InputBuffer-&gt;OutputBuffer-&gt;帧数据(YUV420sp，PCM)<br>编码： 帧数据（视频流）-&gt;InputBuffer-&gt;OutputBuffer-&gt;合成器AMediaMuxer</p><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><h4 id="解码配置"><a href="#解码配置" class="headerlink" title="解码配置"></a>解码配置</h4><p>解码开始需要配置AMediaCodec和AMediaExtractor,MediaCodec start后就可以开始解码，</p><p>AMediaExtractor需要设置文件描述符，通过AAssetManager_open或者fopen就可以得到。起始点和长度也同样。然后设置进提取器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AMediaExtractor_setDataSourceFd(mExtractor, virtualFile.fd,</span><br><span class="line">                                                         virtualFile.start,</span><br><span class="line">                                                         virtualFile.length);</span><br></pre></td></tr></table></figure><p>AMediaCodec创建需要设置数据格式，通过AMediaExtractor获取到的AMediaFormat可以得到mime和format。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mCodec = AMediaCodec_createDecoderByType(mime);</span><br><span class="line">AMediaCodec_configure(mCodec, format, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">AMediaCodec_start(mCodec);</span><br></pre></td></tr></table></figure><p>解码配置第三个参数为NativeWindow，加了后解码后可以直接吐到surface上，GPU数据直接渲软，效率高但不够灵活。不加的话解码数据就需要输出拷贝。</p><h4 id="解码流程"><a href="#解码流程" class="headerlink" title="解码流程"></a>解码流程</h4><p>解码也就是操作两个Buffer的过程，执行玩三板斧就可以，然后有一些状态需要处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mInputEof) &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> bufidx = AMediaCodec_dequeueInputBuffer(mCodec, <span class="number">1</span>);</span><br><span class="line">    log_info(<span class="literal">NULL</span>, <span class="string">"input buffer %zd"</span>, bufidx);</span><br><span class="line">    <span class="keyword">if</span> (bufidx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> bufsize;</span><br><span class="line">        <span class="keyword">uint8_t</span> *buf = AMediaCodec_getInputBuffer(mCodec, bufidx, &amp;bufsize);</span><br><span class="line">        <span class="keyword">int</span> sampleSize = AMediaExtractor_readSampleData(mExtractor, buf, bufsize);</span><br><span class="line">        <span class="keyword">if</span> (sampleSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sampleSize = <span class="number">0</span>;</span><br><span class="line">            mInputEof = <span class="literal">true</span>;</span><br><span class="line">            log_info(<span class="literal">NULL</span>, <span class="string">"video producer input EOS"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int64_t</span> presentationTimeUs = AMediaExtractor_getSampleTime(mExtractor);</span><br><span class="line"></span><br><span class="line">        AMediaCodec_queueInputBuffer(mCodec, bufidx, <span class="number">0</span>, sampleSize, presentationTimeUs,</span><br><span class="line">                                     mInputEof ? AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM</span><br><span class="line">                                               : <span class="number">0</span>);</span><br><span class="line">        AMediaExtractor_advance(mExtractor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mOutputEof) &#123;</span><br><span class="line">    AMediaCodecBufferInfo info;</span><br><span class="line">    <span class="keyword">ssize_t</span> status = AMediaCodec_dequeueOutputBuffer(mCodec, &amp;info, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (info.flags &amp; AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM) &#123;</span><br><span class="line">            log_info(<span class="literal">NULL</span>, <span class="string">"video producer output EOS"</span>);</span><br><span class="line"></span><br><span class="line">            eof = <span class="literal">true</span>;</span><br><span class="line">            mOutputEof = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint8_t</span> *outputBuf = AMediaCodec_getOutputBuffer(mCodec, status, <span class="literal">NULL</span><span class="comment">/* out_size */</span>);</span><br><span class="line">        <span class="keyword">size_t</span> dataSize = info.size;</span><br><span class="line">        <span class="keyword">if</span> (outputBuf != <span class="literal">nullptr</span> &amp;&amp; dataSize != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> pts = info.presentationTimeUs;</span><br><span class="line">            <span class="keyword">int32_t</span> pts32 = (<span class="keyword">int32_t</span>) pts;</span><br><span class="line"></span><br><span class="line">            *buffer = (<span class="keyword">uint8_t</span> *) mlt_pool_alloc(dataSize);</span><br><span class="line">            <span class="built_in">memcpy</span>(*buffer, outputBuf + info.offset, dataSize);</span><br><span class="line">            *buffersize = dataSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> presentationNano = info.presentationTimeUs * <span class="number">1000</span>;</span><br><span class="line">        log_info(<span class="literal">NULL</span>, <span class="string">"video pts %lld outsize %d"</span>, info.presentationTimeUs, dataSize);</span><br><span class="line">        <span class="comment">/*if (delay &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">            usleep(delay / 1000);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        AMediaCodec_releaseOutputBuffer(mCodec, status, info.size != <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AMEDIACODEC_INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">        log_info(<span class="literal">NULL</span>, <span class="string">"output buffers changed"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AMEDIACODEC_INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">        AMediaFormat_delete(format);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AMEDIACODEC_INFO_TRY_AGAIN_LATER) &#123;</span><br><span class="line">        log_info(<span class="literal">NULL</span>, <span class="string">"video no output buffer right now"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_info(<span class="literal">NULL</span>, <span class="string">"unexpected info code: %zd"</span>, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AMediaCodec和AMediaExtractor是没有直接交流的，AMediaCodec取到InputBuffer后实际数据为空，需要从AMediaExtractor_readSampleData获取到buffer数据。<br>AMediaCodec数据入队后，AMediaExtractor调用AMediaExtractor_advance前进到下一个数据位置。</p><p>OutputBuffer操作时有些不一样，AMediaCodec_dequeueOutputBuffer获取的是解码好的帧，AMediaCodec_getOutputBuffer取到的就已经是解码好的数据了，可以直接拷贝使用。<br>AMediaCodec_releaseOutputBuffer是释放buffer，如果配置了surface，就会渲软到surface上。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="编码配置"><a href="#编码配置" class="headerlink" title="编码配置"></a>编码配置</h4><p>编码是解码的逆过程，首先设置格式,然后根据格式创建编码器MediaCodec，再根据文件创建合成器MediaMuxer。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeEncoder::prepareEncoder(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> fps, <span class="built_in">std</span>::<span class="built_in">string</span> strPath) &#123;</span><br><span class="line"></span><br><span class="line">    mWidth = width;</span><br><span class="line">    mHeight = height;</span><br><span class="line">    mFps = fps;</span><br><span class="line"></span><br><span class="line">    AMediaFormat *format = AMediaFormat_new();</span><br><span class="line">    AMediaFormat_setString(format, AMEDIAFORMAT_KEY_MIME, mStrMime.c_str());</span><br><span class="line">    AMediaFormat_setInt32(format, AMEDIAFORMAT_KEY_WIDTH, mWidth);</span><br><span class="line">    AMediaFormat_setInt32(format, AMEDIAFORMAT_KEY_HEIGHT, mHeight);</span><br><span class="line"></span><br><span class="line">    AMediaFormat_setInt32(format,AMEDIAFORMAT_KEY_COLOR_FORMAT, COLOR_FORMAT_SURFACE);</span><br><span class="line">    AMediaFormat_setInt32(format, AMEDIAFORMAT_KEY_BIT_RATE, mBitRate);</span><br><span class="line">    AMediaFormat_setInt32(format, AMEDIAFORMAT_KEY_FRAME_RATE, mFps);</span><br><span class="line">    AMediaFormat_setInt32(format, AMEDIAFORMAT_KEY_I_FRAME_INTERVAL, mIFrameInternal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s = AMediaFormat_toString(format);</span><br><span class="line">    log_info(<span class="literal">NULL</span>, <span class="string">"encoder video format: %s"</span>, s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mCodec = AMediaCodec_createEncoderByType(mStrMime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">media_status_t</span> status = AMediaCodec_configure(mCodec, format, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">                                                  AMEDIACODEC_CONFIGURE_FLAG_ENCODE);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">        log_error(<span class="literal">NULL</span>, <span class="string">"AMediaCodec_configure() failed with error %i for format %u"</span>,</span><br><span class="line">                      (<span class="keyword">int</span>) status, <span class="number">21</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    AMediaFormat_delete(format);</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(strPath.c_str(), <span class="string">"wb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mFd = fileno(fp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mFd = <span class="number">-1</span>;</span><br><span class="line">        log_error(<span class="literal">NULL</span>, <span class="string">"create file %s fail"</span>, strPath.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mMuxer == <span class="literal">NULL</span>)</span><br><span class="line">        mMuxer = AMediaMuxer_new(mFd, AMEDIAMUXER_OUTPUT_FORMAT_MPEG_4);</span><br><span class="line"></span><br><span class="line">    mMuxerStarted = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意下配置类型是 “video/avc”，基本视频都是这个格式，可以看官网格式支持信息，比特率mBitRate是6000000，这个要根据需求对应配置，I帧间隔mIFrameInternal是1秒，间隔长获取关键帧信息会有问题。</p><h4 id="编码准备"><a href="#编码准备" class="headerlink" title="编码准备"></a>编码准备</h4><p>编码视频流需要创建一个surface，再把这个surface绑定到共享的EGLContext上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> NativeEncoder::prepareEncoderWithShareCtx(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> fps, <span class="built_in">std</span>::<span class="built_in">string</span> strPath,</span><br><span class="line">                                   EGLContext shareCtx) &#123;</span><br><span class="line"></span><br><span class="line">    prepareEncoder(width,height,fps,strPath);</span><br><span class="line">    ANativeWindow *surface;</span><br><span class="line">    AMediaCodec_createInputSurface(mCodec, &amp;surface);</span><br><span class="line">    <span class="keyword">media_status_t</span> status;</span><br><span class="line">    <span class="keyword">if</span> ((status = AMediaCodec_start(mCodec)) != AMEDIA_OK) &#123;</span><br><span class="line">        log_error(<span class="literal">NULL</span>, <span class="string">"AMediaCodec_start: Could not start encoder."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log_info(<span class="literal">NULL</span>, <span class="string">"AMediaCodec_start: encoder successfully started"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mCodecInputSurface = <span class="keyword">new</span> CodecInputSurface(surface);</span><br><span class="line">    mCodecInputSurface-&gt;setupEGL(shareCtx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编码流程"><a href="#编码流程" class="headerlink" title="编码流程"></a>编码流程</h4><p>编码需要先进行渲染，从外部共享的EGLContext传入一个纹理，渲软到编码器对应的surface上，再进行编码。</p><p>传入纹理并渲染：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeEncoder::feedFrame(<span class="keyword">uint64_t</span> pts, <span class="keyword">int</span> tex) &#123;</span><br><span class="line">    drainEncoder(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    mCodecInputSurface-&gt;makeCurrent();</span><br><span class="line">    glViewport(<span class="number">0</span>,<span class="number">0</span>,mWidth,mHeight);</span><br><span class="line">    mCodecInputSurface-&gt;renderOnSurface(tex);</span><br><span class="line">    mCodecInputSurface-&gt;setPresentationTime(pts);</span><br><span class="line">    mCodecInputSurface-&gt;swapBuffers();</span><br><span class="line">    mCodecInputSurface-&gt;makeNothingCurrent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeEncoder::drainEncoder(<span class="keyword">bool</span> eof) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eof) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> ret = AMediaCodec_signalEndOfInputStream(mCodec);</span><br><span class="line">        log_info(<span class="literal">NULL</span>, <span class="string">"drainEncoder eof = %d"</span>,ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        AMediaCodecBufferInfo info;</span><br><span class="line">        <span class="comment">//time out usec 1</span></span><br><span class="line">        <span class="keyword">ssize_t</span> status = AMediaCodec_dequeueOutputBuffer(mCodec, &amp;info, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status == AMEDIACODEC_INFO_TRY_AGAIN_LATER) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!eof) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log_info(<span class="literal">NULL</span>, <span class="string">"video no output available, spinning to await EOS"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AMEDIACODEC_INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">            <span class="comment">// not expected for an encoder</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AMEDIACODEC_INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mMuxerStarted) &#123;</span><br><span class="line">                log_warning(<span class="literal">NULL</span>, <span class="string">"format changed twice"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AMediaFormat *fmt = AMediaCodec_getOutputFormat(mCodec);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *s = AMediaFormat_toString(fmt);</span><br><span class="line">            log_info(<span class="literal">NULL</span>, <span class="string">"video output format %s"</span>, s);</span><br><span class="line"></span><br><span class="line">            mTrackIndex = AMediaMuxer_addTrack(mMuxer, fmt);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mAudioTrackIndex != <span class="number">-1</span> &amp;&amp; mTrackIndex != <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                log_info(<span class="literal">NULL</span>,<span class="string">"AMediaMuxer_start"</span>);</span><br><span class="line">                AMediaMuxer_start(mMuxer);</span><br><span class="line">                mMuxerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint8_t</span> *encodeData = AMediaCodec_getOutputBuffer(mCodec, status, <span class="literal">NULL</span><span class="comment">/* out_size */</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (encodeData == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                log_error(<span class="literal">NULL</span>, <span class="string">"encoder output buffer was null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((info.flags &amp; AMEDIACODEC_BUFFER_FLAG_CODEC_CONFIG) != <span class="number">0</span>) &#123;</span><br><span class="line">                log_info(<span class="literal">NULL</span>, <span class="string">"ignoring AMEDIACODEC_BUFFER_FLAG_CODEC_CONFIG"</span>);</span><br><span class="line">                info.size = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">size_t</span> dataSize = info.size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dataSize != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!mMuxerStarted) &#123;</span><br><span class="line">                    log_error(<span class="literal">NULL</span>, <span class="string">"muxer has't started"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                log_info(<span class="literal">NULL</span>,<span class="string">"AMediaMuxer_writeSampleData video size %d"</span>,dataSize);</span><br><span class="line">                AMediaMuxer_writeSampleData(mMuxer, mTrackIndex, encodeData, &amp;info);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AMediaCodec_releaseOutputBuffer(mCodec, status, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((info.flags &amp; AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!eof) &#123;</span><br><span class="line">                    log_warning(<span class="literal">NULL</span>, <span class="string">"reached end of stream unexpectly"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log_info(<span class="literal">NULL</span>, <span class="string">"video end of stream reached"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了结尾标记，编码时没有操作InputBuffer，因为InputBuffer对应的就是surface的源，所以编码第一步实际是渲软，通过opengl render到surface上再交换缓冲区到surface上；<br>第二步获取到OutputBuffer数据，调用AMediaCodec_getOutputBuffer；<br>第三步合成器写数据，调用AMediaMuxer_writeSampleData然后释放outputBuffer，调用AMediaCodec_releaseOutputBuffer。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结了下MediaCodec在ndk中的使用，MediaCodec是一个非常灵活的api，编解码音视频都是同一个，掌握双缓冲和三板斧就对流程有了非常清楚的了解，对编解码代码也可以不再畏惧了。</p>]]></content>
    
    <summary type="html">
    
      MediaCodec使用详解
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
      <category term="音视频" scheme="http://anddymao.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="C" scheme="http://anddymao.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何对一个大型Android项目进行模块化重构</title>
    <link href="http://anddymao.com/2019/02/02/2019-2-2-%E5%A6%82%E4%BD%95%E5%AF%B9%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%9E%8BAndroid%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E9%87%8D%E6%9E%84/"/>
    <id>http://anddymao.com/2019/02/02/2019-2-2-如何对一个大型Android项目进行模块化重构/</id>
    <published>2019-02-02T04:00:00.000Z</published>
    <updated>2020-01-18T02:16:08.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>相册作为一个系统应用，17年才转到gradle编译，带着很多沉重的包袱，基本只有一个app模块，编译速度慢。<br>同时相册上又有许多新的功能，整体代码量层线性增长，一些相对独立的新功能会把代码资源都放在一个单独文件夹中，但编译时还是编译在同一个app模块里，各部分之前耦合度高。<br>这些单独的模块是不是应该抽离成单独Module？<br>第一问之后又会延伸出下面几个问题：<br>基础组件是不是应该独立出来？<br>各部分代码耦合是不是应该抽离？<br>工具类依赖业务类是否需要重构？</p><h2 id="为什么要模块化"><a href="#为什么要模块化" class="headerlink" title="为什么要模块化"></a>为什么要模块化</h2><p>做一件事得思考利益，讲投入产出。模块化主要有这些好处：<br>1.使各模块解耦，提高代码的可维护性，减小bug产生<br>2.增加模块独立运行和测试能力<br>3.提升编译速度</p><p>对于2各个功能目前都没有单独运行的需求，单独测试有一定需求；对于3提升速度有限必要性不大。<br>1是我们最重要的需求，是长期的好处。模块化后各个组件结构清晰，对于项目维护，新增功能，减少bug，都会有很大的好处。<br>所以这是一件值得做的是，优先级是是重要不紧急。</p><h2 id="如何着手做"><a href="#如何着手做" class="headerlink" title="如何着手做"></a>如何着手做</h2><p>实际模块化也就是代码重构的事，我们日常功能需求比较多，这上面只能用少部分时间。所以我定了一个小步慢走的方案，每周用一天左右的时间进行代码重构。</p><h2 id="思路选择"><a href="#思路选择" class="headerlink" title="思路选择"></a>思路选择</h2><p>思路一：直接外移方案<br>当前app module不动，逐渐外移单独module，让单独module依赖app module，最后app module会全部被外移。<br>这种方案开始影响最小，但不适合我们的项目，因为我们的主工程是非常大的，分支小，app module没法也没必要全部外移拆分，这样外移的小模块依赖大模块，没有意义。</p><p>思路二：先整理后外移方案<br>单独module依赖的东西有统计，网络，preference，imageLoader，基础utils等，那先整理这些基础组件，进行下移，然后再进行独立module的重构，独立module和app module之间要互相不依赖，互相调用使用模块化接口。<br>这种方案对代码的整理较多，这也是我们最终需要做的，最终决定使用这种方案。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="基础组件下移"><a href="#基础组件下移" class="headerlink" title="基础组件下移"></a>基础组件下移</h3><p>提前调研需要独立的模块，分析依赖的基础模块，进行基础组件的下移。<br>下移时尽量轻量进行，命名无非必要不进行更改，需要重构可以后续再进行，确保下移的影响最小。<br>这部分工作是实际最耗时间精力的，因为很多工具类和业务类耦合很严重，需要针对性梳理和划分。</p><h3 id="模块化通信"><a href="#模块化通信" class="headerlink" title="模块化通信"></a>模块化通信</h3><p>独立模块之间如何通信，因为互相有接口调用，所以采用接口化方案，接口定义在公共模块，实现在独立功能模块，然后就需要注册和获取。<br>新建了一个iModule的模块，模块化的类需要依赖此模块，此模块里面有模块化接口的定义，各个模块中做对应实现。app启动时进行模块注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModuleManagerImpl</span> <span class="keyword">implements</span> <span class="title">IModuleManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ModuleManagerImpl"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IModuleManager mModuleManager = <span class="keyword">new</span> ModuleManagerImpl();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Class&lt;? extends IModule&gt;, IModuleImpl&gt; mBuiltinModules = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IModuleManager <span class="title">getModuleManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mModuleManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ModuleManagerImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IModule <span class="title">getModule</span><span class="params">(Class&lt;? extends IModule&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBuiltinModules.get(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addModule</span><span class="params">(Class&lt;? extends IModule&gt; cls, IModuleImpl moduleImpl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mBuiltinModules.put(cls, moduleImpl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ModuleManageImpl保存了一个map，key为IModule接口类，value为IModuleImpl类，这样通过接口就可以获取到对应的实现，进行模块间通信。</p><h3 id="代码隔离"><a href="#代码隔离" class="headerlink" title="代码隔离"></a>代码隔离</h3><p>上面说到app启动时需要进行模块注册，如果在app模块注册的话，app模块就依赖了独立module。<br>我们可以使用gradle的implement进行隔离，implement的作用是依赖的模块的代码不对外暴露给依赖我的模块，如果需要暴露就使用api进行模块引入。<br>新增一个moduleservice，moduleservice依赖所有的独立模块，在moduleservice进行模块注册，没有其它功能仅仅是为了做隔离，app依赖moduleservice，app启动时调用moduleservice的模块注册方法。</p><h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><p>这样我们的应用就分成了这样的结构：</p><p>1.主功能层：app模块，包括主体业务功能<br>2.模块注册层：moduleservice， 用于隔离直接依赖<br>3.独立模块层：包括照片电影，拼图等独立功能模块，以library存在，可单独添加application的测试模块<br>4.基础组件层：包括网络，图片库，统计，基础工具等</p><h3 id="进一步自动化"><a href="#进一步自动化" class="headerlink" title="进一步自动化"></a>进一步自动化</h3><p>这个地方再进一步自动化的话，可以使用gradle插件，在集成时添加依赖，在编译期修改代码，自动添加模块注册方法；<br>自动识别运行的application,对模块留一份单独运行的代码,做到即可做library又可独立测试运行。</p><p>这部分参照一些组件化框架进行了尝试，当前还没有在工程上使用，这些是锦上添花的工作，主要的还是把前面几步完成好，循序渐进。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了相册模块化中的思路，对于一个庞杂的系统应用该如何梳理，实现模块化改造。<br>现在大家经常说的是组件化，和模块化相比更强调组件的复用性。这次梳理没有进行业务的组件梳理，只独立出一些基础功能组件，所以主要基于的还是模块化。<br>组件化，模块化方案思路很多，一定要根据业务需求进行选择，先业务后技术，而不是先技术后业务。<br>当前模块化完成后只是提供基本的框架结构，后续还需一步步优化改进，代码重构是一项持续的工作。</p>]]></content>
    
    <summary type="html">
    
      相册模块化方案及心得
    
    </summary>
    
    
      <category term="Android" scheme="http://anddymao.com/tags/Android/"/>
    
  </entry>
  
</feed>
